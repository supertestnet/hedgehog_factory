<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <script>var nostr_p2p = null;</script>
        <script src="https://supertestnet.github.io/hedgehog-advanced/tapscript.js"></script>
        <script src="https://supertestnet.github.io/hedgehog-advanced/rmd160.js"></script>
        <script src="https://supertestnet.github.io/blind-sig-js/blindSigJS.js"></script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/bolt11.js"></script>
        <script src="https://supertestnet.github.io/nostr_p2p/nostr_p2p.js"></script>
        <script src="https://supertestnet.github.io/bankify/super_nostr.js"></script>
        <script src="https://supertestnet.github.io/nwcjs/nwcjs.js"></script>
        <!-- <script src="https://unpkg.com/@cmdcode/tapscript@1.5.1"></script> -->
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script>
            // Give a blind sig to each user after they pay, then have them change their pubkey. In every subsequent message, the user should give the admin their unblinded signature. This ensures that each user can prove they are allowed in the pool but prevents the admin from knowing which member of the pool paid which admission-invoice.
            // var secret_for_message = hedgehog_factory.bytesToHex( blindSigJS.getRand( 32 ) );
            // var mint_pubkey = new nobleSecp256k1.Point( mint.publicKey.x, mint.publicKey.y );
            // var mint_pubkey_hex = mint_pubkey.toHex( true );
            // var message = new blindSigJS.bsjMsg();
            // var B_ = await message.createBlindedMessageFromString( secret_for_message );
            // var C_ = mint.createBlindSignature( B_ );
            // var C_ = new nobleSecp256k1.Point( C_.x, C_.y );
            // var {C, secret} = message.unblindSignature( C_, mint_pubkey );
            // //C is the unblinded signature. If I give C and secret to the mint, he can derive C from the secret and compare it the C I gave him. If they match, it proves that he signed the secret without ever seeing it.
            // var expected_C = await mint.calculateCVerify( secret );
            // console.log( expected_C.toHex( true ) === C.toHex( true ) );
        </script>
        <script>
            var hedgehog = {
                network: "testnet",
                state: {},
                keypairs: {},
                state_obj: {
                    alices_privkey: null,
                    bobs_privkey: null,
                    alices_pubkey: null,
                    bobs_pubkey: null,
                    multisig_script: null,
                    multisig_tree: null,
                    multisig_utxo_info: {},
                    i_was_last_to_send: false,
                    alice_can_revoke: [],
                    bob_can_revoke: [],
                    balances: [],
                    balances_before_most_recent_send: [],
                    balances_before_most_recent_receive: [],
                    alices_revocation_preimages: [],
                    alices_revocation_hashes: [],
                    bobs_revocation_preimages: [],
                    bobs_revocation_hashes: [],
                    txids_to_watch_for: {},
                    latest_force_close_txs: [],
                    extra_outputs: [],
                    pending_htlc: {},
                },
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                bytesToHex: bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" ),
                rmd160: s => {
                    if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                    var hash = RIPEMD160.create();
                    hash.update( new Uint8Array( s ) );
                    return hedgehog.bytesToHex( hash.digest() );
                },
                sha256: async s => {
                    if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                    var hash = await nobleSecp256k1.utils.sha256( new Uint8Array( s ) );
                    return hedgehog.bytesToHex( hash );                    
                },
                waitSomeSeconds: num => {
                    var num = num.toString() + "000";
                    num = Number( num );
                    return new Promise( resolve => setTimeout( resolve, num ) );
                },
                getInvoicePmthash: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var i; for ( i=0; i<decoded[ "tags" ].length; i++ ) {
                        if ( decoded[ "tags" ][ i ][ "tagName" ] == "payment_hash" ) var pmthash = decoded[ "tags" ][ i ][ "data" ].toString();
                    }
                    return pmthash;
                },
                getInvoiceAmount: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var amount = decoded[ "satoshis" ].toString();
                    return Number( amount );
                },
                isValidHex: hex => {
                    if ( !hex ) return;
                    var length = hex.length;
                    if ( length % 2 ) return;
                    try {
                        var bigint = BigInt( "0x" + hex, "hex" );
                    } catch( e ) {
                        return;
                    }
                    var prepad = bigint.toString( 16 );
                    var i; for ( i=0; i<length; i++ ) prepad = "0" + prepad;
                    var padding = prepad.slice( -Math.abs( length ) );
                    return ( padding === hex );
                },
                getVin: ( txid, vout, amnt, addy, sequence ) => {
                    var input = {
                        txid,
                        vout,
                        prevout: {
                            value: amnt,
                            scriptPubKey: tapscript.Address.toScriptPubKey( addy ),
                        },
                    }
                    if ( sequence ) input[ "sequence" ] = sequence;
                    return input;
                },
                getVout: ( amnt, addy ) => ({
                    value: amnt,
                    scriptPubKey: tapscript.Address.toScriptPubKey( addy ),
                }),
                makeAddress: ( scripts ) => {
                    console.log( scripts );
                    var tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var pubkey = "ab".repeat( 32 );
                    var [ tpubkey ] = tapscript.Tap.getPubKey( pubkey, { tree });
                    return tapscript.Address.p2tr.fromPubKey( tpubkey, hedgehog.network );
                },
                makeAlicesRevocationScript: chan_id => ([
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    [ "OP_RIPEMD160", hedgehog.state[ chan_id ].alices_revocation_hashes[ hedgehog.state[ chan_id ].alices_revocation_hashes.length - 1 ], "OP_EQUALVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    //TODO: change the 10 to 4032
                    [ 10, "OP_CHECKSEQUENCEVERIFY", "OP_DROP", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                ]),
                makeBobsRevocationScript: chan_id => ([
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    [ "OP_RIPEMD160", hedgehog.state[ chan_id ].bobs_revocation_hashes[ hedgehog.state[ chan_id ].bobs_revocation_hashes.length - 1 ], "OP_EQUALVERIFY", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG" ],
                    //TODO: change the 10 to 4032
                    [ 10, "OP_CHECKSEQUENCEVERIFY", "OP_DROP", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG" ],
                ]),
                makeHTLC: ( chan_id, hash ) => ([
                    [ "OP_SIZE", 32, "OP_EQUALVERIFY", "OP_SHA256", hash, "OP_EQUALVERIFY", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                ]),
                openChannel: async ( push_all_funds_to_counterparty, bobs_pubkey_and_hash = null, papa_swap_hash = null, utxos_for_papa_swap = null, deposit_amount = null, change_address = null, data = null, alices_privkey = null, txinfo = null ) => {
                    //note that in the version of hedgehog I use in hedgehog_factory, the roles of Alice
                    //and Bob are flipped -- Alice always acts as the one opening a channel to Bob so that
                    //she can push all the funds to his side, that way, when Bob funds the factory address,
                    //all funds in all channels are fully on *his* side, and Alice has a bunch of inbound
                    //capacity
                    //there are three ways to open a channel:
                    //the first way is as Alice, opening a channel to Bob unilaterally
                    //the code for that appears after this "if" statement (not in it) because a
                    //unilateral channel open requires pushing all funds to your counterparty
                    //the second way is as Bob, accepting a channel Alice already unilaterally opened
                    //the third way is as Bob, opening a new channel cooperatively with Alice
                    //the second and third ways are handled in the first "if" statement below
                    //in theory there are two more ways: Alice could open a channel to Bob cooperatively
                    //and thus keep some or all of the funds on his side, or Bob could open a channel
                    //to Alice unilaterally and thus push all funds to Alice's side. To do these examples,
                    //just have Bob open a channel with push_all_funds_to_counterparty set to true
                    //or have Alice open a channel with push_all_funds_to_counterparty set to false
                    if ( !push_all_funds_to_counterparty ) {
                        if ( !data ) {
                            var has_data = confirm( `Click ok if someone sent you channel opening info or cancel if you are opening this channel yourself` );
                        } else {
                            has_data = true;
                        }
                        if ( has_data ) {
                            if ( !data ) data = JSON.parse( prompt( `Enter the data your counterparty sent you` ) );
                            //TODO: validate the data so you don't acccidentally accept irredeemable coins
                            //or crash your wallet

                            //create the state object
                            var pubkey = data[ "recipient_pubkey" ];
                            if ( !( pubkey in hedgehog.keypairs ) ) return alert( `Your counterparty tried to scam you! Do not interact with them any further` );
                            var privkey = hedgehog.keypairs[ pubkey ][ "privkey" ];
                            var preimage = hedgehog.keypairs[ pubkey ][ "preimage" ];
                            var chan_id = data[ "chan_id" ];
                            hedgehog.state[ chan_id ] = JSON.parse( JSON.stringify( hedgehog.state_obj ) );
                            hedgehog.state[ chan_id ][ "bobs_privkey" ] = privkey;
                            hedgehog.state[ chan_id ][ "bobs_pubkey" ] = pubkey;
                            hedgehog.state[ chan_id ][ "alices_pubkey" ] = data[ "sender_pubkey" ];
                            hedgehog.state[ chan_id ][ "multisig_utxo_info" ] = data[ "utxo_info" ];
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                            var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                            hedgehog.state[ chan_id ].bobs_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].bobs_pubkey ], hedgehog.network );
                            hedgehog.state[ chan_id ].alices_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].alices_pubkey ], hedgehog.network );
                            var multisig_script = [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ];
                            var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                            hedgehog.state[ chan_id ].multisig_script = multisig_script;
                            hedgehog.state[ chan_id ].multisig_tree = multisig_tree;
                            hedgehog.state[ chan_id ].multisig = hedgehog.makeAddress( [ multisig_script ] );

                            //temporarily pretend the entire balance is on Alice's side so she can
                            //send it to Bob using the regular send command
                            var amnt = data[ "amnt" ];
                            hedgehog.state[ chan_id ].balances = [ amnt, 0 ];
                            var opening = true;

                            //validate the initial state using the regular "receive" function
                            var opened = await hedgehog.receive( {amnt: amnt - 500 - 500, sig_1: data[ "sig_1" ], sig_3: data[ "sig_3" ], chan_id: data[ "chan_id" ], hash: data[ "hash" ]} );
                            if ( opened !== true ) return;

                            //update the state to reflect Bob's ability to withdraw 100%
                            hedgehog.state[ chan_id ].balances = [ 0, amnt ];

                            //update the send/receive/close buttons to use this channel
                            // $( '.send_btn' ).onclick = () => {console.log( "send this data to your recipient:" );console.log( JSON.stringify( hedgehog.send( chan_id ) ) );}
                            // $( '.receive_btn' ).onclick = () => {hedgehog.receive();}
                            // $( '.close_channel' ).onclick = () => {hedgehog.closeChannel( chan_id );}
                            // $( '.send_htlc_btn' ).onclick = async () => {
                            //     var chan_id = Object.keys( hedgehog.state )[ 0 ];
                            //     var amnt = Number( prompt( `enter an amount of sats you want to send to the htlc` ) );
                            //     var info_for_bob = await hedgehog.aliceSendsHtlc( chan_id, amnt );
                            // }
                            // alert( `yay, your channel is open!` );
                            return true;
                        } else {
                            // In this way, Bob does *not* receive data from Alice but instead
                            // opens a channel to her *cooperatively.* It is not yet implemented
                        }
                        return;
                    }

                    //handle the case where Alice opens a channel to Bob unilaterally
                    //start by preparing the state object
                    var chan_id = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    hedgehog.state[ chan_id ] = JSON.parse( JSON.stringify( hedgehog.state_obj ) );
                    if ( !alices_privkey ) hedgehog.state[ chan_id ].alices_privkey = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    else hedgehog.state[ chan_id ].alices_privkey = alices_privkey;
                    hedgehog.state[ chan_id ].alices_pubkey = nobleSecp256k1.getPublicKey( hedgehog.state[ chan_id ].alices_privkey, true ).substring( 2 );
                    if ( !bobs_pubkey_and_hash ) bobs_pubkey_and_hash = JSON.parse( prompt( `Enter Bob's pubkey and revocation hash` ) );
                    hedgehog.state[ chan_id ].bobs_pubkey = bobs_pubkey_and_hash[ 0 ];
                    hedgehog.state[ chan_id ].bobs_revocation_hashes.push( bobs_pubkey_and_hash[ 1 ] );
                    hedgehog.state[ chan_id ].bobs_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].bobs_pubkey ], hedgehog.network );
                    hedgehog.state[ chan_id ].alices_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].alices_pubkey ], hedgehog.network );
                    var multisig_script = [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ];
                    var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                    hedgehog.state[ chan_id ].multisig_script = multisig_script;
                    hedgehog.state[ chan_id ].multisig_tree = multisig_tree;
                    hedgehog.state[ chan_id ].multisig = hedgehog.makeAddress( [ multisig_script ] );
                    if ( papa_swap_hash ) {
                        //we are using a papa swap so a transaction needs to go from the multisig to a
                        //revocable address; and a 2 week timelock from the revocable address should give
                        //the funds back to Alice; but if she revokes this path, then of course Bob can
                        //sweep it if Alice tries to use it, because he will have the revocation preimage.
                        var vin = [];
                        var sum = 0;
                        utxos_for_papa_swap.forEach( utxo => {
                            sum = sum + utxo.amnt;
                            vin.push( hedgehog.getVin( utxo.txid, utxo.vout, utxo.amnt, utxo.addy ) );
                        });
                        var papa_swap_funding_tx = tapscript.Tx.create({
                            vin,
                            vout: [hedgehog.getVout( deposit_amount, hedgehog.state[ chan_id ].multisig )],
                        });
                        var deposit_mining_txfee = 500;
                        if ( sum - deposit_amount - deposit_mining_txfee > 330 ) {
                            papa_swap_funding_tx.vout.push( hedgehog.getVout( sum - deposit_amount - deposit_mining_txfee, change_address ) );
                        }
                        var i; for ( i=0; i<papa_swap_funding_tx.vin.length; i++ ) {
                            var utxo = utxos_for_papa_swap[ i ];
                            var sig = tapscript.Signer.taproot.sign( utxo[ "skey" ], papa_swap_funding_tx, 0 ).hex;
                            papa_swap_funding_tx.vin[ i ].witness = [ sig ];
                        }
                        var funding_txhex = tapscript.Tx.encode( papa_swap_funding_tx ).hex;
                        var txid = tapscript.Tx.util.getTxid( papa_swap_funding_tx );
                        var utxos_created = [];
                        if ( sum - deposit_amount - deposit_mining_txfee > 330 ) {
                            utxos_created.push( {txid, vout: 1, amnt: sum - deposit_amount - deposit_mining_txfee, addy: change_address } );
                        }
                        var vout = 0;
                        var amnt = deposit_amount;

                        var revocable_scripts = [
                            [
                                2016,
                                "OP_CHECKSEQUENCEVERIFY",
                                "OP_DROP",
                                hedgehog.state[ chan_id ].alices_pubkey,
                                "OP_CHECKSIG",
                            ],
                            [
                                "OP_SIZE",
                                32,
                                "OP_EQUALVERIFY",
                                "OP_SHA256",
                                papa_swap_hash,
                                "OP_EQUALVERIFY",
                                hedgehog.state[ chan_id ].bobs_pubkey,
                                "OP_CHECKSIG",
                            ]
                        ];

                        var revocable_address = hedgehog.makeAddress( revocable_scripts );

                        hedgehog.state[ chan_id ].multisig_utxo_info = {
                            txid,
                            vout,
                            amnt,
                        }

                        //temporarily pretend the entire balance is on Alice's side so she can
                        //send it to Bob using the regular send command
                        hedgehog.state[ chan_id ].balances = [ amnt, 0 ];

                        //prepare the transaction that moves all funds to Bob's side
                        var opening = true;
                        var sigs_and_stuff = hedgehog.send( chan_id, amnt - 500 - 500, opening );
                        sigs_and_stuff[ "amnt" ] = amnt;

                        //update the state to reflect Bob's ability to withdraw 100%
                        hedgehog.state[ chan_id ].balances = [ 0, amnt ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ 0, amnt ];

                        // update the send/receive/close buttons to use this channel
                        // $( '.send_btn' ).onclick = () => {console.log( "send this data to your recipient:" );console.log( JSON.stringify( hedgehog.send( chan_id ) ) );}
                        // $( '.receive_btn' ).onclick = () => {hedgehog.receive();}
                        // $( '.close_channel' ).onclick = () => {hedgehog.closeChannel( chan_id );}
                        // alert( `yay, your channel is funded! send your counterparty the info in your console` );
                        return [ chan_id, sigs_and_stuff, funding_txhex, utxos_created ];
                    }
                    console.log( "address:", hedgehog.state[ chan_id ].multisig );

                    if ( !txinfo ) {
                        var txid = prompt( `send some sats to this address and give the txid:\n\n${hedgehog.state[ chan_id ].multisig}` );
                        var vout = Number( prompt( `and the vout` ) );
                        var amnt = Number( prompt( `and the amount` ) );
                    } else {
                        var txid = txinfo[ 0 ];
                        var vout = txinfo[ 1 ];
                        var amnt = txinfo[ 2 ];
                    }
                    hedgehog.state[ chan_id ].multisig_utxo_info = {
                        txid,
                        vout,
                        amnt,
                    }

                    //temporarily pretend the entire balance is on Alice's side so she can
                    //send it to Bob using the regular send command
                    hedgehog.state[ chan_id ].balances = [ amnt, 0 ];

                    //prepare the transaction that moves all funds to Bob's side
                    var opening = true;
                    console.log( chan_id, amnt - 500 - 500, opening );
                    var sigs_and_stuff = hedgehog.send( chan_id, amnt - 500 - 500, opening );
                    sigs_and_stuff[ "amnt" ] = amnt;
                    console.log( "send this data to your recipient:" );
                    console.log( JSON.stringify( sigs_and_stuff ) );

                    //update the state to reflect Bob's ability to withdraw 100%
                    hedgehog.state[ chan_id ].balances = [ 0, amnt ];
                    hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ 0, amnt ];

                    //update the send/receive/close buttons to use this channel
                    // $( '.send_btn' ).onclick = () => {console.log( "send this data to your recipient:" );console.log( JSON.stringify( hedgehog.send( chan_id ) ) );}
                    // $( '.receive_btn' ).onclick = () => {hedgehog.receive();}
                    // $( '.close_channel' ).onclick = () => {hedgehog.closeChannel( chan_id );}
                    // alert( `yay, your channel is funded! send your counterparty the info in your console` );
                    return sigs_and_stuff;
                },
                send: ( chan_id, amnt, opening, skip_pending_check ) => {
                    if ( !skip_pending_check && Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot send money while you have one...clear it before proceeding` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_send;
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                    }

                    //unless an amount is already given, prompt the user to enter an amount
                    if ( !amnt ) amnt = Number( prompt( `Please enter an amount you want to send to your counterparty` ) );

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Bob but I sent him 5k,
                    //current_balances would say he has 5k. If I am now
                    //sending him 1k, amnt should be 6k, which is 
                    //( current_balances[ 1 ] - prev_balance[ 1 ] ) + amnt
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                        else amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                    }

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create and sign the timeout tx in case your counterparty takes
                    //too long to force close or disappears during a force closure
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    //tx0 sends all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    console.log( 85, JSON.stringify( tx0 ) );
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    if ( am_alice ) var my_address = alices_address;
                    else var my_address = bobs_address;
                    var timeout_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 10 to 4032
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                    });
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var timeout_tx_script = latest_scripts[ 2 ];
                    var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                    var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: timeout_tx_tree, target: timeout_tx_target });
                    timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                    hedgehog.state[ chan_id ].txids_to_watch_for[ tx0_id ] = {
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                    }

                    //create tx1 to distribute the funds however the sender wishes to do so
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [],
                    });

                    //increase the recipient's balance by amnt and decrease the sender's by
                    //amnt and two mining fees
                    if ( am_alice ) {
                        var amnt_for_alice = balances[ 0 ] - amnt - 500 - 500;
                        var amnt_for_bob = balances[ 1 ] + amnt;
                    } else {
                        var amnt_for_alice = balances[ 0 ] + amnt;
                        var amnt_for_bob = balances[ 1 ] - amnt - 500 - 500;
                        if ( opening ) var amnt_for_bob = 0;
                    }
                    if ( am_alice ) {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }
                    // console.log( 87, JSON.stringify( tx1 ) );
                    // console.log( "tx0:", JSON.stringify( tx0 ) );
                    // console.log( "tx1:", JSON.stringify( tx1 ) );

                    //Sign both of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    //sig_3 is for tx1 and it has a relative timelock of 2016 blocks
                    //because tx1's only input (see above) has sequence number 2016
                    var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;

                    //If necessary, create a revocation sig that conditionally revokes
                    //the prior state
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, prepare to reveal whichever preimage fully revokes
                    //the state prior to the prior state (yes, doubly prior)
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chan_id ].alices_revocation_preimages[ hedgehog.state[ chan_id ].alices_revocation_preimages.length - 2 ];
                        else var full_revocation_preimage = hedgehog.state[ chan_id ].bobs_revocation_preimages[ hedgehog.state[ chan_id ].bobs_revocation_preimages.length - 2 ];
                    }

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                    } else {
                        hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                    }
                    //Create an object to send all this data to the recipient
                    var object = {
                        sig_1,
                        sig_3,
                        hash,
                        amnt,
                        chan_id,
                    }
                    if ( conditional_revocation_sig ) object[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;
                    if ( opening ) object[ "utxo_info" ] = utxo_info;
                    if ( opening ) object[ "sender_pubkey" ] = hedgehog.state[ chan_id ].bobs_pubkey;
                    if ( opening ) object[ "recipient_pubkey" ] = hedgehog.state[ chan_id ].alices_pubkey;

                    //update the balances
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                    } else {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = true;

                    return object;
                },
                receive: async ( data, skip_pending_check ) => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];

                    if ( !skip_pending_check && Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot receive money in this channel while you have one...clear it before proceeding` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) {
                            if ( amnt <= hedgehog.state[ chan_id ].balances[ 0 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 0 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );                            
                        } else {
                            if ( amnt <= hedgehog.state[ chan_id ].balances[ 1 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 1 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );
                        }
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_receive;
                        if ( !hedgehog.state[ chan_id ].balances.length ) {
                            var sum = current_balances[ 0 ] + current_balances[ 1 ];
                            if ( am_alice ) hedgehog.state[ chan_id ].balances = [ 0, sum ];
                            else hedgehog.state[ chan_id ].balances = [ sum, 0 ];
                        }
                        if ( am_alice ) {
                            var old_rev_hashes = hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].alice_can_revoke.pop();
                        } else {
                            var old_rev_hashes = hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].bob_can_revoke.pop();
                        }
                    }

                    //push your counterparty's payment hash to their hashes object
                    if ( am_alice ) hedgehog.state[ chan_id ].bobs_revocation_hashes.push( data[ "hash" ] );
                    else hedgehog.state[ chan_id ].alices_revocation_hashes.push( data[ "hash" ] );

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create tx0 to send all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var amnt = data[ "amnt" ];
                    var balances = hedgehog.state[ chan_id ].balances;
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    console.log( 86, JSON.stringify( tx0 ) );
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                    //create tx1 to distribute the funds however the sender wishes to do so
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [],
                    });

                    //increase the recipient's balance by amnt and decrease the sender's by
                    //amnt and two mining fees
                    if ( am_alice ) {
                        var amnt_for_alice = balances[ 0 ] + amnt;
                        var amnt_for_bob = balances[ 1 ] - amnt - 500 - 500;
                        if ( data_was_here_originally && !skip_pending_check ) var amnt_for_bob = 0;
                    } else {
                        var amnt_for_alice = balances[ 0 ] - amnt - 500 - 500;
                        var amnt_for_bob = balances[ 1 ] + amnt;
                    }
                    if ( am_alice ) {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }
                    // console.log( 88, JSON.stringify( tx1 ) );
                    // console.log( "tx0:", JSON.stringify( tx0 ) );
                    // console.log( "tx1:", JSON.stringify( tx1 ) );

                    //validate the signatures by which the sender creates the new state
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var sig_1 = data[ "sig_1" ];
                    var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                    var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                    var sig_3 = data[ "sig_3" ];
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                    var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );
                    if ( !is_valid_1 || !is_valid_3 ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    //Sign both of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;

                    //If necessary, validate the signature by which the sender
                    //conditionally revokes the old state and cosign the revocation
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( !( "conditional_revocation_sig" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = data[ "conditional_revocation_sig" ];
                        var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                        var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                        if ( !conditional_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                        var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, validate the preimage by which the sender
                    //fully revokes the old state and sign the revocation
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( !( "full_revocation_preimage" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 1 ];
                        var preimage = data[ "full_revocation_preimage" ];
                        var expected_hash = prev_scripts[ 1 ][ 1 ];
                        var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                        if ( hash_provided != expected_hash ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                        }
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var tx2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        var tx2_script = prev_scripts[ 1 ];
                        var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                        var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                    }

                    //prepare and save the force closure initiation transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx0_tree, target: tx0_target });
                    //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                    //the first sig must be sig_2 -- which means it must be in the "last"
                    //position (i.e. the sig created by Alice must appear right before her pubkey)
                    if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                    else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                    //prepare the force closure finalization transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx1_tree, target: tx1_target });
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                    else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx1_tree, target: new_tx1_target });
                        if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                        else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                    }

                    //if necessary, prepare and save the full revocation transaction
                    if ( full_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx2_tree, target: tx2_target });
                        tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                    }

                    //save the transactions
                    hedgehog.state[ chan_id ].latest_force_close_txs = [
                        tapscript.Tx.encode( tx0 ).hex,
                        tapscript.Tx.encode( tx1 ).hex,
                    ];
                    if ( conditional_revocation_is_necessary ) {
                        hedgehog.state[ chan_id ].txids_to_watch_for[ prev_txid ] = {
                            conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                        }
                    }
                    if ( full_revocation_is_necessary ) hedgehog.state[ chan_id ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                    //update the balances
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                    } else {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = false;

                    return true;
                },
                aliceSendsHtlc: async ( chan_id, amnt, htlc_hash = null, invoice_to_pay ) => {
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and you want to make an htlc worth less than that, i.e. only ${amnt} sats, so it cannot be done -- the software refuses and your only recourse is to find or make a modified version that allows dust htlcs` );
                    console.log( amnt );
                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot send money while you have one...clear it before proceeding` );
                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;
                    if ( !am_alice ) return;

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_send;
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                    }

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Bob but I sent him 5k,
                    //current_balances would say he has 5k. If I am now
                    //sending him 1k, amnt should be 6k, which is 
                    //( current_balances[ 1 ] - prev_balance[ 1 ] ) + amnt
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                        else amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                    }

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create and sign the timeout tx in case your counterparty takes
                    //too long to force close or disappears during a force closure
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    //tx0 sends all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    if ( am_alice ) var my_address = alices_address;
                    else var my_address = bobs_address;
                    var timeout_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 10 to 4032
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                    });
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var timeout_tx_script = latest_scripts[ 2 ];
                    var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                    var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: timeout_tx_tree, target: timeout_tx_target });
                    timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                    hedgehog.state[ chan_id ].txids_to_watch_for[ tx0_id ] = {
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                    }

                    //create the htlc
                    if ( !htlc_hash ) {
                        var htlc_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                        htlc_hash = await hedgehog.sha256( hedgehog.hexToBytes( htlc_preimage ) );
                    } else {
                        var htlc_preimage = null;
                    }
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 1996
                        //note that it is 20 blocks less than 2016 because below, we will give
                        //second_from_htlc_tx a timelock of 2026, 10 blocks longer than any LN invoice (so the
                        //operator can't be screwed by paying a 2016 block lightning invoice),
                        //and we want the sum of that timelock plus this one (2026+1996) to be
                        //10 blocks less than 4032, that way the operator can't be stolen from
                        //on the grounds that he disappeared
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create first_from_htlc_tx to disperse the funds from the htlc to the new state if
                    //Bob discloses his knowledge of the preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                            hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                        ],
                    });

                    //create second_from_htlc_tx to disperse the funds from the htlc to the current state
                    //if Bob does not disclose his knowledge of the preimage in time
                    var amnt_for_alice = balances[ 0 ] - 500 - 500 - 500;
                    var amnt_for_bob = balances[ 1 ];
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2026
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    //sig_3 is for tx1 and it has a relative timelock of 1996 blocks
                    //because tx1's only input (see above) has sequence number 1996
                    var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    //alices_first_htlc_sig is for first_from_htlc_tx which lets Bob create the latest
                    //state if he learns the preimage
                    var alices_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    //alices_second_htlc_sig is for second_from_htlc_tx which restores the current state
                    //if Bob doesn't learn the preimage in time
                    var alices_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;

                    //If necessary, create a revocation sig that conditionally revokes
                    //the prior state
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                                hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                            ],
                        });
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2026
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                        var alices_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var alices_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    }

                    //If necessary, prepare to reveal whichever preimage fully revokes
                    //the state prior to the prior state (yes, doubly prior)
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chan_id ].alices_revocation_preimages[ hedgehog.state[ chan_id ].alices_revocation_preimages.length - 2 ];
                        else var full_revocation_preimage = hedgehog.state[ chan_id ].bobs_revocation_preimages[ hedgehog.state[ chan_id ].bobs_revocation_preimages.length - 2 ];
                    }

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                    } else {
                        hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = true;

                    //collect info to send to bob
                    var info_for_bob = {
                        alices_first_htlc_sig,
                        alices_second_htlc_sig,
                        htlc_hash,
                        hash,
                        amnt,
                        chan_id,
                        alices_conditional_first_htlc_sig,
                        alices_conditional_second_htlc_sig,
                    }

                    //don't send the rest of the data til Bob cosigns first_from_htlc_tx and second_from_htlc_tx
                    //and the conditional versions thereof
                    // console.log( `send this info to bob:` );
                    // console.log( JSON.stringify( info_for_bob ) );
                    var recipient = $_GET[ "layer2" ];
                    var depositor_id = Object.keys( l2generator.state.depositor_data )[ 0 ];
                    var nostr_privkey = l2generator.state.depositor_data[ depositor_id ].nostr_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var secret = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "initiate_ln_payment",
                        msg: {
                            info_for_bob,
                            secret,
                            invoice_to_pay,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_bob = await hedgehog_factory.getNote( secret );
                    delete hedgehog_factory.retrievables[ secret ];
                    var { secret_for_responding_to_bob } = JSON.parse( preparsed_info_from_bob );
                    var info_from_bob = JSON.parse( preparsed_info_from_bob )[ "data_for_alice" ];
                    var { bobs_first_htlc_sig, bobs_second_htlc_sig, bobs_conditional_first_htlc_sig, bobs_conditional_second_htlc_sig } = info_from_bob;
                    // var { bobs_first_htlc_sig, bobs_second_htlc_sig, bobs_conditional_first_htlc_sig, bobs_conditional_second_htlc_sig } = JSON.parse( prompt( `send the info in your console to bob and enter his reply -- btw he should be running hedgehog.bobReceivesHTLC()` ) );

                    //validate the sigs
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_first_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_first_htlc_sig, first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var bobs_second_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_second_htlc_sig, second_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var new_first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_conditional_htlc_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_first_htlc_sig, new_first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var new_second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var bobs_conditional_htlc_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_second_htlc_sig, new_second_from_htlc_tx_sighash, pubkey_to_validate_against );
                    if ( !bobs_first_htlc_sig_is_valid || !bobs_second_htlc_sig_is_valid || !bobs_conditional_htlc_1_sig_is_valid || !bobs_conditional_htlc_2_sig_is_valid ) {
                        //restore previous state
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                        return;
                    }

                    //send bob the rest of the data

                    //Create an object to send all this data to the recipient
                    //but don't send him the htlc_preimage -- that's for Alice
                    //only
                    var object = {
                        sig_1,
                        sig_3,
                    }
                    if ( conditional_revocation_sig ) object[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;

                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify( object ),
                            secret: secret_for_responding_to_bob,
                        }
                    });
                    var recipient = $_GET[ "layer2" ];
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );

                    // console.log( `send this info to bob:` );
                    // console.log( JSON.stringify( object ) );
                    // alert( `send the info in your console to bob and then click ok` );

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    console.log( "prev_tx0:" );
                    console.log( prev_force_close_tx );

                    if ( htlc_preimage ) {
                        console.log( 'here is the preimage your counterparty needs, they should run hedgehog.settleIncomingHTLC() and enter it' );
                        console.log( JSON.stringify({chan_id, preimage: htlc_preimage}) );
                    }

                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "alice",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage,
                        htlc_hash,
                        force_close_tx: prev_force_close_tx,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        restore_current_state_after_force_close: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        when_to_restore_current_state: 2026, //longer than any lightning invoice locktime
                        //note that the timeout_tx is there in case your counterparty disappears after you
                        //force close -- Alice can EITHER sweep the money using the timeout tx after 4032
                        //blocks, if Bob disappears entirely, or -- if she force closes and then Bob at
                        //least sticks around long enough to move the money into the htlc, but then doesn't
                        //disclose the preimage within 2026 blocks, Alice can sweep back her funds using
                        //the new_second_from_htlc_tx
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                        time_til_timeout_tx: 4032,
                    }

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Bob can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Alice's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    hedgehog.state[ chan_id ].balances_before_most_recent_receive = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    //TODO: if you have the preimage, send it to whoever you're sending money to
                    //and remember to also tell them whatever amount you are sending so
                    //they can set up a scenario where they gain that much money if they
                    //disclose the preimage to bob
                },
                bobReceivesHTLC: async ( data, secret_for_responding_to_alice, alices_nostr_pubkey, invoice_to_pay ) => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];

                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot receive money in this channel while you have one...clear it before proceeding` );

                    var amnt = data[ "amnt" ];
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and this htlc is worth only ${amnt} sats so we reject it` );
                    if ( amnt > hedgehog.state[ chan_id ].balances[ 0 ] ) return alert( `alice tried to send you more money than she has so we reject it` );
                    //TODO: ensure checking the invoice here doesn't crash my app
                    var invoice_amt = hedgehog.getInvoiceAmount( invoice_to_pay );
                    //TODO: let the operator charge a fee to pay invoices
                    if ( invoice_amt > amnt ) return alert( `alice tried to send you less money than the invoice she wants you to pay` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( amnt <= hedgehog.state[ chan_id ].balances[ 1 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 1 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_receive;
                        if ( !hedgehog.state[ chan_id ].balances.length ) {
                            var sum = current_balances[ 0 ] + current_balances[ 1 ];
                            if ( am_alice ) hedgehog.state[ chan_id ].balances = [ 0, sum ];
                            else hedgehog.state[ chan_id ].balances = [ sum, 0 ];
                        }
                        if ( am_alice ) {
                            var old_rev_hashes = hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].alice_can_revoke.pop();
                        } else {
                            var old_rev_hashes = hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].bob_can_revoke.pop();
                        }
                    }

                    //push your counterparty's payment hash to their hashes object
                    if ( am_alice ) hedgehog.state[ chan_id ].bobs_revocation_hashes.push( data[ "hash" ] );
                    else hedgehog.state[ chan_id ].alices_revocation_hashes.push( data[ "hash" ] );

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create tx0 to send all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                    //create the htlc
                    var htlc_hash = data[ "htlc_hash" ];
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 1996
                        //note that it is 20 blocks less than 2016 because below, we will give
                        //second_from_htlc_tx a timelock of 2026, 10 blocks longer than any LN invoice (so the
                        //operator can't be screwed by paying a 2016 block lightning invoice),
                        //and we want the sum of that timelock plus this one (2026+1996) to be
                        //10 blocks less than 4032, that way the operator can't be stolen from
                        //on the grounds that he disappeared
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create first_from_htlc_tx to disperse the funds from the htlc to the new state if
                    //Bob discloses his knowledge of the preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                            hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                        ],
                    });

                    //create second_from_htlc_tx to disperse the funds from the htlc to the current state
                    //if Bob does not disclose his knowledge of the preimage in time
                    var amnt_for_alice = balances[ 0 ] - 500 - 500 - 500;
                    var amnt_for_bob = balances[ 1 ];
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2026
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //validate the signatures by which the sender creates the new state
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var alices_first_htlc_sig = data[ "alices_first_htlc_sig" ];
                    var sighash_first_htlc = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var is_valid_first_htlc = await nobleSecp256k1.schnorr.verify( alices_first_htlc_sig, sighash_first_htlc, pubkey_to_validate_against );
                    var alices_second_htlc_sig = data[ "alices_second_htlc_sig" ];
                    var sighash_second_htlc = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var is_valid_second_htlc = await nobleSecp256k1.schnorr.verify( alices_second_htlc_sig, sighash_second_htlc, pubkey_to_validate_against );

                    if ( !is_valid_first_htlc || !is_valid_second_htlc ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    var bobs_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;

                    //If necessary, validate the signature by which the sender
                    //conditionally revokes the old state and cosign the revocation
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                                hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                            ],
                        });
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2026
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var alices_conditional_first_htlc_sig = data[ "alices_conditional_first_htlc_sig" ];
                        var conditional_htlc_1_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var conditional_htlc_1_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_first_htlc_sig, conditional_htlc_1_sighash, pubkey_to_validate_against );
                        var bobs_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var alices_conditional_second_htlc_sig = data[ "alices_conditional_second_htlc_sig" ];
                        var conditional_htlc_2_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var conditional_htlc_2_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_second_htlc_sig, conditional_htlc_2_sighash, pubkey_to_validate_against );
                        var bobs_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        if ( !conditional_htlc_1_is_valid || !conditional_htlc_2_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                    }

                    var data_for_alice = {
                        bobs_first_htlc_sig,
                        bobs_second_htlc_sig,
                    }
                    if ( bobs_conditional_first_htlc_sig ) data_for_alice[ "bobs_conditional_first_htlc_sig" ] = bobs_conditional_first_htlc_sig;
                    if ( bobs_conditional_second_htlc_sig ) data_for_alice[ "bobs_conditional_second_htlc_sig" ] = bobs_conditional_second_htlc_sig;

                    // console.log( `send this data to alice:` );
                    // console.log( JSON.stringify( data_for_alice ) );

                    var l2id = Object.keys( l2generator.state.l2s )[ 0 ];
                    var nostr_privkey = l2generator.state.l2s[ l2id ].l2_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var recipient = alices_nostr_pubkey;
                    var secret_for_responding_to_bob = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify({
                                data_for_alice, secret_for_responding_to_bob
                            }),
                            secret: secret_for_responding_to_alice,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_alice = await hedgehog_factory.getNote( secret_for_responding_to_bob );
                    delete hedgehog_factory.retrievables[ secret_for_responding_to_bob ];
                    var data = JSON.parse( preparsed_info_from_alice );

                    // alert( `send the data in your console to alice and then click ok` );
                    // await hedgehog.waitSomeSeconds( 1 );
                    // var data = JSON.parse( prompt( `enter alice's reply here` ) );

                    //validate the rest of the data sent by your counterparty

                    var sig_1 = data[ "sig_1" ];
                    var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                    var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                    var sig_3 = data[ "sig_3" ];
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                    var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );

                    if ( !is_valid_1 || !is_valid_3 ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    if ( conditional_revocation_is_necessary ) {
                        if ( !( "conditional_revocation_sig" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = data[ "conditional_revocation_sig" ];
                        var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                        var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                        if ( !conditional_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                        var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, validate the preimage by which the sender
                    //fully revokes the old state and sign the revocation
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( !( "full_revocation_preimage" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 1 ];
                        var preimage = data[ "full_revocation_preimage" ];
                        var expected_hash = prev_scripts[ 1 ][ 1 ];
                        var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                        if ( hash_provided != expected_hash ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                        }
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var tx2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        var tx2_script = prev_scripts[ 1 ];
                        var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                        var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                    }

                    //prepare and save the force closure initiation transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx0_tree, target: tx0_target });
                    //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                    //the first sig must be sig_2 -- which means it must be in the "last"
                    //position (i.e. the sig created by Alice must appear right before her pubkey)
                    if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                    else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                    //prepare the force closure finalization transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx1_tree, target: tx1_target });
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                    else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx1_tree, target: new_tx1_target });
                        if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                        else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                    }

                    //prepare the transaction that uses the htlc to create the new state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                    if ( am_alice ) first_from_htlc_tx.vin[ 0 ].witness = [ alices_first_htlc_sig, bobs_first_htlc_sig, first_htlc_script, cblock ];
                    else first_from_htlc_tx.vin[ 0 ].witness = [ bobs_first_htlc_sig, alices_first_htlc_sig, first_htlc_script, cblock ];

                    //prepare the transaction that uses the htlc to restore the current state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    if ( am_alice ) second_from_htlc_tx.vin[ 0 ].witness = [ alices_second_htlc_sig, bobs_second_htlc_sig, second_htlc_script, cblock ];
                    else second_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];

                    //if necessary, prepare and save the full revocation transactions
                    if ( full_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx2_tree, target: tx2_target });
                        tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                    }

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    //save the transactions
                    hedgehog.state[ chan_id ].latest_force_close_txs = [
                        tapscript.Tx.encode( tx0 ).hex,
                        tapscript.Tx.encode( tx1 ).hex,
                    ];
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) {
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                            new_first_from_htlc_tx.vin[ 0 ].witness = [ alices_conditional_first_htlc_sig, bobs_conditional_first_htlc_sig, first_htlc_script, cblock ];
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                            new_second_from_htlc_tx.vin[ 0 ].witness = [ alices_conditional_second_htlc_sig, bobs_conditional_second_htlc_sig, second_htlc_script, cblock ];
                        } else {
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                            new_first_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_first_htlc_sig, alices_conditional_first_htlc_sig, first_htlc_script, cblock ];
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                            new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];
                        }
                        hedgehog.state[ chan_id ].txids_to_watch_for[ prev_txid ] = {
                            conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                            conditional_second_htlc_tx: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        }
                    }
                    if ( full_revocation_is_necessary ) hedgehog.state[ chan_id ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Bob can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Alice's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = false;

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "alice",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage: null,
                        htlc_hash,
                        force_close_tx: tapscript.Tx.encode( tx0 ).hex,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        from_force_close_to_htlc: tapscript.Tx.encode( tx1 ).hex,
                        when_to_fund_htlc: 1996, //shorter than normal so that 4032 blocks is never exceeded
                        unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( first_from_htlc_tx ).hex,
                        restore_current_state_after_force_close: tapscript.Tx.encode( second_from_htlc_tx ).hex,
                        when_to_restore_current_state: 2026, //longer than any lightning invoice locktime
                        txid_to_watch_for: prev_txid,
                        replacement_tx1_if_txid_to_watch_for_is_seen: tapscript.Tx.encode( new_tx1 ).hex,
                        //remember to decode the following tx, then make the preimage the item in
                        //the witness stack closest to the script, then reencode it, then broadcast it
                        conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_first_from_htlc_tx ).hex,
                        restore_current_state_after_replacement_tx1: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        channels_with_pending_outgoing_htlcs_linked_to_this_one: {},
                        time_when_preimage_was_received: null,
                        time_to_wait_after_preimage_is_received: 2016,
                    }

                    //test the following scenarios:

                    // console.log( `first test tx0 (bob) tx1 (bob) second_from_htlc_tx (bob) [tested]` );
                    // console.log( `next test prev_tx0 (alice) replacement_tx1 (bob) new_second_from_htlc_tx (bob) [tested]` );
                    // console.log( `next test prev_tx0 (alice) replacement_tx1 (bob) new_second_from_htlc_tx (alice) [tested by proxy -- I checked that her copy of new_second_from_htlc_tx is identical to bob's, so it will necessarily work too if he broadcasts replacement_tx1]` );
                    // console.log( `next test tx0 (bob) tx1 (bob) first_from_htlc_tx (bob) [tested]` );
                    // console.log( `next test prev_tx0 (alice) replacement_tx1 (bob) new_first_from_htlc_tx (bob) [tested]` );

                    //note that I was gonna have Bob broadcast *his* prev_tx0 and then
                    //have *Alice* broadcast *her* replacement_tx1 but that won't
                    //result in the htlc getting created -- it will just mean they
                    //go to the state *before* the htlc was created, in which Alice
                    //had more money coming to her

                    //TODO: set up a listener to get the preimage from somewhere
                    //or restore the old state after too much time goes by without resolution

                    //i am bob

                    return invoice_to_pay;
                },
                bobSendsHtlc: async ( state_id, amnt, htlc_hash = null, invoice = null, alices_nostr_pubkey ) => {
                    var msg_id = state_id;
                    var state = hedgehog_factory.state[ state_id ];
                    var chan_ids = [];
                    var opening_info = state.opening_info_for_hedgehog_channels[ alices_nostr_pubkey ];
                    opening_info.forEach( opener => chan_ids.push( opener.chan_id ) );
                    var chan_id = chan_ids[ 0 ];
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and you want to make an htlc worth less than that, i.e. only ${amnt} sats, so it cannot be done -- the software refuses and your only recourse is to find or make a modified version that allows dust htlcs` );
                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot send money while you have one...clear it before proceeding` );
                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;
                    if ( am_alice ) return;

                    var recipient = alices_nostr_pubkey;
                    var node = state.node;
                    var nwc_string = state.nwc_string;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var secret = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "get_revocation_data",
                        msg: {
                            secret,
                            state_id,
                            amnt,
                            invoice,
                        }
                    });
                    console.log( 4, 'waiting for this secret:', secret );
                    node.send( 'get_revocation_data', msg, alices_nostr_pubkey, msg_id );
                    console.log( 5 );
                    var preparsed_info_from_alice = await hedgehog_factory.getNote( secret );
                    console.log( 6 );
                    delete hedgehog_factory.retrievables[ secret ];
                    var { alices_revocation_hash, secret_for_responding_to_alice } = JSON.parse( preparsed_info_from_alice );
                    // console.log( JSON.stringify({ chan_id, amnt }) );
                    // var alices_revocation_data = JSON.parse( prompt( 'send the data in your console to alice and enter her reply here -- she should run hedgehog.aliceReceivesHTLC()' ) );
                    // var alices_revocation_hash = alices_revocation_data[ "alices_revocation_hash" ];

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );

                    //prepare objects to collect all the sigs you are about to make for each of Alice's channels
                    var sig_1s = [];
                    var sig_3s = [];
                    var bobs_first_htlc_sigs = [];
                    var bobs_revo_tx_1_sigs = [];
                    var bobs_revo_tx_2_sigs = [];
                    var bobs_second_htlc_sigs = [];
                    // I don't think Alice should know the
                    // restoration sig otherwise once the
                    // money moves into the revocation
                    // address after a new state update
                    // she can broadcast the restoration
                    // tx and restore an old state
                    //bobs_restoration_sig,
                    // I think it is fine for her to have
                    // bobs_second_htlc_sig because that
                    // one is timelocked for 20 blocks
                    // which should give Bob time to
                    // broadcast first_from_htlc_tx
                    // instead -- though this *also*
                    // restores the state created by
                    // this transaction, so I also
                    // ensure Alice can revoke that
                    // state so Bob can penalize her
                    // if she tries to broadcast this
                    // state later -- and this also
                    // means Bob must never have the
                    // sigs he needs to broadcast
                    // first_from_htlc_tx on his own
                    // -- but that's a contradiction
                    // -- I just said he needs to be
                    // able to broadcast that if
                    // Alice restores this state. Ok
                    // maybe he can only do that *if*
                    // her restoration tx reveals a
                    // piece of data he needs to do
                    // that. But duh, of course it
                    // does: Alice alone can restore
                    // this state once Bob has
                    // conditionally revoked it --
                    // he cannot do that on his own
                    // so I think all is well
                    // btw although I won't send
                    // bobs_restoration_sigs to Alice,
                    // I will still make it a thing so
                    // Bob can use it
                    var bobs_restoration_sigs = [];
                    var conditional_revocation_sigs = [];
                    var bobs_cheater_sigs = [];
                    var revocation_hashes = [];
                    var bobs_conditional_first_htlc_sigs = [];
                    var bobs_conditional_second_htlc_sigs = [];
                    var bobs_conditional_revo_tx_1_sigs = [];
                    var bobs_conditional_revo_tx_2_sigs = [];
                    // removing the following one for
                    // the same lengthy reason I gave
                    // above
                    // bobs_conditional_restoration_sig,
                    //but although I do not send the conditional_restoration_sigs
                    //to my counterparty, 
                    var bobs_conditional_restoration_sigs = [];
                    var bobs_conditional_cheater_sigs = [];
                    var tx0s = [];
                    var tx1s = [];
                    var timeout_txs = [];
                    var first_from_htlc_txs = [];
                    var from_revo_tx_1s = [];
                    var from_revo_tx_2s = [];
                    var second_from_htlc_txs = [];
                    var restore_from_revo_txs = [];
                    var bob_tried_to_cheat_txs = [];
                    var prev_tx0s = [];
                    var new_tx1s = [];
                    var new_first_from_htlc_txs = [];
                    var new_from_revo_tx_1s = [];
                    var new_from_revo_tx_2s = [];
                    var new_second_from_htlc_txs = [];
                    var new_restore_from_revo_txs = [];
                    var new_bob_tried_to_cheat_txs = [];

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    var k; for ( k=0; k<chan_ids.length; k++ ) {
                        var chid = chan_ids[ k ];
                        if ( hedgehog.state[ chid ].i_was_last_to_send ) {
                            var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chid ].balances ) );
                            hedgehog.state[ chid ].balances = hedgehog.state[ chid ].balances_before_most_recent_send;
                            if ( am_alice ) {
                                hedgehog.state[ chid ].bob_can_revoke.pop();
                                hedgehog.state[ chid ].alices_revocation_preimages.pop();
                                hedgehog.state[ chid ].alices_revocation_hashes.pop();
                            } else {
                                hedgehog.state[ chid ].alice_can_revoke.pop();
                                hedgehog.state[ chid ].bobs_revocation_preimages.pop();
                                hedgehog.state[ chid ].bobs_revocation_hashes.pop();
                            }
                        }

                        //update the amnt variable if necessary. For example,
                        //if the prev balance was 0 for Alice but I sent her 5k,
                        //current_balances would say she has 5k. If I am now
                        //sending her 1k, amnt should be 6k, which is 
                        //( current_balances[ 0 ] - prev_balance[ 0 ] ) + amnt
                        if ( hedgehog.state[ chid ].i_was_last_to_send ) {
                            if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chid ].balances[ 1 ] ) + amnt;
                            else amnt = ( current_balances[ 0 ] - hedgehog.state[ chid ].balances[ 0 ] ) + amnt;
                        }

                        //create the revocation scripts so the recipient can revoke this state later
                        if ( am_alice ) {
                            var latest_scripts = hedgehog.makeBobsRevocationScript( chid );
                            var revocable_address = hedgehog.makeAddress( latest_scripts );
                            hedgehog.state[ chid ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                        } else {
                            var latest_scripts = hedgehog.makeAlicesRevocationScript( chid );
                            var revocable_address = hedgehog.makeAddress( latest_scripts );
                            hedgehog.state[ chid ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                        }

                        //create and sign the timeout tx in case your counterparty takes
                        //too long to force close or disappears during a force closure
                        var utxo_info = hedgehog.state[ chid ].multisig_utxo_info;
                        var balances = hedgehog.state[ chid ].balances;
                        var original_amnt = balances[ 0 ] + balances[ 1 ];
                        //tx0 sends all the money from the multisig into alice_can_revoke
                        //or bob_can_revoke (depending on who is sending)
                        var tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chid ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                        });
                        tx0s.push( tx0 );
                        var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                        var alices_address = hedgehog.state[ chid ].alices_address;
                        var bobs_address = hedgehog.state[ chid ].bobs_address;
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var timeout_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 10 to 4032
                            vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        timeout_txs.push( timeout_tx );
                        if ( am_alice ) var privkey = hedgehog.state[ chid ].alices_privkey;
                        else var privkey = hedgehog.state[ chid ].bobs_privkey;
                        var timeout_tx_script = latest_scripts[ 2 ];
                        var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                        var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: timeout_tx_tree, target: timeout_tx_target });
                        timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                        hedgehog.state[ chid ].txids_to_watch_for[ tx0_id ] = {
                            timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                        }

                        //create the htlc
                        if ( !htlc_hash ) {
                            var htlc_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                            htlc_hash = await hedgehog.sha256( hedgehog.hexToBytes( htlc_preimage ) );
                        } else {
                            var htlc_preimage = null;
                        }
                        var htlc_scripts = hedgehog.makeHTLC( chid, htlc_hash );
                        var htlc_address = hedgehog.makeAddress( htlc_scripts );

                        //create tx1 to send all the funds into the htlc
                        var tx1 = tapscript.Tx.create({
                            //TODO: there's no sequence number because this is expected to be used
                            //when Alice is receiving a lightning payment, and the htlc will have
                            //a timelock of 20 blocks, 20 because every hop on an LN path increases
                            //the timelock and most wallets have a max timelock of only 2016 blocks
                            //-- but, to ensure Alice isn't screwed if she goes offline for 20
                            //blocks, we'll make it so that, after the 20 blocks expire, Bob can
                            //only sweep the funds into a revocable address that *does* have a
                            //2016 block timelock before he can sweep them from *there* -- and then,
                            //when updating the state, Bob will revoke his ability to withdraw from
                            //the revocable address
                            vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        tx1s.push( tx1 );
                        var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                        //create an address that Alice can revoke later -- I will reuse
                        //makeHTLC for this because she can revoke this one by revealing
                        //its preimage after signing a tx that lets Bob sweep it if he
                        //learns the preimage
                        var alices_revocation_scripts = hedgehog.makeHTLC( chid, alices_revocation_hash );
                        var alices_revocation_address = hedgehog.makeAddress( alices_revocation_scripts );

                        //create first_from_htlc_tx to disperse the funds from the htlc to Alice's
                        //revocation_address if Alice discloses her knowledge of the payment preimage
                        //note that if I previously sent funds to Alice, I have reset the balance to its
                        //prior state, i.e. the state before I sent her money, so the amount in the htlc
                        //will be the previous amount I sent her plus the new amount I am sending her
                        //-- e.g. if she started out with 0 in state A, and then in state B I sent her
                        //3k, and now in state C I am sending her 5k, the htlc will have 8k in it rather
                        //than 5k
                        var first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                                hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                            ],
                        });
                        first_from_htlc_txs.push( first_from_htlc_tx );
                        var first_from_htlc_txid = tapscript.Tx.util.getTxid( first_from_htlc_tx );

                        //note that this revocation path requires Alice to disclose alices_revocation_preimage
                        //which means it uses the first path in alices_revocation_scripts
                        //she should only do this once the new state has been created
                        //if Alice revokes this state the following tx lets Bob sweep the funds
                        var from_revo_tx_1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                            ],
                        });
                        from_revo_tx_1s.push( from_revo_tx_1 );

                        //this one actually disperses the funds to Alice but only after a 20 block timelock
                        //it also uses the second path in alices_revocation_scripts
                        var from_revo_tx_2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                            vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                        });
                        from_revo_tx_2s.push( from_revo_tx_2 );

                        //create an address that Bob can revoke later -- I will reuse
                        //makeHTLC for this because he can revoke this one by revealing
                        //its preimage after signing a tx that lets Alice sweep it if
                        //she learns the preimage
                        var revocation_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                        var revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_preimage ) );
                        revocation_hashes.push( revocation_hash );
                        var revocation_scripts = hedgehog.makeHTLC( chid, revocation_hash );
                        var revocation_address = hedgehog.makeAddress( revocation_scripts );

                        //create second_from_htlc_tx to move the funds into the revocation addy with a 20 block
                        //timelock if Alice does not disclose her knowledge of the preimage in a timely manner
                        var second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 20
                            vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                        });
                        second_from_htlc_txs.push( second_from_htlc_tx );
                        var htlc_2_txid = tapscript.Tx.util.getTxid( second_from_htlc_tx );

                        //create restore_from_revo_tx to disperse the funds from the revocation address to
                        //restore the current state if Bob did not revoke this address (for use when Alice
                        //won't disclose the preimage in the "happy path" so he forces her to do so or go
                        //back to the prior state, or, if he tries to do this just because he thinks she will
                        //be offline for 20 blocks, she gets 2016 blocks to show he revoked this path and
                        //penalize him)
                        //TODO: ensure Alice cannot put the money in the revocation address after Bob revokes
                        //it -- note that I thought for a second Alice could broadcast the *prior* state and
                        //thus force Bob to "update" the state to the one where the money is in the htlc, from
                        //which he is screwed because he can only move it from there to the state where Alice
                        //gets the new state as of this state update, or into the revocation address; but that
                        //is not true for two reasons: first, Alice will revoke that state shortly, so she
                        //cannot do that; and even if she didn't, Alice can only force closes into the state
                        //when she last sent money, in which case she loses the money she gains through this
                        //transaction -- so Bob can just let her lose that money.
                        //And I don't think Alice has any other opportunity to put the money in the revocation
                        //address after Bob revokes it -- he will only revoke it after they've created the
                        //new state and Alice has fully revoked this one, so if she tries to get it into the
                        //revocation address later, she will be screwed
                        var amnt_for_alice = balances[ 0 ];
                        var amnt_for_bob = balances[ 1 ] - 500 - 500 - 500 - 500;
                        var restore_from_revo_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2016
                            vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        restore_from_revo_txs.push( restore_from_revo_tx );

                        //create bob_tried_to_cheat_tx that lets Alice sweep the funds if
                        //Bob tries to restore the current state after revoking it
                        var bob_tried_to_cheat_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                        });
                        bob_tried_to_cheat_txs.push( bob_tried_to_cheat_tx );

                        //Sign all of these transactions, but sign tx1 with a sig that
                        //is only valid after a relative timelock of 2016 blocks expires,
                        //and sign bob_tried_to_cheat_tx with the path that requires
                        //Bob to reveal his preimage for Alice to use it (i.e. the first
                        //path)
                        var tx0_script = hedgehog.state[ chid ].multisig_script;
                        var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                        var tx0_tree = hedgehog.state[ chid ].multisig_tree;
                        var tx1_script = latest_scripts[ 0 ];
                        var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                        var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var first_htlc_script = htlc_scripts[ 0 ];
                        var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                        var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var second_htlc_script = htlc_scripts[ 1 ];
                        var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                        var alices_first_revo_script = alices_revocation_scripts[ 0 ];
                        var alices_first_revo_target = tapscript.Tap.encodeScript( alices_first_revo_script );
                        var alices_second_revo_script = alices_revocation_scripts[ 1 ];
                        var alices_second_revo_target = tapscript.Tap.encodeScript( alices_second_revo_script );
                        var alices_revo_tree = alices_revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var first_revo_script = revocation_scripts[ 0 ];
                        var first_revo_target = tapscript.Tap.encodeScript( first_revo_script );
                        var revo_tree = revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var second_revo_script = revocation_scripts[ 1 ];
                        var second_revo_target = tapscript.Tap.encodeScript( second_revo_script );
                        var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                        var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                        // var sig_1 = nobleSecp256k1.schnorr.sign( sighash_1, privkey );
                        sig_1s.push( sig_1 );
                        var validity = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, hedgehog.state[ chid ].bobs_pubkey );
                        if ( !k ) console.log( sig_1, sighash_1, tx0_target, tx0, hedgehog.state[ chid ].bobs_pubkey, validity, hedgehog.state[ chid ].multisig_utxo_info, "clown" );
                        //sig_3 is for tx1 and it has a relative timelock of 1996 blocks
                        //because tx1's only input (see above) has sequence number 1996
                        var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                        sig_3s.push( sig_3 );
                        //bobs_first_htlc_sig is for first_from_htlc_tx which lets Alice create the latest
                        //state if she discloses the preimage
                        var bobs_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        bobs_first_htlc_sigs.push( bobs_first_htlc_sig );
                        var bobs_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        bobs_revo_tx_1_sigs.push( bobs_revo_tx_1_sig );
                        var bobs_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        bobs_revo_tx_2_sigs.push( bobs_revo_tx_2_sig );

                        //bobs_second_htlc_sig is for second_from_htlc_tx which restores the current state
                        //if Alice doesn't disclose the preimage in time -- or lets Alice sweep all of Bob's
                        //funds if he revokes this state and then puts the money in this state anyway
                        var bobs_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        bobs_second_htlc_sigs.push( bobs_second_htlc_sig );
                        //bobs_restoration_sig is for restore_from_revo_tx which disperses the funds from the
                        //revocation address to restore the current state if Bob did not revoke this address
                        //(for use when Alice won't disclose the preimage in the "happy path" so he forces her
                        //to do so or go back to the prior state, or, if he tries to do this just because he
                        //thinks she will be offline for 20 blocks, she gets 2016 blocks to show he revoked
                        //this path and penalize him)
                        var bobs_restoration_sig = tapscript.Signer.taproot.sign( privkey, restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                        bobs_restoration_sigs.push( bobs_restoration_sig );
                        //bobs_cheater_sig is for bob_tried_to_cheat_tx which lets Alice sweep the funds if
                        //Bob tries to restore the current state after revoking it
                        var bobs_cheater_sig = tapscript.Signer.taproot.sign( privkey, bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                        bobs_cheater_sigs.push( bobs_cheater_sig );

                        //If necessary, create a revocation sig that conditionally revokes
                        //the prior state
                        var conditional_revocation_is_necessary = false;
                        if ( am_alice && hedgehog.state[ chid ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                        if ( !am_alice && hedgehog.state[ chid ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                        if ( conditional_revocation_is_necessary ) {
                            if ( am_alice ) var prev_address = hedgehog.state[ chid ].alice_can_revoke[ hedgehog.state[ chid ].alice_can_revoke.length - 1 ][ 0 ];
                            else var prev_address = hedgehog.state[ chid ].bob_can_revoke[ hedgehog.state[ chid ].bob_can_revoke.length - 1 ][ 0 ];
                            if ( am_alice ) var prev_scripts = hedgehog.state[ chid ].alice_can_revoke[ hedgehog.state[ chid ].alice_can_revoke.length - 1 ][ 1 ];
                            else var prev_scripts = hedgehog.state[ chid ].bob_can_revoke[ hedgehog.state[ chid ].bob_can_revoke.length - 1 ][ 1 ];
                            var prev_tx0 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chid ][ "multisig" ] )],
                                vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                            });
                            prev_tx0s.push( prev_tx0 );
                            var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                            var new_tx1 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                                vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                            });
                            new_tx1s.push( new_tx1 );
                            var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                            var new_first_from_htlc_tx = tapscript.Tx.create({
                                vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                                vout: [
                                    hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                                    hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                                ],
                            });
                            new_first_from_htlc_txs.push( new_first_from_htlc_tx );
                            var new_first_from_htlc_txid = tapscript.Tx.util.getTxid( new_first_from_htlc_tx );
                            var new_from_revo_tx_1 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                                vout: [
                                    hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                                ],
                            });
                            new_from_revo_tx_1s.push( new_from_revo_tx_1 );
                            var new_from_revo_tx_2 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                                vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                            });
                            new_from_revo_tx_2s.push( new_from_revo_tx_2 );
                            var new_second_from_htlc_tx = tapscript.Tx.create({
                                //TODO: change the sequence number (relative timelock) from 5 to 20
                                vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                                vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                            });
                            new_second_from_htlc_txs.push( new_second_from_htlc_tx );
                            var new_htlc_2_txid = tapscript.Tx.util.getTxid( new_second_from_htlc_tx );
                            var new_restore_from_revo_tx = tapscript.Tx.create({
                                //TODO: change the sequence number (relative timelock) from 5 to 2016
                                vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                                vout: [],
                            });
                            if ( am_alice ) {
                                if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                                if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                            } else {
                                if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                                if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                            }
                            new_restore_from_revo_txs.push( new_restore_from_revo_tx );
                            var new_bob_tried_to_cheat_tx = tapscript.Tx.create({
                                vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                                vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                            });
                            new_bob_tried_to_cheat_txs.push( new_bob_tried_to_cheat_tx );

                            var new_tx1_script = prev_scripts[ 0 ];
                            var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                            var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                            var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                            conditional_revocation_sigs.push( conditional_revocation_sig );
                            var bobs_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                            bobs_conditional_first_htlc_sigs.push( bobs_conditional_first_htlc_sig );
                            var bobs_conditional_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, new_from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                            bobs_conditional_revo_tx_1_sigs.push( bobs_conditional_revo_tx_1_sig );
                            var bobs_conditional_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, new_from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                            bobs_conditional_revo_tx_2_sigs.push( bobs_conditional_revo_tx_2_sig );
                            var bobs_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                            bobs_conditional_second_htlc_sigs.push( bobs_conditional_second_htlc_sig );
                            var bobs_conditional_restoration_sig = tapscript.Signer.taproot.sign( privkey, new_restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                            bobs_conditional_restoration_sigs.push( bobs_conditional_restoration_sig );
                            var bobs_conditional_cheater_sig = tapscript.Signer.taproot.sign( privkey, new_bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                            bobs_conditional_cheater_sigs.push( bobs_conditional_cheater_sig );
                        }

                        //If necessary, prepare to reveal whichever preimage fully revokes
                        //the state prior to the prior state (yes, doubly prior)
                        var full_revocation_is_necessary = false;
                        if ( am_alice && hedgehog.state[ chid ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                        if ( !am_alice && hedgehog.state[ chid ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                        if ( full_revocation_is_necessary ) {
                            if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chid ].alices_revocation_preimages[ hedgehog.state[ chid ].alices_revocation_preimages.length - 2 ];
                            else var full_revocation_preimage = hedgehog.state[ chid ].bobs_revocation_preimages[ hedgehog.state[ chid ].bobs_revocation_preimages.length - 2 ];
                        }

                        //use the preimage/hash pair created earlier to prepare for the
                        //next state update
                        if ( am_alice ) {
                            hedgehog.state[ chid ].alices_revocation_preimages.push( preimage );
                            hedgehog.state[ chid ].alices_revocation_hashes.push( hash );
                        } else {
                            hedgehog.state[ chid ].bobs_revocation_preimages.push( preimage );
                            hedgehog.state[ chid ].bobs_revocation_hashes.push( hash );
                        }

                        //update state of who was last to send
                        hedgehog.state[ chid ].i_was_last_to_send = true;
                    }

                    //collect info to send to alice
                    //it is important that Alice not be able
                    //to force Bob to put money into the revocation
                    //address after he has revoked it
                    var info_for_alice = {
                        bobs_first_htlc_sigs,
                        bobs_revo_tx_1_sigs,
                        bobs_revo_tx_2_sigs,
                        bobs_second_htlc_sigs,
                        // I don't think Alice should know the
                        // restoration sig otherwise once the
                        // money moves into the revocation
                        // address after a new state update
                        // she can broadcast the restoration
                        // tx and restore an old state
                        //bobs_restoration_sig,
                        // I think it is fine for her to have
                        // bobs_second_htlc_sig because that
                        // one is timelocked for 20 blocks
                        // which should give Bob time to
                        // broadcast first_from_htlc_tx
                        // instead -- though this *also*
                        // restores the state created by
                        // this transaction, so I also
                        // ensure Alice can revoke that
                        // state so Bob can penalize her
                        // if she tries to broadcast this
                        // state later -- and this also
                        // means Bob must never have the
                        // sigs he needs to broadcast
                        // first_from_htlc_tx on his own
                        // -- but that's a contradiction
                        // -- I just said he needs to be
                        // able to broadcast that if
                        // Alice restores this state. Ok
                        // maybe he can only do that *if*
                        // her restoration tx reveals a
                        // piece of data he needs to do
                        // that. But duh, of course it
                        // does: Alice alone can restore
                        // this state once Bob has
                        // conditionally revoked it --
                        // he cannot do that on his own
                        // so I think all is well
                        bobs_cheater_sigs,
                        htlc_hash,
                        revocation_hashes,
                        hash,
                        amnt,
                        chan_id,
                        bobs_conditional_first_htlc_sigs,
                        bobs_conditional_second_htlc_sigs,
                        bobs_conditional_revo_tx_1_sigs,
                        bobs_conditional_revo_tx_2_sigs,
                        // removing the following one for
                        // the same lengthy reason I gave
                        // above
                        // bobs_conditional_restoration_sig,
                        bobs_conditional_cheater_sigs,
                    }

                    var recipient = alices_nostr_pubkey;
                    var node = state.node;
                    var secret_2_for_responding_to_bob = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify({
                                data: info_for_alice,
                                secret_2_for_responding_to_bob,
                            }),
                            secret: secret_for_responding_to_alice,
                        }
                    });
                    console.log( 7 );
                    node.send( 'secret_you_need', msg, recipient, msg_id );
                    console.log( 8 );
                    var preparsed_info_from_alice = await hedgehog_factory.getNote( secret_2_for_responding_to_bob );
                    console.log( 9 );
                    delete hedgehog_factory.retrievables[ secret_2_for_responding_to_bob ];

                    var { data, secret_2_for_responding_to_alice } = JSON.parse( preparsed_info_from_alice );

                    //don't send the rest of the data til alice cosigns first_from_htlc_tx and second_from_htlc_tx
                    //and the restoration_tx and the conditional versions thereof
                    // console.log( `send this info to alice:` );
                    // console.log( JSON.stringify( info_for_alice ) );
                    // var { alices_first_htlc_sig, alices_revo_tx_1_sig, alices_revo_tx_2_sig, alices_second_htlc_sig, alices_restoration_sig, alices_conditional_first_htlc_sig, alices_conditional_revo_tx_1_sig, alices_conditional_revo_tx_2_sig, alices_conditional_second_htlc_sig, alices_conditional_restoration_sig } = JSON.parse( prompt( `send the info in your console to alice and enter her reply` ) );
                    var { alices_first_htlc_sigs, alices_revo_tx_1_sigs, alices_revo_tx_2_sigs, alices_second_htlc_sigs, alices_restoration_sigs, alices_conditional_first_htlc_sigs, alices_conditional_revo_tx_1_sigs, alices_conditional_revo_tx_2_sigs, alices_conditional_second_htlc_sigs, alices_conditional_restoration_sigs } = data;

                    //validate the sigs
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;

                    var k; for ( k=0; k<chan_ids.length; k++ ) {
                        var chid = chan_ids[ k ];
                        var first_from_htlc_tx = first_from_htlc_txs[ k ];
                        var first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var alices_first_htlc_sig = alices_first_htlc_sigs[ k ];
                        var alices_first_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_first_htlc_sig, first_from_htlc_tx_sighash, pubkey_to_validate_against );
                        var from_revo_tx_1 = from_revo_tx_1s[ k ];
                        var revo_tx_1_sighash = tapscript.Signer.taproot.hash( from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        var alices_revo_tx_1_sig = alices_revo_tx_1_sigs[ k ];
                        var alices_revo_tx_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_revo_tx_1_sig, revo_tx_1_sighash, pubkey_to_validate_against );
                        var from_revo_tx_2 = from_revo_tx_2s[ k ];
                        var revo_tx_2_sighash = tapscript.Signer.taproot.hash( from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        var alices_revo_tx_2_sig = alices_revo_tx_2_sigs[ k ];
                        var alices_revo_tx_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_revo_tx_2_sig, revo_tx_2_sighash, pubkey_to_validate_against );

                        var second_from_htlc_tx = second_from_htlc_txs[ k ];
                        var second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var alices_second_htlc_sig = alices_second_htlc_sigs[ k ];
                        var alices_second_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_second_htlc_sig, second_from_htlc_tx_sighash, pubkey_to_validate_against );

                        var restore_from_revo_tx = restore_from_revo_txs[ k ];
                        var restoration_tx_sighash = tapscript.Signer.taproot.hash( restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                        var alices_restoration_sig = alices_restoration_sigs[ k ];
                        var alices_restoration_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_restoration_sig, restoration_tx_sighash, pubkey_to_validate_against );
                        var new_restore_from_revo_tx = new_restore_from_revo_txs[ k ];
                        var new_restoration_tx_sighash = tapscript.Signer.taproot.hash( new_restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                        var alices_conditional_restoration_sig = alices_conditional_restoration_sigs[ k ];
                        var alices_conditional_restoration_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_restoration_sig, new_restoration_tx_sighash, pubkey_to_validate_against );

                        var new_first_from_htlc_tx = new_first_from_htlc_txs[ k ];
                        var new_first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var alices_conditional_first_htlc_sig = alices_conditional_first_htlc_sigs[ k ];
                        var alices_conditional_htlc_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_first_htlc_sig, new_first_from_htlc_tx_sighash, pubkey_to_validate_against );
                        var new_second_from_htlc_tx = new_second_from_htlc_txs[ k ];
                        var new_second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var alices_conditional_second_htlc_sig = alices_conditional_second_htlc_sigs[ k ];
                        var alices_conditional_htlc_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_second_htlc_sig, new_second_from_htlc_tx_sighash, pubkey_to_validate_against );
                        if ( !alices_first_htlc_sig_is_valid || !alices_second_htlc_sig_is_valid || !alices_conditional_htlc_1_sig_is_valid || !alices_conditional_htlc_2_sig_is_valid || !alices_restoration_sig_is_valid || !alices_conditional_restoration_sig_is_valid || !alices_revo_tx_1_sig_is_valid || !alices_revo_tx_2_sig_is_valid ) {
                            //restore previous state
                            if ( am_alice ) {
                                hedgehog.state[ chid ].bob_can_revoke.pop();
                                hedgehog.state[ chid ].alices_revocation_preimages.pop();
                                hedgehog.state[ chid ].alices_revocation_hashes.pop();
                            } else {
                                hedgehog.state[ chid ].alice_can_revoke.pop();
                                hedgehog.state[ chid ].bobs_revocation_preimages.pop();
                                hedgehog.state[ chid ].bobs_revocation_hashes.pop();
                            }
                            return;
                        }
                    }

                    //send alice the rest of the data

                    //Create an object to send all this data to the recipient
                    //but don't send her the htlc_preimage -- that's for Bob
                    //only
                    //I forgot that Bob will only know the preimage
                    //when he creates an invoice that pays Alice -- in every
                    //other case, Alice will know the preimage and Bob will
                    //be trying to learn it -- so I made a todo to figure out
                    //what to do about that. I thought about it and decided to
                    //make it so that Bob is by default the one who knows
                    //the preimage, and if someone wants this to work
                    //differently they can modify it
                    // var validity_again = await nobleSecp256k1.schnorr.verify( sig_1s[ 0 ], sighash_1, hedgehog.state[ chid ].bobs_pubkey );
                    // console.log( sig_1s[ 0 ], sighash_1, tx0_target, tx0, validity_again );
                    var object = {
                        sig_1s,
                        sig_3s,
                        conditional_revocation_sigs,
                    }
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;

                    var recipient = alices_nostr_pubkey;
                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify( object ),
                            secret: secret_2_for_responding_to_alice,
                        }
                    });
                    var node = state.node;
                    node.send( 'secret_you_need', msg, recipient, msg_id );

                    // console.log( `send this info to alice:` );
                    // console.log( JSON.stringify( object ) );
                    // alert( `send the info in your console to alice and then click ok` );

                    // if ( htlc_preimage ) {
                    //     console.log( 'here is the preimage your counterparty needs, they should run hedgehog.settleIncomingHTLC() and enter it' );
                    //     console.log( JSON.stringify({chan_id, preimage: htlc_preimage}) );
                    // }

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    // console.log( "prev_tx0:" );
                    // console.log( prev_force_close_tx );

                    //if I force close, Alice can broadcast new_tx1, which puts the money in the htlc,
                    //so I need to prepare new_first_from_htlc_tx (which gives Alice her money if this
                    //I also need to prepare new_second_from_htlc_tx. It
                    //moves the money into the revocation address -- if Alice has revoked her state,
                    //I should not broadcast new_second_from_htlc_tx but rather new_first_from_htlc_tx
                    //and then penalize her; otherwise, I have two options: I should either broadcast
                    //new_first_from_htlc_tx if the sender paid me, and that results in Alice getting
                    //her money; or, if he did not, I should broadcast new_second_from_htlc_tx to
                    //restore the current state.
                    //consequently, after new_second_from_htlc_tx I need to prepare
                    //new_restore_from_revo_tx so that I can restore the current state. I also create
                    //"non" conditional versions of those so that if Alice force closes I can react
                    //properly.

                    //is the latest state or will soon let bob penalize her otherwise)
                    //prepare to give Alice her money if this is the latest state
                    //or prepare to sweep it from her if this is not the latest state
                    var k; for ( k=0; k<chan_ids.length; k++ ) {
                        var chid = chan_ids[ k ];
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                        var new_first_from_htlc_tx = new_first_from_htlc_txs[ k ];
                        var bobs_conditional_second_htlc_sig = bobs_conditional_second_htlc_sigs[ k ];
                        var alices_conditional_second_htlc_sig = alices_conditional_second_htlc_sigs[ k ];
                        new_first_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];

                        //actually give Alice her money if this is the latest state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                        var new_from_revo_tx_1 = new_from_revo_tx_1s[ k ];
                        var bobs_conditional_revo_tx_1_sig = bobs_conditional_revo_tx_1_sigs[ k ];
                        var alices_conditional_revo_tx_1_sig = alices_conditional_revo_tx_1_sigs[ k ];
                        new_from_revo_tx_1.vin[ 0 ].witness = [ bobs_conditional_revo_tx_1_sig, alices_conditional_revo_tx_1_sig, alices_first_revo_script, cblock ];

                        //sweep Alice's money if she tries to broadcast old state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                        var new_from_revo_tx_2 = new_from_revo_tx_2s[ k ];
                        var bobs_conditional_revo_tx_2_sig = bobs_conditional_revo_tx_2_sigs[ k ];
                        var alices_conditional_revo_tx_2_sig = alices_conditional_revo_tx_2_sigs[ k ];
                        new_from_revo_tx_2.vin[ 0 ].witness = [ bobs_conditional_revo_tx_2_sig, alices_conditional_revo_tx_2_sig, alices_second_revo_script, cblock ];

                        //prepare to restore the current state if the sender did not pay bob
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                        var new_second_from_htlc_tx = new_second_from_htlc_txs[ k ];
                        var bobs_conditional_second_htlc_sig = bobs_conditional_second_htlc_sigs[ k ];
                        var alices_conditional_second_htlc_sig = alices_conditional_second_htlc_sigs[ k ];
                        new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];

                        //actually restore the current state if the sender did not pay bob
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: revo_tree, target: second_revo_target });
                        var new_restore_from_revo_tx = new_restore_from_revo_txs[ k ];
                        var bobs_conditional_restoration_sig = bobs_conditional_restoration_sigs[ k ];
                        var alices_conditional_restoration_sig = alices_conditional_restoration_sigs[ k ];
                        new_restore_from_revo_tx.vin[ 0 ].witness = [ bobs_conditional_restoration_sig, alices_conditional_restoration_sig, second_revo_script, cblock ];

                        //the unconditional versions of all the above -- in case Alice force closes
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                        var first_from_htlc_tx = first_from_htlc_txs[ k ];
                        var bobs_second_htlc_sig = bobs_second_htlc_sigs[ k ];
                        var alices_second_htlc_sig = alices_second_htlc_sigs[ k ];
                        first_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                        var from_revo_tx_1 = from_revo_tx_1s[ k ];
                        var bobs_revo_tx_1_sig = bobs_revo_tx_1_sigs[ k ];
                        var alices_revo_tx_1_sig = alices_revo_tx_1_sigs[ k ];
                        from_revo_tx_1.vin[ 0 ].witness = [ bobs_revo_tx_1_sig, alices_revo_tx_1_sig, alices_first_revo_script, cblock ];
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                        var from_revo_tx_2 = from_revo_tx_2s [ k ];
                        var bobs_revo_tx_2_sig = bobs_revo_tx_2_sigs[ k ];
                        var alices_revo_tx_2_sig = alices_revo_tx_2_sigs[ k ];
                        from_revo_tx_2.vin[ 0 ].witness = [ bobs_revo_tx_2_sig, alices_revo_tx_2_sig, alices_second_revo_script, cblock ];
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                        var second_from_htlc_tx = second_from_htlc_txs[ k ];
                        var bobs_second_htlc_sig = bobs_second_htlc_sigs[ k ];
                        var alices_second_htlc_sig = alices_second_htlc_sigs[ k ];
                        second_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: revo_tree, target: second_revo_target });
                        var restore_from_revo_tx = restore_from_revo_txs[ k ];
                        var bobs_restoration_sig = bobs_restoration_sigs[ k ];
                        var alices_restoration_sig = alices_restoration_sigs[ k ];
                        restore_from_revo_tx.vin[ 0 ].witness = [ bobs_restoration_sig, alices_restoration_sig, second_revo_script, cblock ];

                        hedgehog.state[ chid ].pending_htlc = {
                            from: "bob",
                            now: Math.floor( Date.now() / 1000 ),
                            amnt,
                            htlc_preimage,
                            htlc_hash,
                            force_close_tx: prev_force_close_tx,
                            conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_first_from_htlc_tx ).hex,
                            conditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_from_revo_tx_1 ).hex,
                            conditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( new_from_revo_tx_2 ).hex,
                            conditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                            conditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_restore_from_revo_tx ).hex,
                            unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( first_from_htlc_tx ).hex,
                            unconditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( from_revo_tx_1 ).hex,
                            unconditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( from_revo_tx_2 ).hex,
                            unconditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( second_from_htlc_tx ).hex,
                            unconditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( restore_from_revo_tx ).hex,
                            //TODO: change the value of when_to_force_close to something more reasonable
                            //than 10 blocks after the htlc is created
                            when_to_force_close: 10,
                            when_to_restore_current_state: 20, //short because I don't want to support hodl invoices yet
                            //note that the timeout_tx is there in case your counterparty disappears after you
                            //force close -- Bob can EITHER sweep the money using the timeout tx after 4032
                            //blocks, if Alice disappears entirely, or -- if he force closes and then Alice at
                            //least sticks around long enough to move the money into the htlc, but then doesn't
                            //disclose the preimage within 20 blocks, Bob can restore the existing state using
                            //the new_second_from_htlc_tx and the restoration_tx
                            timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                            time_til_timeout_tx: 4032,
                        }

                        // console.log( 73, hedgehog.state[ chan_id ].balances_before_most_recent_send );
                        // console.log( 74, hedgehog.state[ chan_id ].balances );

                        //ensure the balances_before_most_recent_send are updated to the current state
                        //so that, after the htlc gets settled, Alice can add amnt to
                        //balances_before_most_recent_send and know that's the amount to expect in
                        //Bob's next state update
                        hedgehog.state[ chid ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chid ].balances ) );
                        hedgehog.state[ chid ].balances_before_most_recent_receive = JSON.parse( JSON.stringify( hedgehog.state[ chid ].balances ) );
                    }

                    console.log( 'htlc sent!' );
                    // console.log( 75, hedgehog.state[ chan_id ].balances );

                    if ( invoice ) {
                        //start listening for the invoice to be paid
                        var loop = async () => {
                            //TODO: if the invoice is not paid quickly and Alice won't cancel it, force close
                            console.log( 'checking invoice status' );
                            var delay_tolerance = 10;
                            var nwc_info = nwcjs.processNWCstring( nwc_string );
                            var invoice_status_info = await nwcjs.checkInvoice( nwc_info, invoice, delay_tolerance );
                            if ( invoice_status_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "result_type" in invoice_status_info && invoice_status_info[ "result_type" ] !== "lookup_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "error" in invoice_status_info && invoice_status_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( invoice_status_info[ "error" ] )} -- please try again` );
                            if ( invoice_status_info.result.settled_at ) {
                                //resolve the htlc
                                var chan_id = chan_ids[ 0 ];
                                var sigs_and_stuff = await hedgehog.checkIfOutgoingHTLCIsSettled( chan_id, invoice_status_info.result.preimage );
                                var msg = JSON.stringify({
                                    type: "payment_complete",
                                    msg: {
                                        chan_id,
                                        preimage: invoice_status_info.result.preimage,
                                        sigs_and_stuff,
                                    }
                                });
                                var node = state.node;
                                node.send( 'payment_complete', msg, recipient, msg_id );
                                super_nostr.sendEvent( event, socket );
                                return;
                            }
                            var loop_delay = state.loop_delay;
                            await super_nostr.waitSomeSeconds( loop_delay );
                            return loop();
                            //Now the htlc is resolved -- the checkIfOutgoingHTLCIsSettled() function sends the amount that *was* in pending_htlc to Alice after Bob gets the preimage, and then it clears out pending_htlc -- so the htlc is resolved
                        }
                        await loop();
                    }

                    //The above sets up a listener to do the rest, namely, it gets a preimage
                    //from the nwc funding source and
                    //uses it to close out the posititon with the sender and the recipient,
                    //TODO: revoke the
                    //revocation_address so that it can't be used
                    //also, rework this so that if the recipient is the one with the preimage,
                    //I only listen for the invoice to be "pending" and then ask the user for
                    //the preimage, then resolve the htlc and revoke the revocation_address
                },
                aliceReceivesHTLC: async data => {
                    console.log( 12 );
                    //TODO: ensure Alice rejects the offer if it contains an htlc_hash she doesn't expect
                    //-- namely, she expects one from a lightning invoice Bob offered to pay her with
                    //she should also reject it if the amount in the invoice she is expecting does not
                    //match the amount offered to her by this htlc -- oh yeah and I just figured out that
                    //she should also *independently* have info from the sender about how much they want to
                    //pay her, that way Bob can't send her an invoice for *less* than that and keep the
                    //difference -- then again, she is the one who hit receive, and then typed in an
                    //amount, so she *should* know how much money to expect
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var secret_for_responding_to_bob = null;
                    var invoice = null;
                    if ( data[ "secret" ] ) secret_for_responding_to_bob = data[ "secret" ];
                    if ( data[ "invoice" ] ) invoice = data[ "invoice" ];
                    var state_id = data[ "state_id" ];
                    var state = hedgehog_factory.state[ state_id ];
                    var msg_id = state_id;
                    var chan_ids = [];
                    var opening_info = state.opening_info_for_hedgehog_channels[ state.pubkey ];
                    opening_info.forEach( opener => chan_ids.push( opener.chan_id ) );
                    var chan_id = chan_ids[ 0 ];
                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot receive money in this channel while you have one...clear it before proceeding` );

                    var amnt = data[ "amnt" ];
                    var amnt_to_be_displayed_in_invoice = amnt;
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and this htlc is worth only ${amnt} sats so we reject it` );
                    if ( amnt > hedgehog.state[ chan_id ].balances[ 1 ] ) return alert( `bob tried to send you more money than he has so we reject it` );

                    //give Bob a revocation hash
                    var alices_revocation_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    var alices_revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( alices_revocation_preimage ) );
                    if ( secret_for_responding_to_bob ) {
                        var recipient = state.all_peers[ 0 ];
                        var node = state.node;
                        var secret_for_responding_to_alice = super_nostr.getPrivkey();
                        var msg = JSON.stringify({
                            type: "secret_you_need",
                            msg: {
                                thing_needed: JSON.stringify({
                                    alices_revocation_hash,
                                    secret_for_responding_to_alice,
                                }),
                                secret: secret_for_responding_to_bob,
                            }
                        });
                        console.log( 13, `waiting for this secret:`, secret_for_responding_to_alice );
                        node.send( 'secret_you_need', msg, recipient, msg_id );
                        console.log( 14 );
                        var preparsed_info_from_bob = await hedgehog_factory.getNote( secret_for_responding_to_alice );
                        console.log( 15, preparsed_info_from_bob );
                        delete hedgehog_factory.retrievables[ secret_for_responding_to_alice ];
                        var data = JSON.parse( preparsed_info_from_bob )[ "data" ];
                        var secret_2_for_responding_to_bob = JSON.parse( preparsed_info_from_bob )[ "secret_2_for_responding_to_bob" ];
                    } else {
                        console.log( JSON.stringify({alices_revocation_hash}) );
                        alert( `send your counterparty the data in your console and then click ok` );
                        await hedgehog.waitSomeSeconds( 1 );
                        var data = JSON.parse( prompt( `enter the data from your counterparty here` ) );
                    }
                    console.log( 15.1 );
                    var new_amnt = data[ "amnt" ];
                    var new_chan_id = data[ "chan_id" ];
                    if ( new_chan_id !== chan_id ) return alert( `aborting because your counterparty tried to scam you with an invalid chan_id` );
                    console.log( 15.2 );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( amnt <= hedgehog.state[ chan_id ].balances[ 1 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 1 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        var k; for ( k=0; k<chan_ids.length; k++ ) {
                            var chid = chan_ids[ k ];
                            hedgehog.state[ chid ].balances = hedgehog.state[ chid ].balances_before_most_recent_receive;
                            if ( !hedgehog.state[ chid ].balances.length ) {
                                var sum = current_balances[ 0 ] + current_balances[ 1 ];
                                if ( am_alice ) hedgehog.state[ chid ].balances = [ 0, sum ];
                                else hedgehog.state[ chid ].balances = [ sum, 0 ];
                            }
                            if ( am_alice ) {
                                var old_rev_hashes = hedgehog.state[ chid ].bobs_revocation_hashes.pop();
                                var other_rev_info = hedgehog.state[ chid ].alice_can_revoke.pop();
                            } else {
                                var old_rev_hashes = hedgehog.state[ chid ].alices_revocation_hashes.pop();
                                var other_rev_info = hedgehog.state[ chid ].bob_can_revoke.pop();
                            }
                        }
                    }
                    console.log( 15.3 );

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Alice but Bob sent her 5k,
                    //current_balances would say she has 5k. If Bob is now
                    //sending her 1k, amnt should be 6k, which is
                    //( current_balances[ 0 ] - prev_balance[ 0 ] ) + amnt
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                        else amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                    }
                    console.log( 15.4 );

                    console.log( 16, `amount Bob is trying to deposit into the htlc:`, new_amnt, 'amount I expect him to deposit:', amnt );
                    if ( new_amnt !== amnt ) return alert( `aborting because your counterparty tried to scam you on the amount. Specifically, he tried to send you ${new_amnt} when you are supposed to receive ${amnt}, per your request, keeping in mind the fact that if Bob was the last person to send money, the amount you receive should look like the previous amount he sent plus the new amount` );

                    var sig_2s = [];
                    var sig_4s = [];
                    var alices_first_htlc_sigs = [];
                    var alices_second_htlc_sigs = [];
                    var alices_restoration_sigs = [];
                    var alices_revo_tx_1_sigs = [];
                    var alices_revo_tx_2_sigs = [];
                    var alices_conditional_first_htlc_sigs = [];
                    var alices_conditional_second_htlc_sigs = [];
                    var alices_conditional_restoration_sigs = [];
                    var alices_conditional_revo_tx_1_sigs = [];
                    var alices_conditional_revo_tx_2_sigs = [];
                    var tx0s = [];
                    var tx1s = [];
                    var first_from_htlc_txs = [];
                    var from_revo_tx_1s = [];
                    var from_revo_tx_2s = [];
                    var second_from_htlc_txs = [];
                    var restore_from_revo_txs = [];
                    var bob_tried_to_cheat_txs = [];
                    var new_tx1s = [];
                    var new_first_from_htlc_txs = [];
                    var new_from_revo_tx_1s = [];
                    var new_from_revo_tx_2s = [];
                    var new_second_from_htlc_txs = [];
                    var new_restore_from_revo_txs = [];
                    var new_bob_tried_to_cheat_txs = [];

                    var k; for ( k=0; k<chan_ids.length; k++ ) {
                        var chid = chan_ids[ k ];
                        //push your counterparty's payment hash to their hashes object
                        if ( am_alice ) hedgehog.state[ chid ].bobs_revocation_hashes.push( data[ "hash" ] );
                        else hedgehog.state[ chid ].alices_revocation_hashes.push( data[ "hash" ] );

                        //create the revocation scripts so the recipient can revoke this state later
                        if ( am_alice ) {
                            var latest_scripts = hedgehog.makeAlicesRevocationScript( chid );
                            var revocable_address = hedgehog.makeAddress( latest_scripts );
                            hedgehog.state[ chid ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                        } else {
                            var latest_scripts = hedgehog.makeBobsRevocationScript( chid );
                            var revocable_address = hedgehog.makeAddress( latest_scripts );
                            hedgehog.state[ chid ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                        }

                        //create tx0 to send all the money from the multisig into alice_can_revoke
                        //or bob_can_revoke (depending on who is sending)
                        var utxo_info = hedgehog.state[ chid ].multisig_utxo_info;
                        var balances = hedgehog.state[ chid ].balances;
                        var alices_address = hedgehog.state[ chid ].alices_address;
                        var bobs_address = hedgehog.state[ chid ].bobs_address;
                        var original_amnt = balances[ 0 ] + balances[ 1 ];
                        var tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chid ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                        });
                        tx0s.push( tx0 );
                        var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                        //create the htlc
                        var htlc_hash = data[ "htlc_hash" ];
                        if ( invoice ) {
                            var invoice_hash = hedgehog.getInvoicePmthash( invoice );
                            if ( htlc_hash !== invoice_hash ) return alert( `bob tried to scam you by giving you an htlc unrelated to the invoice` );
                            var invoice_amt = hedgehog.getInvoiceAmount( invoice );
                            //TODO: consider whether to allow the invoice to pay you less
                            //as a kind of fee for Bob
                            if ( invoice_amt !== amnt_to_be_displayed_in_invoice ) return alert( `bob tried to scam you by giving you an invoice with the wrong amount` );
                        }
                        var htlc_scripts = hedgehog.makeHTLC( chid, htlc_hash );
                        var htlc_address = hedgehog.makeAddress( htlc_scripts );

                        //create tx1 to send all the funds into the htlc
                        var tx1 = tapscript.Tx.create({
                            //TODO: there's no sequence number because this is expected to be used
                            //when Alice is receiving a lightning payment, and the htlc will have
                            //a timelock of 20 blocks, 20 because every hop on an LN path increases
                            //the timelock and most wallets have a max timelock of only 2016 blocks
                            //-- but, to ensure Alice isn't screwed if she goes offline for 20
                            //blocks, we'll make it so that, after the 20 blocks expire, Bob can
                            //only sweep the funds into a revocable address that *does* have a
                            //2016 block timelock before he can sweep them from *there* -- and then,
                            //when updating the state, Bob will revoke his ability to withdraw from
                            //the revocable address
                            vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        tx1s.push( tx1 );
                        var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                        //create an address that Alice can revoke later -- I will reuse
                        //makeHTLC for this because she can revoke this one by revealing
                        //its preimage after signing a tx that lets Bob sweep it if he
                        //learns the preimage
                        var alices_revocation_scripts = hedgehog.makeHTLC( chid, alices_revocation_hash );
                        var alices_revocation_address = hedgehog.makeAddress( alices_revocation_scripts );

                        //create first_from_htlc_tx to disperse the funds from the htlc to Alice's
                        //revocation_address if Alice discloses her knowledge of the payment preimage
                        var first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                                hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                            ],
                        });
                        first_from_htlc_txs.push( first_from_htlc_tx );
                        var first_from_htlc_txid = tapscript.Tx.util.getTxid( first_from_htlc_tx );

                        //note that this revocation path requires Alice to disclose alices_revocation_preimage
                        //which means it uses the first path in alices_revocation_scripts
                        //she should only do this once the new state has been created
                        //if Alice revokes this state the following tx lets Bob sweep the funds
                        var from_revo_tx_1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                            ],
                        });
                        from_revo_tx_1s.push( from_revo_tx_1 );

                        //this one actually disperses the funds to Alice but only after a 20 block timelock
                        //it also uses the second path in alices_revocation_scripts
                        var from_revo_tx_2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                            vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                        });
                        from_revo_tx_2s.push( from_revo_tx_2 );

                        //create an address that Bob can revoke later -- I will reuse
                        //makeHTLC for this because he can revoke this one by revealing
                        //its preimage after signing a tx that lets Alice sweep it if
                        //she learns the preimage
                        var revocation_hash = data[ "revocation_hashes" ][ k ];
                        var revocation_scripts = hedgehog.makeHTLC( chid, revocation_hash );
                        var revocation_address = hedgehog.makeAddress( revocation_scripts );

                        //create second_from_htlc_tx to move the funds into the revocation addy after a 20 block
                        //timelock if Alice does not disclose her knowledge of the preimage in a timely manner
                        var second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 20
                            vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                        });
                        second_from_htlc_txs.push( second_from_htlc_tx );
                        var htlc_2_txid = tapscript.Tx.util.getTxid( second_from_htlc_tx );

                        //create restore_from_revo_tx to disperse the funds from the revocation address to
                        //restore the current state if Bob did not revoke this address (for use when Alice
                        //won't disclose the preimage in the "happy path" so he forces her to do so or go
                        //back to the prior state, or, if he tries to do this just because he thinks she will
                        //be offline for 20 blocks, she gets 2016 blocks to show he revoked this path and
                        //penalize him)
                        //TODO: ensure Alice cannot put the money in the revocation address after Bob revokes
                        //it -- note that I thought for a second Alice could broadcast the *prior* state and
                        //thus force Bob to "update" the state to the one where the money is in the htlc, from
                        //which he is screwed because he can only move it from there to the state where Alice
                        //gets the new state as of this state update, or into the revocation address; but that
                        //is not true for two reasons: first, Alice will revoke that state shortly, so she
                        //cannot do that; and even if she didn't, Alice can only force closes into the state
                        //when she last sent money, in which case she loses the money she gains through this
                        //transaction -- so Bob can just let her lose that money.
                        //And I don't think Alice has any other opportunity to put the money in the revocation
                        //address after Bob revokes it -- he will only revoke it after they've created the
                        //new state and Alice has fully revoked this one, so if she tries to get it into the
                        //revocation address later, she will be screwed
                        var amnt_for_alice = balances[ 0 ];
                        var amnt_for_bob = balances[ 1 ] - 500 - 500 - 500 - 500;
                        var restore_from_revo_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2016
                            vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        restore_from_revo_txs.push( restore_from_revo_tx );

                        //create bob_tried_to_cheat_tx that lets Alice sweep the funds if
                        //Bob tries to restore the current state after revoking it
                        var bob_tried_to_cheat_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                        });
                        bob_tried_to_cheat_txs.push( bob_tried_to_cheat_tx );

                        //validate the signatures by which the sender creates the new state
                        if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chid ].bobs_pubkey;
                        else var pubkey_to_validate_against = hedgehog.state[ chid ].alices_pubkey;
                        var tx0_script = hedgehog.state[ chid ].multisig_script;
                        var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                        var tx0_tree = hedgehog.state[ chid ].multisig_tree;
                        var tx1_script = latest_scripts[ 0 ];
                        var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                        var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var first_htlc_script = htlc_scripts[ 0 ];
                        var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                        var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var second_htlc_script = htlc_scripts[ 1 ];
                        var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                        var alices_first_revo_script = alices_revocation_scripts[ 0 ];
                        var alices_first_revo_target = tapscript.Tap.encodeScript( alices_first_revo_script );
                        var alices_second_revo_script = alices_revocation_scripts[ 1 ];
                        var alices_second_revo_target = tapscript.Tap.encodeScript( alices_second_revo_script );
                        var alices_revo_tree = alices_revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var first_revo_script = revocation_scripts[ 0 ];
                        var first_revo_target = tapscript.Tap.encodeScript( first_revo_script );
                        var revo_tree = revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var second_revo_script = revocation_scripts[ 1 ];
                        var second_revo_target = tapscript.Tap.encodeScript( second_revo_script );
                        var bobs_first_htlc_sig = data[ "bobs_first_htlc_sigs" ][ k ];
                        var sighash_first_htlc = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var is_valid_first_htlc = await nobleSecp256k1.schnorr.verify( bobs_first_htlc_sig, sighash_first_htlc, pubkey_to_validate_against );
                        var bobs_revo_tx_1_sig = data[ "bobs_revo_tx_1_sigs" ][ k ];
                        var revo_tx_1_sighash = tapscript.Signer.taproot.hash( from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        var revo_tx_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_revo_tx_1_sig, revo_tx_1_sighash, pubkey_to_validate_against );
                        var bobs_revo_tx_2_sig = data[ "bobs_revo_tx_2_sigs" ][ k ];
                        var revo_tx_2_sighash = tapscript.Signer.taproot.hash( from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        var revo_tx_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_revo_tx_2_sig, revo_tx_2_sighash, pubkey_to_validate_against );
                        var bobs_second_htlc_sig = data[ "bobs_second_htlc_sigs" ][ k ];
                        var sighash_second_htlc = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var is_valid_second_htlc = await nobleSecp256k1.schnorr.verify( bobs_second_htlc_sig, sighash_second_htlc, pubkey_to_validate_against );
                        // var bobs_restoration_sig = data[ "bobs_restoration_sig" ];
                        // var sighash_restoration = tapscript.Signer.taproot.hash( restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                        // var is_valid_restoration = await nobleSecp256k1.schnorr.verify( bobs_restoration_sig, sighash_restoration, pubkey_to_validate_against );
                        var bobs_cheater_sig = data[ "bobs_cheater_sigs" ][ k ];
                        var sighash_cheater = tapscript.Signer.taproot.hash( bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                        var is_valid_cheater = await nobleSecp256k1.schnorr.verify( bobs_cheater_sig, sighash_cheater, pubkey_to_validate_against );

                        // if ( !is_valid_first_htlc || !is_valid_second_htlc || !is_valid_restoration || !is_valid_cheater ) {
                        if ( !is_valid_first_htlc || !is_valid_second_htlc || !is_valid_cheater ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chid ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chid ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chid ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chid ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                        }

                        //Sign all of these transactions, but sign tx1 with a sig that
                        //is only valid after a relative timelock of 2016 blocks expires.
                        if ( am_alice ) var privkey = hedgehog.state[ chid ].alices_privkey;
                        else var privkey = hedgehog.state[ chid ].bobs_privkey;
                        var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                        sig_2s.push( sig_2 );
                        var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                        sig_4s.push( sig_4 );
                        var alices_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        alices_first_htlc_sigs.push( alices_first_htlc_sig );
                        var alices_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        alices_revo_tx_1_sigs.push( alices_revo_tx_1_sig );
                        var alices_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        alices_revo_tx_2_sigs.push( alices_revo_tx_2_sig );
                        var alices_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        alices_second_htlc_sigs.push( alices_second_htlc_sig );
                        var alices_first_revo_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        var alices_second_revo_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        var alices_restoration_sig = tapscript.Signer.taproot.sign( privkey, restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                        alices_restoration_sigs.push( alices_restoration_sig );
                        var alices_cheater_sig = tapscript.Signer.taproot.sign( privkey, bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;

                        //If necessary, validate the signature by which the sender
                        //conditionally revokes the old state and cosign the revocation
                        var conditional_revocation_is_necessary = false;
                        if ( am_alice && hedgehog.state[ chid ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                        if ( !am_alice && hedgehog.state[ chid ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                        if ( conditional_revocation_is_necessary ) {
                            //TODO: ensure checking this sig doesn't crash the app
                            if ( am_alice ) var prev_address = hedgehog.state[ chid ].bob_can_revoke[ hedgehog.state[ chid ].bob_can_revoke.length - 1 ][ 0 ];
                            else var prev_address = hedgehog.state[ chid ].alice_can_revoke[ hedgehog.state[ chid ].alice_can_revoke.length - 1 ][ 0 ];
                            if ( am_alice ) var prev_scripts = hedgehog.state[ chid ].bob_can_revoke[ hedgehog.state[ chid ].bob_can_revoke.length - 1 ][ 1 ];
                            else var prev_scripts = hedgehog.state[ chid ].alice_can_revoke[ hedgehog.state[ chid ].alice_can_revoke.length - 1 ][ 1 ];
                            var prev_tx0 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chid ][ "multisig" ] )],
                                vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                            });
                            var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                            var new_tx1 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                                vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                            });
                            new_tx1s.push( new_tx1 );
                            var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                            var new_first_from_htlc_tx = tapscript.Tx.create({
                                vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                                vout: [
                                    hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                                    hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                                ],
                            });
                            new_first_from_htlc_txs.push( first_from_htlc_tx );
                            var new_first_from_htlc_txid = tapscript.Tx.util.getTxid( new_first_from_htlc_tx );
                            var new_from_revo_tx_1 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                                vout: [
                                    hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                                ],
                            });
                            new_from_revo_tx_1s.push( new_from_revo_tx_1 );
                            var new_from_revo_tx_2 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                                vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                            })
                            new_from_revo_tx_2s.push( new_from_revo_tx_2 );
                            var new_second_from_htlc_tx = tapscript.Tx.create({
                                //TODO: change the sequence number (relative timelock) from 5 to 20
                                vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                                vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                            });
                            new_second_from_htlc_txs.push( new_second_from_htlc_tx );
                            var new_htlc_2_txid = tapscript.Tx.util.getTxid( new_second_from_htlc_tx );
                            var new_restore_from_revo_tx = tapscript.Tx.create({
                                //TODO: change the sequence number (relative timelock) from 5 to 2016
                                vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                                vout: [],
                            });
                            if ( am_alice ) {
                                if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                                if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                            } else {
                                if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                                if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                            }
                            new_restore_from_revo_txs.push( new_restore_from_revo_tx );
                            var new_bob_tried_to_cheat_tx = tapscript.Tx.create({
                                vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                                vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                            });
                            new_bob_tried_to_cheat_txs.push( new_bob_tried_to_cheat_tx );
                            var bobs_conditional_first_htlc_sig = data[ "bobs_conditional_first_htlc_sigs" ][ k ];
                            var conditional_htlc_1_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                            var conditional_htlc_1_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_first_htlc_sig, conditional_htlc_1_sighash, pubkey_to_validate_against );
                            var alices_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                            alices_conditional_first_htlc_sigs.push( alices_conditional_first_htlc_sig );
                            var bobs_conditional_revo_tx_1_sig = data[ "bobs_conditional_revo_tx_1_sigs" ][ k ];
                            var conditional_revo_tx_1_sighash = tapscript.Signer.taproot.hash( new_from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                            var conditional_revo_tx_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_revo_tx_1_sig, conditional_revo_tx_1_sighash, pubkey_to_validate_against );
                            var alices_conditional_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                            alices_conditional_revo_tx_1_sigs.push( alices_conditional_revo_tx_1_sig );
                            var bobs_conditional_revo_tx_2_sig = data[ "bobs_conditional_revo_tx_2_sigs" ][ k ];
                            var conditional_revo_tx_2_sighash = tapscript.Signer.taproot.hash( new_from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                            var conditional_revo_tx_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_revo_tx_2_sig, conditional_revo_tx_2_sighash, pubkey_to_validate_against );
                            var alices_conditional_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                            alices_conditional_revo_tx_2_sigs.push( alices_conditional_revo_tx_2_sig );
                            var bobs_conditional_second_htlc_sig = data[ "bobs_conditional_second_htlc_sigs" ][ k ];
                            var conditional_htlc_2_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                            var conditional_htlc_2_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_second_htlc_sig, conditional_htlc_2_sighash, pubkey_to_validate_against );
                            var alices_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                            alices_conditional_second_htlc_sigs.push( alices_conditional_second_htlc_sig );
                            var bobs_conditional_cheater_sig = data[ "bobs_conditional_cheater_sigs" ][ k ];
                            var conditional_cheater_sighash = tapscript.Signer.taproot.hash( new_bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                            var conditional_cheater_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_cheater_sig, conditional_cheater_sighash, pubkey_to_validate_against );
                            var alices_conditional_restoration_sig = tapscript.Signer.taproot.sign( privkey, new_restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                            alices_conditional_restoration_sigs.push( alices_conditional_restoration_sig );
                            var alices_conditional_cheater_sig = tapscript.Signer.taproot.sign( privkey, new_bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;

                            if ( !conditional_htlc_1_is_valid || !conditional_htlc_2_is_valid || !conditional_cheater_is_valid || !conditional_revo_tx_1_sig_is_valid || !conditional_revo_tx_2_sig_is_valid ) {
                                //restore old state and inform user this state update was invalid
                                if ( am_alice ) {
                                    hedgehog.state[ chid ].bobs_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].alice_can_revoke.push( other_rev_info );
                                } else {
                                    hedgehog.state[ chid ].alices_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].bob_can_revoke.push( other_rev_info );
                                }
                                return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                            }
                        }
                    }

                    var data_for_bob = {
                        alices_first_htlc_sigs,
                        alices_second_htlc_sigs,
                        alices_restoration_sigs,
                        alices_revo_tx_1_sigs,
                        alices_revo_tx_2_sigs,
                        alices_conditional_first_htlc_sigs,
                        alices_conditional_second_htlc_sigs,
                        alices_conditional_restoration_sigs,
                        alices_conditional_revo_tx_1_sigs,
                        alices_conditional_revo_tx_2_sigs,
                    }

                    if ( secret_for_responding_to_bob ) {
                        var recipient = state.all_peers[ 0 ];
                        var node = state.node;
                        var secret_2_for_responding_to_alice = super_nostr.getPrivkey();
                        var msg = JSON.stringify({
                            type: "secret_you_need",
                            msg: {
                                thing_needed: JSON.stringify({
                                    data: data_for_bob,
                                    secret_2_for_responding_to_alice,
                                }),
                                secret: secret_2_for_responding_to_bob,
                            }
                        });
                        node.send( 'secret_you_need', msg, recipient, msg_id );
                        var preparsed_info_from_bob = await hedgehog_factory.getNote( secret_2_for_responding_to_alice );
                        delete hedgehog_factory.retrievables[ secret_2_for_responding_to_alice ];
                        var data = JSON.parse( preparsed_info_from_bob );
                    } else {
                        console.log( `send this data to bob:` );
                        console.log( JSON.stringify( data_for_bob ) );
                        alert( `send the data in your console to bob and then click ok` );
                        await hedgehog.waitSomeSeconds( 1 );
                        var data = JSON.parse( prompt( `enter bob's reply here` ) );
                    }

                    //validate the rest of the data sent by your counterparty
                    var k; for ( k=0; k<chan_ids.length; k++ ) {
                        var chid = chan_ids[ k ];
                        var sig_1 = data[ "sig_1s" ][ k ];
                        var tx0 = tx0s[ k ];
                        var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                        if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chid ].bobs_pubkey;
                        else var pubkey_to_validate_against = hedgehog.state[ chid ].alices_pubkey;
                        console.log( k, sig_1, sighash_1, tx0_target, tx0, pubkey_to_validate_against );
                        var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                        var sig_3 = data[ "sig_3s" ][ k ];
                        var tx1 = tx1s[ k ];
                        var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                        var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );

                        console.log( 30, k, is_valid_1, is_valid_3 );
                        if ( !is_valid_1 || !is_valid_3 ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chid ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chid ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chid ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chid ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                        }

                        if ( conditional_revocation_is_necessary ) {
                            if ( !( "conditional_revocation_sigs" in data ) ) {
                                //restore old state and inform user this state update was invalid
                                if ( am_alice ) {
                                    hedgehog.state[ chid ].bobs_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].alice_can_revoke.push( other_rev_info );
                                } else {
                                    hedgehog.state[ chid ].alices_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].bob_can_revoke.push( other_rev_info );
                                }
                                return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                            }
                            //TODO: ensure checking this sig doesn't crash the app
                            if ( am_alice ) var prev_address = hedgehog.state[ chid ].bob_can_revoke[ hedgehog.state[ chid ].bob_can_revoke.length - 1 ][ 0 ];
                            else var prev_address = hedgehog.state[ chid ].alice_can_revoke[ hedgehog.state[ chid ].alice_can_revoke.length - 1 ][ 0 ];
                            if ( am_alice ) var prev_scripts = hedgehog.state[ chid ].bob_can_revoke[ hedgehog.state[ chid ].bob_can_revoke.length - 1 ][ 1 ];
                            else var prev_scripts = hedgehog.state[ chid ].alice_can_revoke[ hedgehog.state[ chid ].alice_can_revoke.length - 1 ][ 1 ];
                            var utxo_info = hedgehog.state[ chid ].multisig_utxo_info;
                            var prev_tx0 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chid ][ "multisig" ] )],
                                vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                            });
                            var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                            var new_tx1 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                                vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                            });
                            var new_tx1_script = prev_scripts[ 0 ];
                            var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                            var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                            var conditional_revocation_sig = data[ "conditional_revocation_sigs" ][ k ];
                            var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                            var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                            if ( !conditional_is_valid ) {
                                //restore old state and inform user this state update was invalid
                                if ( am_alice ) {
                                    hedgehog.state[ chid ].bobs_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].alice_can_revoke.push( other_rev_info );
                                } else {
                                    hedgehog.state[ chid ].alices_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].bob_can_revoke.push( other_rev_info );
                                }
                                return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                            }
                            var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                        }

                        //If necessary, validate the preimage by which the sender
                        //fully revokes the old state and sign the revocation
                        var full_revocation_is_necessary = false;
                        if ( am_alice && hedgehog.state[ chid ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                        if ( !am_alice && hedgehog.state[ chid ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                        if ( full_revocation_is_necessary ) {
                            if ( !( "full_revocation_preimage" in data ) ) {
                                //restore old state and inform user this state update was invalid
                                if ( am_alice ) {
                                    hedgehog.state[ chid ].bobs_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].alice_can_revoke.push( other_rev_info );
                                } else {
                                    hedgehog.state[ chid ].alices_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].bob_can_revoke.push( other_rev_info );
                                }
                                return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                            }
                            //TODO: ensure checking this sig doesn't crash the app
                            if ( am_alice ) var prev_address = hedgehog.state[ chid ].bob_can_revoke[ hedgehog.state[ chid ].bob_can_revoke.length - 2 ][ 0 ];
                            else var prev_address = hedgehog.state[ chid ].alice_can_revoke[ hedgehog.state[ chid ].alice_can_revoke.length - 2 ][ 0 ];
                            if ( am_alice ) var prev_scripts = hedgehog.state[ chid ].bob_can_revoke[ hedgehog.state[ chid ].bob_can_revoke.length - 2 ][ 1 ];
                            else var prev_scripts = hedgehog.state[ chid ].alice_can_revoke[ hedgehog.state[ chid ].alice_can_revoke.length - 2 ][ 1 ];
                            var preimage = data[ "full_revocation_preimage" ];
                            var expected_hash = prev_scripts[ 1 ][ 1 ];
                            var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                            if ( hash_provided != expected_hash ) {
                                //restore old state and inform user this state update was invalid
                                if ( am_alice ) {
                                    hedgehog.state[ chid ].bobs_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].alice_can_revoke.push( other_rev_info );
                                } else {
                                    hedgehog.state[ chid ].alices_revocation_hashes.push( old_rev_hashes );
                                    hedgehog.state[ chid ].bob_can_revoke.push( other_rev_info );
                                }
                                return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                            }
                            var prev_tx0 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chid ][ "multisig" ] )],
                                vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                            });
                            var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                            if ( am_alice ) var my_address = alices_address;
                            else var my_address = bobs_address;
                            var tx2 = tapscript.Tx.create({
                                vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                                vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                            });
                            var tx2_script = prev_scripts[ 1 ];
                            var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                            var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                            var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                        }

                        //prepare and save the force closure initiation transaction
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx0_tree, target: tx0_target });
                        //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                        //the first sig must be sig_2 -- which means it must be in the "last"
                        //position (i.e. the sig created by Alice must appear right before her pubkey)
                        var tx0 = tx0s[ k ];
                        if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                        else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                        //prepare the force closure finalization transaction
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx1_tree, target: tx1_target });
                        var tx1 = tx1s[ k ];
                        if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                        else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                        //if necessary, prepare and save the conditional revocation transaction
                        if ( conditional_revocation_is_necessary ) {
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx1_tree, target: new_tx1_target });
                            if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                            else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                        }

                        //prepare the transaction that uses the htlc to prepare to create the new state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                        var first_from_htlc_tx = first_from_htlc_txs[ k ];
                        first_from_htlc_tx.vin[ 0 ].witness = [ bobs_first_htlc_sig, alices_first_htlc_sig, first_htlc_script, cblock ];

                        //actually give Alice her money if this is the latest state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                        var from_revo_tx_1 = from_revo_tx_1s[ k ];
                        from_revo_tx_1.vin[ 0 ].witness = [ bobs_revo_tx_1_sig, alices_revo_tx_1_sig, alices_first_revo_script, cblock ];

                        //let Bob sweep Alice's money if she tries to broadcast old state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                        var from_revo_tx_2 = from_revo_tx_2s[ k ];
                        from_revo_tx_2.vin[ 0 ].witness = [ bobs_revo_tx_2_sig, alices_revo_tx_2_sig, alices_second_revo_script, cblock ];

                        //prepare the transaction that uses the htlc to restore the current state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                        var second_from_htlc_tx = second_from_htlc_txs[ k ];
                        second_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];

                        //if necessary, prepare and save the full revocation transactions
                        if ( full_revocation_is_necessary ) {
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx2_tree, target: tx2_target });
                            tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                        }

                        var prev_force_close_tx = hedgehog.state[ chid ].latest_force_close_txs[ 0 ];

                        //save the transactions
                        hedgehog.state[ chid ].latest_force_close_txs = [
                            tapscript.Tx.encode( tx0 ).hex,
                            tapscript.Tx.encode( tx1 ).hex,
                        ];
                        if ( conditional_revocation_is_necessary ) {
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                            var new_first_from_htlc_tx = new_first_from_htlc_txs[ k ];
                            new_first_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_first_htlc_sig, alices_conditional_first_htlc_sig, first_htlc_script, cblock ];
                            //in case Bob force closes, prepare and save the conditional transaction that uses the htlc to actually create the new state
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                            var new_from_revo_tx_1 = new_from_revo_tx_1s[ k ];
                            new_from_revo_tx_1.vin[ 0 ].witness = [ bobs_conditional_revo_tx_1_sig, alices_conditional_revo_tx_1_sig, alices_first_revo_script, cblock ];
                            //let Bob conditionally sweep Alice's money if she tries to broadcast old state
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                            var new_from_revo_tx_2 = new_from_revo_tx_2s[ k ];
                            new_from_revo_tx_2.vin[ 0 ].witness = [ bobs_conditional_revo_tx_2_sig, alices_conditional_revo_tx_2_sig, alices_second_revo_script, cblock ];
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                            var new_second_from_htlc_tx = new_second_from_htlc_txs[ k ];
                            new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];
                            hedgehog.state[ chid ].txids_to_watch_for[ prev_txid ] = {
                                conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                                conditional_second_htlc_tx: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                            }
                        }
                        if ( full_revocation_is_necessary ) hedgehog.state[ chid ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                        //ensure the balances_before_most_recent_send are updated to the current state
                        //so that, after the htlc gets settled, Bob can add amnt to
                        //balances_before_most_recent_send and know that's the amount to expect in
                        //Alice's next state update
                        hedgehog.state[ chid ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chid ].balances ) );

                        //update state of who was last to send
                        hedgehog.state[ chid ].i_was_last_to_send = false;

                        hedgehog.state[ chid ].pending_htlc = {
                            from: "bob",
                            now: Math.floor( Date.now() / 1000 ),
                            amnt,
                            htlc_preimage: null,
                            htlc_hash,
                            force_close_tx: tapscript.Tx.encode( tx0 ).hex,
                            //TODO: change the value of when_to_force_close to something more reasonable
                            //than 10 blocks after the htlc is created
                            when_to_force_close: 10,
                            from_force_close_to_htlc: tapscript.Tx.encode( tx1 ).hex,
                            when_to_fund_htlc: 1996, //shorter than normal so that 4032 blocks is never exceeded
                            conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_first_from_htlc_tx ).hex,
                            conditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_from_revo_tx_1 ).hex,
                            conditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( new_from_revo_tx_2 ).hex,
                            conditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                            conditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_restore_from_revo_tx ).hex,
                            unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( first_from_htlc_tx ).hex,
                            unconditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( from_revo_tx_1 ).hex,
                            unconditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( from_revo_tx_2 ).hex,
                            unconditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( second_from_htlc_tx ).hex,
                            unconditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( restore_from_revo_tx ).hex,
                            when_to_restore_current_state: 2026, //longer than any lightning invoice locktime
                            txid_to_watch_for: prev_txid,
                            replacement_tx1_if_txid_to_watch_for_is_seen: tapscript.Tx.encode( new_tx1 ).hex,
                            //remember to decode the following tx, then make the preimage the item in
                            //the witness stack closest to the script, then reencode it, then broadcast it
                            channels_with_pending_outgoing_htlcs_linked_to_this_one: {},
                            time_when_preimage_was_received: null,
                            time_to_wait_after_preimage_is_received: 2016,
                        }
                    }

                    //test the following scenarios:

                    //alice force closes and restores the current state
                    console.log( `first test tx0 (alice) tx1 (alice) second_from_htlc_tx (alice)` );
                    //bob force closes and alice restores the current state
                    console.log( `next test prev_tx0 (bob) replacement_tx1 (alice) new_second_from_htlc_tx (alice)` );
                    //alice force closes and gives herself the money using a preimage obtained from bob
                    console.log( `next test tx0 (alice) tx1 (alice) first_from_htlc_tx (alice)` );
                    //bob force closes and alice gives herself the money using a preimage obtained from bob
                    console.log( `next test prev_tx0 (bob) replacement_tx1 (alice) new_first_from_htlc_tx (alice)` );

                    //TODO: also test other scenarios and consider eliminating txs that Alice doesn't need
                    //TODO: relatedly, I think Bob also has txs that he doesn't need -- and in both cases
                    //I think these unneeded txs allow them to put the money in states that they shouldn't
                    //be able to put them in, because they can steal them from those states in some scenarios
                    //e.g. Bob shouldn't be able to put Alice's money in a state she has revoked unless *she*
                    //broadcasts it after revoking it -- when *Bob* force closes he should not be able to do
                    //that

                    //TODO: set up a listener to get the preimage from somewhere
                    //or restore the old state after too much time goes by without resolution
                    //Note that if Bob sends payment_complete he includes the preimage, and I
                    //do have a listener set up to get it from that message, assuming he sends
                    //it -- but I need to be prepared to get the preimage from the sender if
                    //Bob decides to try to scam me by not sending it

                    //i am alice

                    if ( invoice ) return invoice;
                    return true;
                },
                closeChannel: chan_id => {
                    console.log( "Broadcast this transaction to initiate a force closure:" );
                    console.log( hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ] );
                    //TODO: change the 5 to a 2016
                    console.log( "Wait 5 blocks and broadcast this transaction to finalize the force closure:" );
                    console.log( hedgehog.state[ chan_id ].latest_force_close_txs[ 1 ] );
                    return [ hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ], hedgehog.state[ chan_id ].latest_force_close_txs[ 1 ] ];
                },
                checkIfIncomingHTLCIsSettled: async data => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //check if this channel has a pending htlc
                    var pending_htlc = hedgehog.state[ chan_id ].pending_htlc;
                    if ( !Object.keys( pending_htlc ).length ) return;

                    if ( am_alice && pending_htlc.from === "alice" ) return;
                    if ( !am_alice && pending_htlc.from !== "alice" ) return;

                    if ( !hedgehog.state[ chan_id ].pending_htlc.htlc_preimage ) {
                        var data_for_counterparty = {
                            msg: "unsettled",
                            htlc_hash: hedgehog.state[ chan_id ].pending_htlc.htlc_hash,
                        }
                        console.log( JSON.stringify( data_for_counterparty ) );
                        return alert( 'send the data in your console to your counterparty' );
                    }
                    var data_for_counterparty = {
                        status: "settled",
                        htlc_preimage: hedgehog.state[ chan_id ].pending_htlc.htlc_preimage,
                    }
                    console.log( JSON.stringify( data_for_counterparty ) );
                    alert( 'send the data in your console to your counterparty and then click ok' );
                    await hedgehog.waitSomeSeconds( 1 );
                    var data = JSON.parse( prompt( `enter your counterparty's reply here` ) );
                    var amnt_expected = hedgehog.state[ chan_id ].balances[ 1 ] + hedgehog.state[ chan_id ].pending_htlc.amnt;
                    if ( data[ "amnt" ] !== amnt_expected ) return alert( `something strange happened, your counterparty tried to send ${data[ "amnt" ]} and you expected ${amnt_expected} -- force close and settle with the preimage` );
                    var skip_pending_check = true;
                    hedgehog.receive( data, skip_pending_check );
                    hedgehog.state[ chan_id ].pending_htlc = {}
                },
                checkIfOutgoingHTLCIsSettled: async ( chan_id, preimage ) => {
                    if ( !chan_id ) chan_id = prompt( `enter chan_id` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    if ( !preimage ) {
                        console.log( JSON.stringify( {
                            chan_id,
                        } ) );
                        alert( 'send the data in your console to your counterparty and then click ok -- btw they should run hedgehog.checkIfIncomingHTLCIsSettled()' );
                        await hedgehog.waitSomeSeconds( 1 );
                        var data = JSON.parse( prompt( `enter bob's reply here` ) );
                        if ( data[ "status" ] === "unsettled" ) return alert( 'not settled yet' );
                        preimage = data[ "htlc_preimage" ];
                    }
                    var pending_htlc = hedgehog.state[ chan_id ].pending_htlc;
                    var expected_hash = pending_htlc.htlc_hash;
                    //ensure hashing the preimage won't crash the pc
                    var is_hex = hedgehog.isValidHex( preimage );
                    var is_right_size = preimage.length === 64;
                    if ( is_hex && is_right_size ) {
                        var actual_hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                        //TODO: uncomment the line below
                        // if ( expected_hash !== actual_hash ) return;
                    }
                    if ( am_alice ) var amnt_to_send = hedgehog.state[ chan_id ].balances_before_most_recent_send[ 1 ] + pending_htlc[ "amnt" ];
                    else var amnt_to_send = pending_htlc[ "amnt" ];
                    var skip_pending_check = true;
                    console.log( 75.5, hedgehog.state[ chan_id ].balances_before_most_recent_send );
                    console.log( 75.6, pending_htlc[ "amnt" ] );
                    console.log( 76, hedgehog.state[ chan_id ].balances );
                    console.log( amnt_to_send );
                    var sigs_and_stuff = hedgehog.send( chan_id, amnt_to_send, null, skip_pending_check );
                    console.log( 77, hedgehog.state[ chan_id ].balances );
                    // console.log( "send this data to your counterparty:" );
                    // console.log( JSON.stringify( sigs_and_stuff ) );
                    hedgehog.state[ chan_id ].pending_htlc = {}
                    return sigs_and_stuff;
                },
                settleIncomingHTLC: async data => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];
                    var preimage = data[ "preimage" ];

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //check if this channel has a pending htlc
                    var pending_htlc = hedgehog.state[ chan_id ].pending_htlc;
                    if ( !Object.keys( pending_htlc ).length ) return;

                    if ( am_alice && pending_htlc.from === "alice" ) return;
                    if ( !am_alice && pending_htlc.from !== "alice" ) return;

                    var expected_hash = pending_htlc.htlc_hash;
                    //ensure hashing the preimage won't crash the pc
                    var is_hex = hedgehog.isValidHex( preimage );
                    var is_right_size = preimage.length === 64;
                    if ( is_hex && is_right_size ) {
                        var actual_hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                        console.log( 1.5, expected_hash, actual_hash );
                        if ( expected_hash !== actual_hash ) return alert( `error regarding the hashes: expected_hash ${expected_hash} but got ${actual_hash} instead -- the preimage was ${preimage}` );
                    } else {
                        console.log( 'force close this channel and restore the previous state, and if it is linked to any related payments, force close those too and restore *their* previous state' );
                        console.log( 'broadcast this force close tx:' );
                        console.log( hedgehog.state[ chan_id ].pending_htlc.force_close_tx );
                        console.log( 'then wait 1996 blocks and broadcast this tx that funds the htlc:' );
                        console.log( hedgehog.state[ chan_id ].pending_htlc.from_force_close_to_htlc );
                        console.log( 'then wait 2016 blocks and broadcast this to restore the prior state:' );
                        console.log( hedgehog.state[ chan_id ].pending_htlc.restore_current_state_after_force_close );
                    }

                    //mark htlc ready for resolution

                    hedgehog.state[ chan_id ].pending_htlc[ "htlc_preimage" ] = preimage;
                    hedgehog.state[ chan_id ].pending_htlc[ "time_when_preimage_was_received" ] = Math.floor( Date.now() / 1000 );

                    //add the preimage to the transactions that need it

                    var first_tx_to_fix = hedgehog.state[ chan_id ].pending_htlc.unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state;
                    var decoded_1 = tapscript.Tx.decode( first_tx_to_fix );
                    decoded_1.vin[ 0 ].witness = [ decoded_1.vin[ 0 ].witness[ 0 ], decoded_1.vin[ 0 ].witness[ 1 ], preimage, decoded_1.vin[ 0 ].witness[ 2 ], decoded_1.vin[ 0 ].witness[ 3 ] ];
                    var encoded_1 = tapscript.Tx.encode( decoded_1 ).hex;

                    var second_tx_to_fix = hedgehog.state[ chan_id ].pending_htlc.conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state;
                    var decoded_2 = tapscript.Tx.decode( second_tx_to_fix );
                    decoded_2.vin[ 0 ].witness = [ decoded_2.vin[ 0 ].witness[ 0 ], decoded_2.vin[ 0 ].witness[ 1 ], preimage, decoded_2.vin[ 0 ].witness[ 2 ], decoded_2.vin[ 0 ].witness[ 3 ] ];
                    var encoded_2 = tapscript.Tx.encode( decoded_2 ).hex;

                    //save those transactions
                    hedgehog.state[ chan_id ].pending_htlc.unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state = encoded_1;
                    hedgehog.state[ chan_id ].pending_htlc.conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state = encoded_2;

                    //TODO: set up a listener so that if 2016 blocks go by we force close
                    return `that went well, now your counterparty should run hedgehog.checkIfOutgoingHTLCIsSettled("${chan_id}")`;
                },
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 800px;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
                padding: 0;
            }
            body {
                margin: 3rem 1rem;
                word-wrap: break-word;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .hidden {
                display: none !important;
            }
            .minutes_selector {
                display: flex;
            }
            .minutes_selector span {
                margin-left: .5rem;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
            var hash_arr = window.location.href.substring( window.location.href.indexOf( "#" ) ).split( "#" );
            hash_arr.splice( 0, 1 );
            var params = {}
            hash_arr.forEach( item => {
                var vals = item.split( "=" );
                params[ vals[ 0 ] ] = vals[ 1 ];
            });
        </script>
    </head>
    <body>
        <h1>Hedgehog factory</h1>
        <div class="schedule_signing_ceremony">
            <p>Pick how long you're willing to wait for people to show up to your signing ceremony</p>
            <p class="minutes_selector"><input type="number" class="minutes_to_wait" value="1" step="1"><span>minutes</span></p>
            <p>Enter an nwc string so you can create invoices for your users</p>
            <p><input class="nwc_string_entry_form"></p>
            <p><button class="prep_ceremony">Submit</button></p>
        </div>
        <div class="ceremony_page hidden">
            <p>The signing ceremony will start before this timer runs out:</p>
            <p class="time_til_signing_ceremony"></p>
            <p>How many people are here (other than the admin): <span class="participant_count">loading...</span></p>
            <p>Minimum number of participants required: <span class="minimum_required"></span></p>
            <div class="user_only">
                <p>Instructions:</p>
                <p>When the admin starts the signing ceremony you will see a lightning invoice to purchase a hedgehog channel with <span class="channel_size"></span> sats of inbound capacity for <span class="channel_cost"></span> sats. Get your wallet ready! You will only have 1 minute to pay.</p>
            </div>
            <div class="admin_only hidden">
                <p>Instructions:</p>
                <p>Share this link with anyone you want to open channels for:</p>
                <p class="shareable_link"></p>
                <p><button class="start_signing_ceremony">Start signing ceremony</button></p>
            </div>
        </div>
        <div class="wallet_page hidden">
            <div>Balance</div>
            <div><span class="balance">loading...</span></div>
            <div class="wallet_btns"><button class="send_btn">Send</button><button class="receive_btn">Receive</button></div>
        </div>
        <div class="ejection_buttons admin_only hidden"></div>
        <script>
            var hedgehog_factory = {
                state: {},
                retrievables: {},
                waitSomeTime: num => new Promise( resolve => setTimeout( resolve, num ) ),
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                bytesToHex: bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" ),
                convertHMS: value => {
                    if ( value < 0 ) value = 0;
                    var sec = parseInt(value, 10); // convert value to number if it's string
                    var years = Math.floor(sec / 31536000); // get years
                    var months = Math.floor((sec - (years * 31536000)) / 2592000); // get months
                    var days = Math.floor((sec - (years * 31536000) - (months * 2592000)) / 86400); // get days
                    var hours = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400)) / 3600); // get hours
                    var minutes = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600)) / 60); // get minutes
                    var seconds = sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600) - (minutes * 60); //  get seconds
                    var yearsstring = (years != 1) ? `years`:`year`;
                    var monthsstring = (months != 1) ?  `months`:`month`;
                    var daysstring = (days != 1) ? `days`:`day`;
                    var hoursstring = (hours != 1) ? `hours`:`hour`;
                    var minutesstring = (minutes != 1) ? `minutes`:`minute`;
                    var secondsstring = (seconds != 1) ? `seconds`:`second`;
                    return `${days} ${daysstring} ${minutes} ${minutesstring} ${seconds} seconds`;
                },
                hexToText: hex => {
                    var bytes = new Uint8Array( Math.ceil( hex.length / 2 ) );
                    var i; for ( i=0; i<hex.length; i++ ) bytes[ i ] = parseInt( hex.substr( i * 2, 2 ), 16 );
                    var text = new TextDecoder().decode( bytes );
                    return text;
                },
                textToHex: text => {
                    var encoded = new TextEncoder().encode( text );
                    return Array.from( encoded )
                        .map( x => x.toString( 16 ).padStart( 2, "0" ) )
                        .join( "" );
                },
                shuffle: array => {
                    var secureRandom = () => Number( `0.${parseInt( hedgehog_factory.bytesToHex( window.crypto.getRandomValues( new Uint8Array( 7 ) ) ), 16 )}` );
                    array = JSON.parse( JSON.stringify( array ) );
                    var currentIndex = array.length, randomIndex;
                    // While there remain elements to shuffle.
                    while ( currentIndex > 0 ) {
                        // Pick a remaining element.
                        randomIndex = Math.floor( secureRandom() * currentIndex );
                        currentIndex--;
                        // And swap it with the current element.
                        [ array[ currentIndex ], array[ randomIndex ] ] = [
                            array[ randomIndex ], array[ currentIndex ]
                        ];
                    }
                    return array;
                },
                isValidAddress: address => {
                    try {
                        return !!tapscript.Address.decode( address ).script;
                    } catch( e ) {return;}
                    return;
                },
                isValidBitcoinKey: key => {
                    if ( key.length != 64 && key.length != 66 ) return;
                    if ( key.length === 64 ) key = "02" + key;
                    try {
                        return !!nobleSecp256k1.Point.fromCompressedHex( hedgehog_factory.hexToBytes( key ) );
                    } catch ( e ) {
                        return;
                    }
                },
                getNote: async item => {
                    async function isNoteSetYet( note_i_seek ) {
                        return new Promise( function( resolve, reject ) {
                            if ( !note_i_seek ) {
                                setTimeout( async function() {
                                    var msg = await isNoteSetYet( hedgehog_factory.retrievables[ item ] );
                                    resolve( msg );
                                }, 100 );
                            } else {
                                resolve( note_i_seek );
                            }
                        });
                    }
                    async function getTimeoutData() {
                        var note_i_seek = await isNoteSetYet( hedgehog_factory.retrievables[ item ] );
                        return note_i_seek;
                    }
                    var returnable = await getTimeoutData();
                    return returnable;
                },
                init: state_id => {
                    hedgehog_factory.state[ state_id ] = {
                        whos_here: {},
                        who_should_pay: {},
                        all_peers: [],
                        ceremony_started: false,
                        channel_cost: 1000,
                        channel_size: 100_000,
                        minimum: 3,
                        maximum: 20,
                        address_type: "regtest",
                        relays: ["wss://nostrue.com"],
                        privkey: hedgehog_factory.bytesToHex( window.crypto.getRandomValues( new Uint8Array( 32 ) ) ),
                        pubkey: null,
                        scripts: [],
                        script: [],
                        tree: [],
                        multisig: null,
                        backup_pubkey: "a".repeat( 64 ),
                        funding_tx: null,
                        rounds: [],
                        ejection_txs: [],
                        round_sigs: [],
                        midstate_scripts: [],
                        midstate_trees: [],
                        midstate_addresses: [],
                        connector_utxos: [],
                        user_ejection_sigs: [],
                        connector_sigs: [],
                        withdrawal_txids: [],
                        all_sigs_needed_by_admin: {},
                        sorted_round_sigs: [],
                        sorted_user_ejection_sigs: [],
                        sorted_connector_sigs: [],
                        current_round: 0,
                        amount_per_user_to_cover_p2a_costs: 240 * 2,
                        average_bytesize_of_each_users_input: 200,
                        routing_node: null,
                        msg_id: state_id,
                        node: null,
                        initial_state_hash: null,
                        admin_pubkeys_for_hedgehog_channels: {},
                        admin_privkey_for_own_hedgehog_channel: null,
                        admin_preimage_for_own_hedgehog_channel: null,
                        opening_info_for_hedgehog_channels: {},
                        signing_started: false,
                        nwc_string: null,
                        loop_delay: 20,
                        amount_alice_expects_in_next_htlc: 0,
                    }
                    var state = hedgehog_factory.state[ state_id ];
                    if ( params[ "privkey" ] ) state.privkey = params[ "privkey" ];
                    state.pubkey = nobleSecp256k1.getPublicKey( state.privkey, true ).substring( 2 );
                    state.routing_node = params.hasOwnProperty( "routing_node" ) ? params.routing_node : state.pubkey;
                    state.node = nostr_p2p( state.relays, state.privkey );
                    $( '.channel_cost' ).innerText = state.channel_cost;
                    $( '.channel_size' ).innerText = state.channel_size.toLocaleString();
                },
                whosHereCleaner: async state_id => {
                    var now = Math.floor( Date.now() / 1000 );
                    var state = hedgehog_factory.state[ state_id ];
                    var whos_here = state.whos_here;
                    if ( state.ceremony_started ) return;
                    Object.keys( whos_here ).forEach( participant => {
                        if ( now - whos_here[ participant ] > 30 ) delete whos_here[ participant ];
                    });
                    if ( Object.keys( whos_here ).length < 2 ) $( '.participant_count' ).innerText = `1 (just you)`;
                    else $( '.participant_count' ).innerText = Object.keys( whos_here ).length;
                    if ( params.hasOwnProperty( "admin" ) ) {
                        if ( !Object.keys( whos_here ).length ) $( '.participant_count' ).innerText = `0 (it's just you)`;
                        if ( Object.keys( whos_here ).length === 1 ) $( '.participant_count' ).innerText = 1;
                    }
                    await hedgehog_factory.waitSomeTime( 1000 );
                    hedgehog_factory.whosHereCleaner( state_id );
                },
                startSigning: async ( official_peers_and_utxos_list, state_id ) => {
                    var peers_and_utxos = JSON.parse( official_peers_and_utxos_list );
                    var peers = peers_and_utxos.value.randomized_peers;
                    var utxos = peers_and_utxos.value.utxos_for_protocol;
                    var sats_per_byte = peers_and_utxos.value.sats_per_byte;
                    var change_address = peers_and_utxos.value.change_address;
                    var state = hedgehog_factory.state[ state_id ];
                    var privkey = state.privkey;
                    var pubkey = state.pubkey;
                    var node = state.node;
                    var address_type = state.address_type;
                    var routing_node = state.routing_node;
                    var funding_amount = state.channel_size;
                    var channel_size = state.channel_size;
                    var amount_per_user_to_cover_p2a_costs = state.amount_per_user_to_cover_p2a_costs;
                    var backup_pubkey = state.backup_pubkey;
                    var msg_id = state_id;

                    //if you are the admin, clear your hedgehog.keypairs object and insert the keypairs
                    //belonging to the people who paid and have not been kicked out
                    if ( params.hasOwnProperty( "admin" ) ) {
                        var who_should_pay = state.who_should_pay;
                        hedgehog.keypairs = {}
                        peers.forEach( peer => {
                            if ( peer === pubkey ) {
                                var preimage_for_hedgehog = state.admin_preimage_for_own_hedgehog_channel;
                                var privkey_for_hedgehog = state.admin_privkey_for_own_hedgehog_channel;
                            }
                            var preimage_for_hedgehog = who_should_pay[ peer ][ 2 ];
                            var privkey_for_hedgehog = who_should_pay[ peer ][ 3 ];
                            var pubkey_for_hedgehog = nobleSecp256k1.getPublicKey( privkey_for_hedgehog, true ).substring( 2 );
                            hedgehog.keypairs[ pubkey_for_hedgehog ] = {
                                privkey: privkey_for_hedgehog,
                                preimage: preimage_for_hedgehog,
                            }
                        });
                    }

                    // Have every party insert the admins pubkey at the top of the pubkeys list
                    peers.unshift( routing_node );
                    state.all_peers = JSON.parse( JSON.stringify( peers ) );
                    var all_peers = state.all_peers;

                    // Have every party independently validate that the list has no repeats
                    var duplicates = peers.filter( ( item, index ) => peers.indexOf( item ) !== index );
                    if ( duplicates.length ) return alert( `aborting because the admin scammed you by including some people twice in the multisig. Your money is probably gone forever.` );
                    // Have every party independently validate that their pubkey is in the list
                    if ( !peers.includes( pubkey ) ) return alert( `aborting because the admin scammed you by not including you in the multisig. Your money is probably gone forever.` );

                    // Have every party independently validate that all pubkeys in the list are valid
                    var all_keys_are_valid = true;
                    peers.forEach( key => {
                        if ( !hedgehog_factory.isValidBitcoinKey( key ) ) all_keys_are_valid = false;
                    });
                    if ( !all_keys_are_valid ) return alert( `aborting because the admin scammed you by sending you a list of peers with invalid keys. Your money is probably gone forever.`);

                    // TODO: Have every party independently validate that those utxos exist
                    // Have every party independently validate that those utxos are in segwit addresses (v0 or v1)
                    var all_addys_are_segwit = true;
                    var addys_in_utxo_list = [];
                    utxos.forEach( utxo => addys_in_utxo_list.push( utxo[ "addy" ] ) );
                    addys_in_utxo_list.forEach( addy => {
                        if ( !addy.startsWith( "bc1" ) && !addy.startsWith( "tb1" ) && !addy.startsWith( "bcrt1" ) ) all_addys_are_segwit = false;
                    });
                    if ( !all_addys_are_segwit ) return alert( `aborting because the admin scammed you by not using segwit addresses to fund the multisig, which means anyone can render all signatures invalid while the funding transaction is still in the mempool. Your money is probably gone forever.` );

                    // Have every party independently validate that the utxos contain enough money to fund the multisig
                    var required_sum = ( channel_size * peers.length ) + ( amount_per_user_to_cover_p2a_costs * peers.length ) + 830;
                    var actual_sum = 0;
                    utxos.forEach( utxo => actual_sum = actual_sum + utxo[ "amnt" ] );
                    if ( actual_sum < required_sum ) return alert( `aborting because the admin scammed you by not providing enough money to fund the multisig, which means the funding transaction won't be valid. Your money is probably gone forever.` );

                    // Have every party independently validate that the feerate chosen is sufficient
                    // TODO: actually check a feerate source and ensure the feerate chosen is at or above the fast-track option
                    if ( sats_per_byte < 1 ) return alert( `aborting because the admin scammed you by telling you to use an insufficient feerate, which means the funding transaction will probably never get mined. Your money is probably gone forever.` );

                    // Have every party independently validate that the change address is valid
                    if ( !hedgehog_factory.isValidAddress( change_address ) ) return alert( `aborting because the admin scammed you by telling you to send their change to an invalid bitcoin address, which means the funding transaction won't be valid. Your money is probably gone forever.` );

                    // Have every party independently create an n of n multisig owned by the pubkeys mentioned in the first bullet point of this section
                    var scripts = state.scripts;
                    var script = state.script;
                    var tree = state.tree;
                    peers.forEach( ( key, index ) => script.push( key, "OP_CHECKSIGVERIFY" ) );
                    script.pop();
                    script.push( "OP_CHECKSIG" );
                    scripts.push( script );
                    tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    state.tree = tree;
                    var tapleaf = tree[ 0 ];
                    var [ tpubkey ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tapleaf, tree });
                    var multisig = tapscript.Address.p2tr.fromPubKey( tpubkey, address_type );
                    state.multisig = multisig;

                    // Have every party independently create the 1-or-2 output transaction depositing the right amount of money into the multisig and giving the change, if any, back to the admin
                    var vin = [];
                    utxos.forEach( utxo => {
                        vin.push({
                            txid: utxo[ "txid" ],
                            vout: utxo[ "vout" ],
                            prevout: {
                                value: utxo[ "amnt" ],
                                scriptPubKey: tapscript.Address.toScriptPubKey( utxo[ "addy" ] ),
                            }
                        });
                    });
                    var change_amnt = actual_sum - ( required_sum - 830 );
                    var vout = [{
                        value: required_sum - 830,
                        scriptPubKey: tapscript.Address.toScriptPubKey( multisig ),
                    }];
                    // TODO: ensure you apply the tx fee per the feerate value
                    if ( change_amnt >= 830 ) vout.push({
                        value: change_amnt - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( change_address ),
                    });
                    var funding_tx = tapscript.Tx.create({
                        vin,
                        vout,
                    });
                    state.funding_tx = funding_tx;
                    var num_of_users = peers.length;

                    // Have every party prepare the midstate scripts
                    var midstate_scripts = state.midstate_scripts;
                    var i; for ( i=0; i<num_of_users; i++ ) {
                        var scripts_for_this_midstate = [];
                        var j; for ( j=0; j<num_of_users; j++ ) {
                            var midstate_script = JSON.parse( JSON.stringify( script ) );
                            scripts_for_this_midstate.push( midstate_script );
                        }
                        midstate_scripts.push( scripts_for_this_midstate );
                    }

                    // Have every party prepare the midstate addresses
                    var midstate_trees = state.midstate_trees;
                    var midstate_addresses = state.midstate_addresses;
                    midstate_scripts.forEach( scripts => {
                        var midstate_tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        midstate_trees.push( midstate_tree );
                        var [ tpubkey ] = tapscript.Tap.getPubKey( backup_pubkey, { tree: midstate_tree });
                        var midstate_address = tapscript.Address.p2tr.fromPubKey( tpubkey, address_type );
                        midstate_addresses.push( midstate_address );
                    });

                    // Have every party independently create a 10 step exit ladder using my tornado factory protocol so that the money for each participant is guaranteed to end up in a 2 of 2 multisig owned by that participants pubkey and the admin's
                    var every_partys_2_of_2 = [];
                    peers.forEach( key => {
                        var admins_pubkey_for_hedgehog_channel = state.admin_pubkeys_for_hedgehog_channels[ key ];
                        var two_of_two_script = [ admins_pubkey_for_hedgehog_channel, "OP_CHECKSIGVERIFY", key, "OP_CHECKSIG" ];
                        var two_of_two_tree = [ tapscript.Tap.encodeScript( two_of_two_script ) ];
                        var two_of_two_addy = hedgehog.makeAddress( [ two_of_two_script ] );
                        every_partys_2_of_2.push( two_of_two_addy );
                    });
                    // Generate n presigned txs, to which each user gets a copy
                    var rounds = state.rounds;
                    var round_sigs = state.round_sigs;
                    var i; for ( i=0; i<num_of_users; i++ ) {
                        //i represents the round
                        var txid = rounds.length ? tapscript.Tx.util.getTxid( rounds[ rounds.length - 1 ] ) : tapscript.Tx.util.getTxid( funding_tx );
                        var round = tapscript.Tx.create({
                            version: 3,
                            vin: [{
                                txid,
                                vout: rounds.length ? 2 : 0,
                                prevout: rounds.length ? rounds[ rounds.length - 1 ].vout[ 2 ] : funding_tx.vout[ 0 ],
                            }],
                            vout: [{
                                value: 240,
                                scriptPubKey: "51024e73",
                            },{
                                value: funding_amount + amount_per_user_to_cover_p2a_costs - 330 - 240,
                                scriptPubKey: tapscript.Address.toScriptPubKey( midstate_addresses[ i ] ),
                            }],
                        });
                        if ( i !== num_of_users - 1 ) {
                            round.vout.push({
                                value: ( funding_amount * num_of_users ) + ( amount_per_user_to_cover_p2a_costs * num_of_users ) - ( funding_amount * ( i + 1 ) ) - ( amount_per_user_to_cover_p2a_costs * ( i + 1 ) ) - ( 330 * num_of_users ),
                                scriptPubKey: tapscript.Address.toScriptPubKey( multisig ),
                            });
                        }
                        if ( !i ) {
                            var j; for ( j=0; j<num_of_users; j++ ) {
                                round.vout.push({
                                    value: 330,
                                    scriptPubKey: tapscript.Address.toScriptPubKey( multisig ),
                                });
                            }
                        }
                        var connector_utxos = state.connector_utxos;
                        if ( !i ) {
                            console.log( round );
                            var j; for ( j=0; j<num_of_users; j++ ) {
                                connector_utxos.push({
                                    txid: tapscript.Tx.util.getTxid( round ),
                                    vout: j + 3,
                                    prevout: round.vout[ j + 3 ],
                                });
                            }
                        }
                        var sigs = [];
                        var tapleaf = tree[ 0 ];
                        var sighash = tapscript.Signer.taproot.hash( round, 0, { extension: tapleaf }).hex;
                        var sig = tapscript.Signer.taproot.sign( privkey, round, 0, { extension: tapleaf }).hex;
                        sigs.push( sig );
                        rounds.push( round );
                        round_sigs.push( sigs );
                    }
                    // Have every party sign transactions allowing every other party to exit into that multisig
                    //allow each user to unilaterally exit in each round
                    //each user needs the ability to withdraw from the midstate in any round
                    //therefore, I must make n*n*n sigs -- there are n users who need to exit
                    //and n rounds to exit in, and each user, in order to exit in that round,
                    //needs n sigs
                    //each key needs to sign n*n ejection transactions
                    //the ejection transaction is different for each user
                    //in each round so let's make the other two loops
                    var totalnum = 0;
                    var user_ejection_sigs = state.user_ejection_sigs;
                    var connector_sigs = state.connector_sigs;
                    var ejection_txs = state.ejection_txs;
                    var withdrawal_txids = state.withdrawal_txids;
                    var i; for ( i=0; i<num_of_users; i++ ) {
                        if ( !i ) console.log( `0 out of ${( num_of_users ** 2 ) * 2} signatures created` );
                        //in the codeblock beginning above, i represents a round
                        var all_ejection_sigs_for_this_round = [];
                        var all_connector_sigs_for_this_round = [];
                        var all_withdrawal_txids_for_this_round = [];
                        var all_ejection_txs_for_this_round = [];
                        var j; for ( j=0; j<num_of_users; j++ ) {
                            //in the codeblock beginning above, j represents a user
                            var eject_user_tx = tapscript.Tx.create({
                                version: 3,
                                vin: [{
                                    txid: tapscript.Tx.util.getTxid( rounds[ i ] ),
                                    vout: 1,
                                    prevout: rounds[ i ].vout[ 1 ],
                                }],
                                vout: [{
                                    value: 240,
                                    scriptPubKey: "51024e73",
                                },{
                                    //note that the round made an output of funding_amount - 240
                                    //and this tx is spending that and taking out an *additional*
                                    //240 for output 0 -- so it's funding_amount - 240 - 240
                                    value: funding_amount + amount_per_user_to_cover_p2a_costs - 240 - 240,
                                    scriptPubKey: tapscript.Address.toScriptPubKey( every_partys_2_of_2[ j ] ),
                                }],
                            });
                            eject_user_tx.vin.push( connector_utxos[ j ] );
                            var txid_of_this_withdrawal_tx = tapscript.Tx.util.getTxid( eject_user_tx );
                            all_withdrawal_txids_for_this_round.push( txid_of_this_withdrawal_tx );
                            all_ejection_txs_for_this_round.push( eject_user_tx );
                            //I will use the tapleaf that lets one user alone leave after revealing his or her first withdrawal secret
                            //in round 1, the tapleaf I need for the first user is midstate_trees[ 0 ][ 0 ]
                            //in round 1, the tapleaf I need for the second user is midstate_trees[ 0 ][ 1 ]
                            //etc.
                            //in round 2, the tapleaf I need for the first user is midstate_trees[ 1 ][ 0 ]
                            //in round 2, the tapleaf I need for the second user is midstate_trees[ 1 ][ 1 ]
                            //etc.
                            var midstate_tapleaf = midstate_trees[ i ][ j ];
                            var connector_tapleaf = tree[ 0 ];
                            var backup_pubkey = state.backup_pubkey;
                            var [ _, cblock ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tapleaf, tree: midstate_trees[ i ] });
                            var sigs_for_this_user_for_this_round = [];
                            var connector_sigs_for_this_user_for_this_round = [];
                            var sig = tapscript.Signer.taproot.sign( privkey, eject_user_tx, 0, { extension: midstate_tapleaf } ).hex;
                            totalnum = totalnum + 1;
                            console.log( `${totalnum} out of ${( num_of_users ** 2 ) * 2} signatures created` );
                            sigs_for_this_user_for_this_round.push( sig );
                            var connector_sig = tapscript.Signer.taproot.sign( privkey, eject_user_tx, 1, { extension: connector_tapleaf } ).hex;
                            totalnum = totalnum + 1;
                            console.log( `${totalnum} out of ${( num_of_users ** 2 ) * 2} signatures created` );
                            connector_sigs_for_this_user_for_this_round.push( connector_sig );
                            all_ejection_sigs_for_this_round.push( sigs_for_this_user_for_this_round );
                            all_connector_sigs_for_this_round.push( connector_sigs_for_this_user_for_this_round );
                        }
                        if ( i === num_of_users - 1 ) console.log( 'done!' );
                        user_ejection_sigs.push( all_ejection_sigs_for_this_round );
                        connector_sigs.push( all_connector_sigs_for_this_round );
                        ejection_txs.push( all_ejection_txs_for_this_round );
                        withdrawal_txids.push( all_withdrawal_txids_for_this_round );
                    }
                    // Have every party (except the admin) give the admin their signatures and any data needed to unilaterally eject them from the multisig
                    var sigs_to_send = [];
                    round_sigs.forEach( sig_array => sigs_to_send.push( sig_array[ 0 ] ) );
                    var i; for ( i=0; i<user_ejection_sigs.length; i++ ) {
                        var j; for ( j=0; j<user_ejection_sigs[ i ].length; j++ ) {
                            sigs_to_send.push( user_ejection_sigs[ i ][ j ][ 0 ] );
                        }
                    }
                    var i; for ( i=0; i<connector_sigs.length; i++ ) {
                        var j; for ( j=0; j<connector_sigs[ i ].length; j++ ) {
                            sigs_to_send.push( connector_sigs[ i ][ j ][ 0 ] );
                        }
                    }
                    // Have every party give the admin signatures and hashes which, per my hedgehog protocol, allow the admin to create an initial state for the 2 of 2 multisig such that the admin can withdraw everything from it
                    var my_usernum = all_peers.indexOf( pubkey );
                    var counterpartys_pubkey = state.admin_pubkeys_for_hedgehog_channels[ all_peers[ my_usernum ] ];
                    var initial_state_hash = state.initial_state_hash;
                    var bobs_pubkey_and_hash = [ counterpartys_pubkey, initial_state_hash ];
                    var push_all_funds_to_counterparty = true;
                    var opening_info_for_hedgehog_channels = state.opening_info_for_hedgehog_channels;
                    if ( !opening_info_for_hedgehog_channels.hasOwnProperty( pubkey ) ) opening_info_for_hedgehog_channels[ pubkey ] = [];
                    var i; for ( i=0; i<all_peers.length; i++ ) {
                        var my_withdrawal_txids = state.withdrawal_txids[ my_usernum ];
                        var txid = my_withdrawal_txids[ i ];
                        var vout = 1;
                        var amnt = funding_amount + amount_per_user_to_cover_p2a_costs - 240 - 240;
                        var opening_info = await hedgehog.openChannel( push_all_funds_to_counterparty, bobs_pubkey_and_hash, null, null, null, null, null, privkey, [txid, vout, amnt] );
                        opening_info_for_hedgehog_channels[ pubkey ].push( opening_info );
                    }
                    // Send the data to the admin or, if you are the admin, save your own data
                    var all_sigs_needed_by_admin = state.all_sigs_needed_by_admin;
                    if ( peers[ 0 ] !== pubkey ) node.send( 'sigs', JSON.stringify({ sigs_to_send, opening_info_for_hedgehog_channels: opening_info_for_hedgehog_channels[ pubkey ] }), peers[ 0 ], msg_id );
                    else all_sigs_needed_by_admin[ pubkey ] = sigs_to_send;
                    // Then have the admin broadcast the funding transaction and the protocol is done
                },
                validateAndBroadcast: async state_id => {
                    var state = hedgehog_factory.state[ state_id ];
                    var all_peers = state.all_peers;
                    var sorted_round_sigs = state.sorted_round_sigs;
                    var sorted_user_ejection_sigs = state.sorted_user_ejection_sigs;
                    var sorted_connector_sigs = state.sorted_connector_sigs;
                    var ejection_txs = state.ejection_txs;
                    var midstate_trees = state.midstate_trees;
                    var tree = state.tree;
                    var privkey = state.privkey;
                    var funding_tx = state.funding_tx;
                    var rounds = state.rounds;
                    var num_of_round_sigs_in_each_set = all_peers.length;
                    var all_sigs_needed_by_admin = state.all_sigs_needed_by_admin;
                    var who_should_pay = state.who_should_pay;
                    var unsorted_sigs = JSON.parse( JSON.stringify( all_sigs_needed_by_admin ) );
                    var round_sigs = [];
                    var user_ejection_sigs = [];
                    var connector_sigs = [];
                    all_peers.forEach( peer => {
                        round_sigs.push( [ ...unsorted_sigs[ peer ].splice( 0, all_peers.length ) ] );
                        user_ejection_sigs.push( [ ...unsorted_sigs[ peer ].splice( 0, all_peers.length ** 2 ) ] );
                        connector_sigs.push( [ ...unsorted_sigs[ peer ].splice( 0, all_peers.length ** 2 ) ] );
                    });
                    // console.log( 0 );
                    // console.log( round_sigs );
                    // console.log( user_ejection_sigs );
                    // console.log( connector_sigs );
                    var i; for ( i=0; i<round_sigs.length; i++ ) {
                        var sorted = [];
                        var j; for ( j=0; j<round_sigs.length; j++ ) sorted.push( round_sigs[ j ][ i ] );
                        sorted_round_sigs.push( sorted );
                    }
                    var naughty_peers = [];
                    var i; for ( i=0; i<sorted_round_sigs.length; i++ ) {
                        //i represents the round
                        var sig_array = sorted_round_sigs[ i ];
                        var round = rounds[ i ];
                        var target = tree[ 0 ];
                        var sighash = tapscript.Signer.taproot.hash( round, 0, { extension: target }).hex;
                        var j; for ( j=0; j<sig_array.length; j++ ) {
                            //j represents the user whose sig we are checking
                            //and we skip checking our own
                            if ( !j ) continue;
                            var sig = sig_array[ j ];
                            var is_valid = await nobleSecp256k1.schnorr.verify( sig, sighash, all_peers[ j ] );
                            if ( !is_valid && !naughty_peers.includes( all_peers[ j ] ) ) naughty_peers.push( all_peers[ j ] );
                        }
                    }
                    console.log( 0, `naughty_peers:`, naughty_peers.length );
                    //the following loop makes it so that the first n sig_arrays in the
                    //sorted_user_ejection_sigs array and in the sorted_connector_sigs array
                    //eject all users from the first round, in the order given by all_peers
                    //(so the first array ejects user 1, the second array ejects user 2, etc.)
                    //the second n sig_arrays eject all users from the second round, etc.
                    //this should make it easy to make buttons to eject any user from any round
                    //if we are in the first round, I can have buttons to eject user 1, user 2,
                    //etc. and each one just grabs the next sig_array and makes a tx using them
                    //when the first round is done I can discard the first n sig_arrays and keep
                    //the rest of the code the same, and keep repeating that for all rounds
                    var i; for ( i=0; i<all_peers.length ** 2; i++ ) {
                        var sorted_1 = [];
                        var sorted_2 = [];
                        var j; for ( j=0; j<user_ejection_sigs.length; j++ ) {
                            sorted_1.push( user_ejection_sigs[ j ][ i ] );
                            sorted_2.push( connector_sigs[ j ][ i ] );
                        }
                        sorted_user_ejection_sigs.push( sorted_1 );
                        sorted_connector_sigs.push( sorted_2 );
                    }
                    //now I take the sorted_user_ejection_sigs and sorted_connector_sigs and group
                    //their sig_arrays by round
                    var grouped_1 = [];
                    var grouped_2 = [];
                    var i; for ( i=0; i<all_peers.length; i++ ) {
                        var round_group_1 = [ ...sorted_user_ejection_sigs.splice( 0, all_peers.length ) ];
                        var round_group_2 = [ ...sorted_connector_sigs.splice( 0, all_peers.length ) ];
                        grouped_1.push( round_group_1 );
                        grouped_2.push( round_group_2 );
                    }
                    sorted_user_ejection_sigs = grouped_1;
                    state.sorted_user_ejection_sigs = sorted_user_ejection_sigs;
                    sorted_connector_sigs = grouped_2;
                    state.sorted_connector_sigs = sorted_connector_sigs;
                    var i; for ( i=0; i<ejection_txs.length; i++ ) {
                        //i represents a round
                        var sig_array_1 = sorted_user_ejection_sigs[ i ];
                        var sig_array_2 = sorted_connector_sigs[ i ];
                        var j; for ( j=0; j<all_peers.length; j++ ) {
                            //j represents the user being ejected
                            var ejection_tx = ejection_txs[ i ][ j ];
                            var ejection_sigs_for_this_user = sig_array_1[ j ];
                            var connector_sigs_for_this_user = sig_array_2[ j ];
                            var midstate_tapleaf = midstate_trees[ i ][ j ];
                            var connector_tapleaf = tree[ 0 ];
                            var midstate_sighash = tapscript.Signer.taproot.hash( ejection_tx, 0, { extension: midstate_tapleaf });
                            var connector_sighash = tapscript.Signer.taproot.hash( ejection_tx, 1, { extension: connector_tapleaf });
                            var k; for ( k=0; k<ejection_sigs_for_this_user.length; k++ ) {
                                //k represents the user whose sig we are checking
                                //and we skip checking our own
                                if ( !k ) continue;
                                var sig_1 = ejection_sigs_for_this_user[ k ];
                                var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, midstate_sighash, all_peers[ k ] );
                                if ( !is_valid_1 && !naughty_peers.includes( all_peers[ k ] ) ) naughty_peers.push( all_peers[ k ] );
                                var sig_2 = connector_sigs_for_this_user[ k ];
                                var is_valid_2 = await nobleSecp256k1.schnorr.verify( sig_2, connector_sighash, all_peers[ k ] );
                                if ( !is_valid_2 && !naughty_peers.includes( all_peers[ k ] ) ) naughty_peers.push( all_peers[ k ] );
                            }
                        }
                    }
                    console.log( 1, `naughty_peers:`, naughty_peers.length );
                    // console.log( 1 );
                    // console.log( sorted_round_sigs );
                    // console.log( sorted_user_ejection_sigs );
                    // console.log( sorted_connector_sigs );
                    // ensure each channel opening transaction is valid
                    var i; for ( i=0; i<all_peers.length; i++ ) {
                        //i represents the peer
                        //you do not need to validate your own txs
                        if ( !i ) continue;
                        var peer = all_peers[ i ];
                        var pubkey_i_am_using_in_this_channel = nobleSecp256k1.getPublicKey( who_should_pay[ peer ][ 3 ], true ).substring( 2 );
                        console.log( `validating channels of ${peer}` )
                        var j; for ( j=0; j<all_peers.length; j++ ) {
                            //j represents the channel being validated,
                            //keeping in mind that each party created n
                            //potential channels depending on which
                            //withdrawal tx he ends up getting, and we
                            //must validate each one
                            var channel_info = state.opening_info_for_hedgehog_channels[ peer ][ j ];
                            //do not let users overwrite a channel you already validated
                            if ( hedgehog.state.hasOwnProperty( channel_info.chan_id ) ) {
                                naughty_peers.push( peer );
                                break;
                            }
                            //ensure each user signed correct info about their channel
                            var txid_for_this_channel = state.withdrawal_txids[ i ][ j ];
                            channel_info[ "recipient_pubkey" ] = pubkey_i_am_using_in_this_channel;
                            channel_info.utxo_info[ "txid" ] = txid_for_this_channel;
                            channel_info.utxo_info[ "vout" ] = 1;
                            channel_info.utxo_info[ "amnt" ] = state.channel_size;
                            channel_info.sender_pubkey = peer;
                            var channel_is_valid = await hedgehog.openChannel( null, null, null, null, null, null, channel_info );
                            if ( !channel_is_valid && !naughty_peers.includes( peer ) ) naughty_peers.push( peer );
                        }
                    }
                    //TODO: eject any naughty peers and restart from startSigning (note that it is important you restart from there because that function resets hedgehog.keypairs, ensuring no one can trick you into cosigning a channel state for a keypair that is not in the approved group, and thus stealing from you)
                    console.log( 2, `naughty_peers:`, naughty_peers.length );
                    var i; for ( i=0; i<all_peers.length; i++ ) $( '.ejection_buttons' ).innerHTML = $( '.ejection_buttons' ).innerHTML + `<button onclick="hedgehog_factory.ejectUser( ${i}, '${state_id}' );" class="eject_user_btn">Eject user ${i + 1}</button>`;
                    showPage( 'ejection_buttons' );
                    var sig_for_funding_tx = tapscript.Signer.taproot.sign( privkey, funding_tx, 0 );
                    funding_tx.vin[ 0 ].witness = [ sig_for_funding_tx ];
                    var txhex = tapscript.Tx.encode( funding_tx ).hex;
                    console.log( 'broadcast this:' );
                    console.log( txhex );
                    // Tell everyone their channels are active
                    var msg_id = state.msg_id;
                    var node = state.node;
                    var peers_to_send_message_to = JSON.parse( JSON.stringify( all_peers ) );
                    peers_to_send_message_to.splice( 0, 1 );
                    //TODO: instead of relaying the same message to every peer, send a message
                    //to each one individually and include the signatures they need to unilaterally
                    //withdraw
                    node.relay( 'channels_active', "channels_active", peers_to_send_message_to, msg_id );
                },
                ejectUser: ( user, state_id ) => {
                    var state = hedgehog_factory.state[ state_id ];
                    var round = state.current_round;
                    var tree = state.tree;
                    var backup_pubkey = state.backup_pubkey;
                    var rounds = state.rounds;
                    var sorted_round_sigs = state.sorted_round_sigs;
                    var sorted_user_ejection_sigs = state.sorted_user_ejection_sigs;
                    console.log( 1, sorted_user_ejection_sigs );
                    var sorted_connector_sigs = state.sorted_connector_sigs;
                    var scripts = state.scripts;
                    var address_type = state.address_type;
                    var all_peers = state.all_peers;
                    var average_bytesize_of_each_users_input = state.average_bytesize_of_each_users_input;
                    var pubkey = state.pubkey;
                    var privkey = state.privkey;
                    var ejection_txs = state.ejection_txs;
                    var midstate_scripts = state.midstate_scripts;
                    var midstate_trees = state.midstate_trees;
                    var tapleaf = tree[ 0 ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tapleaf, tree });
                    rounds[ round ].vin[ 0 ].witness = [ ...sorted_round_sigs[ round ].reverse(), scripts[ 0 ], cblock ];
                    //to spend from the user's branch, get a utxo that you can pay the mining fee with
                    var admin_addy = tapscript.Address.fromScriptPubKey( [ 1, pubkey ], address_type );
                    var fee_for_round = 2 * all_peers.length * average_bytesize_of_each_users_input;
                    console.log( `please send ${fee_for_round} sats to this address:` );
                    console.log( admin_addy );
                    var txid2 = prompt( `You are about to eject the user you selected. Please send ${fee_for_round} sats to the address in your console so that your user can pay the mining fee for their exit transaction, then enter the txid of your deposit` );
                    var vout2 = Number( prompt( `and the vout` ) );
                    var amnt2 = Number( prompt( `and the amount` ) );

                    var round_fee_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [{
                            txid: tapscript.Tx.util.getTxid( rounds[ round ] ),
                            vout: 0,
                            prevout: rounds[ round ].vout[ 0 ],
                        },{
                            txid: txid2,
                            vout: vout2,
                            prevout: {
                                value: amnt2,
                                scriptPubKey: [ 1, pubkey ],
                            }
                        }],
                        vout: [{
                            value: ( all_peers.length * average_bytesize_of_each_users_input ) - 240,
                            scriptPubKey: [ 1, pubkey ],
                        }],
                    });

                    //sign for the input that pays the round fee
                    var sig = tapscript.Signer.taproot.sign( privkey, round_fee_tx, 1 ).hex;
                    round_fee_tx.vin[ 1 ].witness = [ sig ];

                    var eject_user_tx = ejection_txs[ round ][ user ];
                    var eject_user_sigs = sorted_user_ejection_sigs[ round ][ user ].reverse();
                    var my_connector_sigs = sorted_connector_sigs[ round ][ user ].reverse();
                    var tapleaf = midstate_trees[ round ][ user ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tapleaf, tree: midstate_trees[ round ] });
                    eject_user_tx.vin[ 0 ].witness = [ ...eject_user_sigs, midstate_scripts[ round ][ user ], cblock ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tree[ 0 ], tree: tree });
                    eject_user_tx.vin[ 1 ].witness = [ ...my_connector_sigs, scripts[ 0 ], cblock ];

                    var exit_fee_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [{
                            txid: tapscript.Tx.util.getTxid( eject_user_tx ),
                            vout: 0,
                            prevout: eject_user_tx.vout[ 0 ],
                        },{
                            txid: tapscript.Tx.util.getTxid( round_fee_tx ),
                            vout: 0,
                            prevout: round_fee_tx.vout[ 0 ],
                        }],
                        vout: [{
                            value: 0,
                            scriptPubKey: [ "OP_RETURN", "" ],
                        }],
                    });

                    //sign for the input that pays the exit fee
                    var sig = tapscript.Signer.taproot.sign( privkey, exit_fee_tx, 1 ).hex;
                    exit_fee_tx.vin[ 1 ].witness = [ sig ];

                    //show the admin the raw transaction hex for creating the midstate
                    var txhex = tapscript.Tx.encode( rounds[ round ] ).hex;
                    console.log( `broadcast this round_${round} tx that lets any user leave:` );
                    console.log( txhex );

                    //show the admin the raw transaction hex for paying the round fee
                    var txhex = tapscript.Tx.encode( round_fee_tx ).hex;
                    console.log( `broadcast this round_fee_tx tx that pays the fee for this round:` );
                    console.log( txhex );
                    console.log( `then wait for the round transaction and the round_fee_tx to confirm` );

                    //show the admin the raw transaction hex for ejecting whoever they picked to eject
                    var txhex = tapscript.Tx.encode( eject_user_tx ).hex;
                    console.log( `broadcast this eject_user_tx that ejects the user you selected:` );
                    console.log( txhex );

                    //show the admin the raw transaction hex for paying the exit fee
                    var txhex = tapscript.Tx.encode( exit_fee_tx ).hex;
                    console.log( `broadcast this exit_fee_tx tx that pays the fee for the eject_user_tx:` );
                    console.log( txhex );
                    state.current_round = round + 1;
                    $$( '.eject_user_btn' )[ user ].disabled = true;
                },
                runGetRevData: async ( msg, state_id ) => {
                    var json = JSON.parse( msg.dat );
                    //TODO: validate the info sent by Bob
                    //especially that the hash he ends up
                    //sending matches the invoice you're
                    //receiving with
                    var state_id_according_to_bob = json.msg.state_id;
                    if ( state_id_according_to_bob !== state_id ) return alert( `aborting because Bob prompted you to receive an htlc in a channel you do not have` );
                    var amnt = json.msg.amnt;
                    var state = hedgehog_factory.state[ state_id ];
                    var expected_amnt = state.amount_alice_expects_in_next_htlc;
                    if ( amnt !== expected_amnt ) return alert( `aborting because Bob tried to send you an amount other than the amount you asked for` );
                    state.amount_alice_expects_in_next_htlc = 0;
                    var invoice = json.msg.invoice;
                    var secret = json.msg.secret;
                    var invoice_to_receive_with = await hedgehog.aliceReceivesHTLC({amnt, secret, invoice, state_id});
                    console.log( "have someone pay this:" );
                    console.log( invoice_to_receive_with );
                },
                runInitiateLNReceive: async ( msg, state_id ) => {
                    console.log( 0 );
                    var json = JSON.parse( msg.dat );
                    //TODO: validate that the state_id exists
                    var state_id = json.msg.state_id;
                    var msg_id = state_id;
                    var state = hedgehog_factory.state[ state_id ];
                    var nwc_string = state.nwc_string;
                    var nwc_info = nwcjs.processNWCstring( nwc_string );
                    // var chan_id = json.msg.chan_id;
                    var amnt = Number( json.msg.amnt );
                    if ( !amnt || amnt < 0 ) return 'error';
                    //TODO: ensure you have outgoing capacity
                    //TODO: ensure the user who sent you this request is your counterparty in the channel with this chan_id
                    var delay_tolerance = 10;
                    var desc = "";
                    console.log( 1 );
                    var invoice_info = await nwcjs.makeInvoice( nwc_info, amnt, desc, delay_tolerance );
                    console.log( 2 );
                    if ( invoice_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_info )}` );
                    if ( "result_type" in invoice_info && invoice_info[ "result_type" ] !== "make_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_info )}` );
                    if ( "error" in invoice_info && invoice_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( invoice_info[ "error" ] )} -- please try again` );
                    var invoice = invoice_info.result.invoice || invoice_info.result.bolt11;
                    var htlc_hash = hedgehog.getInvoicePmthash( invoice );
                    console.log( 3, msg_id, amnt, htlc_hash, invoice, msg.ctx.pubkey );
                    hedgehog.bobSendsHtlc( msg_id, amnt, htlc_hash, invoice, msg.ctx.pubkey );
                },
            }
            var showPage = page => {
                $( '.schedule_signing_ceremony' ).classList.add( "hidden" );
                $( '.ceremony_page' ).classList.add( "hidden" );
                $( '.ejection_buttons' ).classList.add( "hidden" );
                $( '.wallet_page' ).classList.add( "hidden" );
                $( `.${page}` ).classList.remove( "hidden" );
            }
            if ( !params[ "ceremony" ] ) {
                $( '.minutes_to_wait' ).value = 1;
                $( '.nwc_string_entry_form' ).value = "";
                var privkey = hedgehog_factory.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var relays = ["wss://nostrue.com"];
                $( '.prep_ceremony' ).onclick = () => {
                    var nwc_string = $( '.nwc_string_entry_form' ).value;
                    try {
                        var nwc_obj = nwcjs.processNWCstring( nwc_string );
                    } catch ( e ) {
                        return alert( `Your NWC string was invalid, try again` );
                    }
                    var minutes_to_wait = Number( $( '.minutes_to_wait' ).value );
                    var timestamp = Math.floor( Date.now() / 1000 ) + ( minutes_to_wait * 60 );
                    var timestamp_as_hex = timestamp.toString( 16 ).padStart( 8, "0" );
                    var msg_id = timestamp_as_hex + hedgehog_factory.bytesToHex( window.crypto.getRandomValues( new Uint8Array( 16 - 4 ) ) );
                    var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `#ceremony=${msg_id}#privkey=${privkey}#admin=true#nwc_string=${hedgehog_factory.textToHex( nwc_string )}`;
                    window.location.href = url;
                    window.location.reload();
                }
            }
            if ( params[ "ceremony" ] ) {
                var state_id = params[ "ceremony" ];
                hedgehog_factory.init( state_id );
                var state = hedgehog_factory.state[ state_id ];
                $( '.minimum_required' ).innerText = state.minimum;
                showPage( `ceremony_page` );
                var loop = async future => {
                    var now = Math.floor( Date.now() / 1000 );
                    var time_til_then = future - now >= 0 ? future - now : 0;
                    $( '.time_til_signing_ceremony' ).innerText = hedgehog_factory.convertHMS( time_til_then );
                    await hedgehog_factory.waitSomeTime( 1000 );
                    loop( future );
                }
                var future = parseInt( params[ "ceremony" ].substring( 0, 8 ), 16 );
                loop( future );
                var listenFunction = async socket => {
                    var subId = super_nostr.bytesToHex( window.crypto.getRandomValues( new Uint8Array( 8 ) ) );
                    var filter  = {}
                    filter.kinds = [ 52175 ];
                    filter[ "#e" ] = [ params[ "ceremony" ].padStart( 64, "0" ) ];
                    filter.since = Math.floor( Date.now() / 1000 ) - 30;
                    var subscription = [ "REQ", subId, filter ];
                    socket.send( JSON.stringify( subscription ) );
                }
                var handleFunction = async message => {
                    var [ type, subId, event ] = JSON.parse( message.data );
                    if ( !event || event === true ) return;
                    if ( !state.ceremony_started && event.pubkey !== state.routing_node ) state.whos_here[ event.pubkey ] = Math.floor( Date.now() / 1000 );
                }
                (async()=>{
                    var state_id = params[ "ceremony" ];
                    var msg_id = state_id;
                    var state = hedgehog_factory.state[ state_id ];
                    var all_peers = state.all_peers;
                    var node = state.node;
                    await node.connect();
                    node.event.on( 'init', console.log( 'connected to the p2p network!' ) );
                    node.inbox.on( msg_id, msg => {
                        //ignore messages that have the wrong message id
                        if ( msg.id !== msg_id ) return;
                        //the admin ignores preparation messages that they themselves sent
                        if ( msg.tag === "preparation_phase" && params.hasOwnProperty( "admin" ) ) return;
                        //users ignore messages from people other than the admin
                        if ( !params.hasOwnProperty( "admin" ) && msg.ctx.pubkey !== params.routing_node ) return;
                        //if anyone receives the secret_you_need message, add it to retrievables
                        //but only if you are *are* the admin or you are *talking to* the admin
                        if ( msg.tag === "secret_you_need" && ( params.hasOwnProperty( "admin" ) || msg.ctx.pubkey === params.routing_node ) ) {
                            console.log( 'received a secret' );
                            var json = JSON.parse( msg.dat );
                            var secret = json.msg.secret;
                            console.log( 'received this secret:', secret );
                            hedgehog_factory.retrievables[ secret ] = json.msg.thing_needed;
                            setTimeout( () => {delete hedgehog_factory.retrievables[ secret ];}, 5000 );
                            return;
                        }
                        //if the admin sends the "signing_phase" message, pass it to the startSigning function
                        if ( msg.ctx.pubkey === params.routing_node && msg.tag === "signing_phase" && !state.signing_started ) {
                            hedgehog_factory.startSigning( msg.dat, state_id );
                            return;
                        }
                        //if the admin sends the "invoice_paid" message, mark your invoice as paid and prepare to use the hash to create a hedgehog channel
                        //TODO: he should also give you a blind sig here; unblind it and change your pubkey, then you can prove you were in this group using the unblinded sig instead of your pubkey -- preventing the admin from linking you to your payment
                        if ( msg.ctx.pubkey === params.routing_node && msg.tag === "preparation_phase" && JSON.parse( msg.dat )[ "type" ] === "invoice_paid" && !state.initial_state_hash ) {
                            state.initial_state_hash = JSON.parse( JSON.parse( msg.dat )[ "value" ] )[ "hash_for_hedgehog_channel" ];
                            state.admin_pubkeys_for_hedgehog_channels = JSON.parse( JSON.parse( msg.dat )[ "value" ] )[ "pubkeys_for_hedgehog_channels" ];
                            return;
                        }
                        //if the admin sends the "channels_active" message, show the user their wallet
                        if ( msg.ctx.pubkey === params.routing_node && msg.tag === "channels_active" ) {
                            //TODO: have the admin send you the sigs you need to unilaterally withdraw and validate them
                            showPage( 'wallet_page' );
                            var hedgehog_chan_ids = [];
                            state.opening_info_for_hedgehog_channels[ state.pubkey ].forEach( item => hedgehog_chan_ids.push( item.chan_id ) );
                            $( '.receive_btn' ).setAttribute( "data-hedgehog_chan_ids", JSON.stringify( hedgehog_chan_ids ) );
                            $( '.receive_btn' ).setAttribute( "data-state_id", state_id );
                            $( '.receive_btn' ).onclick = async e => {
                                var amnt = Number( prompt( `enter an amount you want to receive` ) );
                                if ( !amnt ) return;
                                // var chan_ids = JSON.parse( e.target.getAttribute( "data-hedgehog_chan_ids" ) );
                                var state_id = e.target.getAttribute( "data-state_id" );
                                var state = hedgehog_factory.state[ state_id ];
                                var all_peers = state.all_peers;
                                var recipient = all_peers[ 0 ];
                                var msg = JSON.stringify({
                                    type: "initiate_ln_receive",
                                    msg: {
                                        amnt,
                                        state_id,
                                        // chan_ids,
                                    }
                                });
                                state.amount_alice_expects_in_next_htlc = amnt;
                                node.send( 'initiate_ln_receive', msg, recipient, msg_id );
                            }
                            return;
                        }
                        //if the admin sends the "get_revocation_data" message, prepare to receive an htlc and tell the user to show their invoice to whoever is paying them
                        if ( msg.ctx.pubkey === params.routing_node && msg.tag === "get_revocation_data" ) {
                            hedgehog_factory.runGetRevData( msg, state_id );
                            return;
                        }
                        //if the admin sends the "payment_complete" message, settle the htlc
                        if ( msg.ctx.pubkey === params.routing_node && msg.tag === "payment_complete" ) {
                            var json = JSON.parse( msg.dat );
                            var chan_id = json.msg.chan_id;
                            var preimage = json.msg.preimage;
                            var sigs_and_stuff = json.msg.sigs_and_stuff;
                            // TODO: uncomment the two lines below
                            // var pmt_status = await hedgehog.settleIncomingHTLC({ chan_id, preimage });
                            // if ( !pmt_status.startsWith( "that went well" ) ) return alert( `something went wrong: ${pmt_status}` );
                            //TODO: consider more deeply whether I am right to assume it is safe to resolve an htlc
                            //that is from Bob; my reasoning is that his htlcs always pay me more money, so resolving
                            //them is fine; I don't even need to check that he has the right preimage or anything;
                            //because resolving the htlc always results in me receiving more money
                            //After considering it, I think I should abort if sigs_and_stuff contains an amount that differs from the amount in pending_htlc
                            console.log( 185, sigs_and_stuff.amnt )
                            sigs_and_stuff.amnt = hedgehog.state[ chan_id ].balances[ 0 ] + hedgehog.state[ chan_id ].pending_htlc.amnt;
                            console.log( 186, hedgehog.state[ chan_id ].balances[ 0 ], hedgehog.state[ chan_id ].pending_htlc.amnt, sigs_and_stuff.amnt )
                            var skip_pending_check = true;
                            hedgehog.receive( sigs_and_stuff, skip_pending_check );
                            hedgehog.state[ chan_id ].pending_htlc = {}
                            //TODO: as soon as you resolve the htlc get Alice and Bob to both revoke their prior states
                            return;
                        }
                        //if the admin receives sigs, validate them and add them to the all_sigs_needed_by_admin object
                        if ( params.hasOwnProperty( "admin" ) && all_peers.includes( msg.ctx.pubkey ) && msg.tag === "sigs" ) {
                            var all_sigs_needed_by_admin = state.all_sigs_needed_by_admin;
                            var opening_info_for_hedgehog_channels = state.opening_info_for_hedgehog_channels;
                            //if you already have all the sigs you need, ignore the message
                            if ( Object.keys( all_sigs_needed_by_admin ).length === all_peers.length ) return;
                            all_sigs_needed_by_admin[ msg.ctx.pubkey ] = JSON.parse( msg.dat )[ "sigs_to_send" ];
                            opening_info_for_hedgehog_channels[ msg.ctx.pubkey ] = JSON.parse( msg.dat )[ "opening_info_for_hedgehog_channels" ];
                            //if you now have all the sigs you need, validate them and broadcast the funding tx
                            if ( Object.keys( all_sigs_needed_by_admin ).length === all_peers.length ) hedgehog_factory.validateAndBroadcast( state_id );
                            return;
                        }
                        //if the admin receives the "initiate_ln_receive" signal, run hedgehog.bobSendsHTLC()
                        if ( params.hasOwnProperty( "admin" ) && all_peers.includes( msg.ctx.pubkey ) && msg.tag === "initiate_ln_receive" ) {
                            hedgehog_factory.runInitiateLNReceive( msg, state_id );
                            return;
                        }
                        console.log( 'received msg:', msg.tag, msg.dat );
                    });
                    var connection = super_nostr.newPermanentConnection( state.relays[ 0 ], listenFunction, handleFunction );
                    console.log( `loading...` );
                    await hedgehog_factory.waitSomeTime( 2000 );
                    console.log( `ready!` );
                    var loop = async () => {
                        var event = await super_nostr.prepEvent( state.privkey, "", 52175, [ [ "e", params[ "ceremony" ].padStart( 64, "0" ) ] ] );
                        super_nostr.sendEvent( event, state.relays[ 0 ] );
                        await hedgehog_factory.waitSomeTime( 25000 );
                        loop();
                    }
                    loop();
                })();
                hedgehog_factory.whosHereCleaner( state_id );
                if ( params.hasOwnProperty( "admin" ) ) {
                    var pubkey = state.pubkey;
                    $( '.ceremony_page p' ).innerText = `Start the signing ceremony before this timer runs out:`;
                    $( '.participant_count' ).parentElement.innerHTML = `How many people are here (other than you): <span class="participant_count">loading...</span>`;
                    $$( '.user_only' ).forEach( item => item.classList.add( "hidden" ) );
                    $$( '.admin_only' ).forEach( item => item.classList.remove( "hidden" ) );
                    var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `#ceremony=${params[ "ceremony" ]}#routing_node=${pubkey}`;
                    $( '.shareable_link' ).innerText = url;
                    state.nwc_string = hedgehog_factory.hexToText( params.nwc_string );
                    var nwc_obj = nwcjs.processNWCstring( state.nwc_string );
                }
            }
            $( '.start_signing_ceremony' ).onclick = async () => {
                console.log( 'starting ceremony...' );
                var state_id = params[ "ceremony" ];
                var msg_id = state_id;
                var state = hedgehog_factory.state[ state_id ];
                state.ceremony_started = true;
                var whos_here = state.whos_here;
                var node = state.node;
                var minimum = state.minimum;
                var who_should_pay = state.who_should_pay;
                var all_peers = state.all_peers;
                var channel_size = state.channel_size;
                var amount_per_user_to_cover_p2a_costs = state.amount_per_user_to_cover_p2a_costs;
                var pubkey = state.pubkey;
                var maximum = state.maximum;
                var channel_cost = state.channel_cost;
                var address_type = state.address_type;
                var peers = Object.keys( whos_here );
                if ( peers.length > maximum ) {
                    //TODO: send a message to anyone who gets cut off telling them
                    //to try again later
                    var cut_off_people = JSON.parse( JSON.stringify( peers ) );
                    cut_off_people = cut_off_people.splice( 0, maximum );
                    peers.length = maximum;
                    var msg = JSON.stringify({
                        type: "abort",
                        value: `You have been excluded from this channel factory because we exceeded the maximum number of people allowed. Please try again in a different channel factory.`
                    });
                    node.relay( 'preparation_phase', msg, cut_off_people, msg_id );
                }
                if ( peers.length < minimum ) {
                    console.log( 'not enough' );
                    var msg = JSON.stringify({
                        type: "abort",
                        value: `Aborting because we did not have enough participants. Only ${peers.length} people showed up when there was a required minimum of ${minimum}, so well have to try again later. Please bring more people next time.`
                    });
                    node.relay( 'preparation_phase', msg, peers, msg_id );
                    return;
                }
                console.log( 'yay, there are enough peers!' );
                var pubkeys_for_hedgehog_channels = {}
                var my_privkey_for_my_hedgehog_channel_with_myself = hedgehog_factory.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var my_pubkey_for_my_hedgehog_channel_with_myself = nobleSecp256k1.getPublicKey( my_privkey_for_my_hedgehog_channel_with_myself, true ).substring( 2 );
                state.admins_pubkey_for_hedgehog_channel = my_pubkey_for_my_hedgehog_channel_with_myself;
                pubkeys_for_hedgehog_channels[ pubkey ] = my_pubkey_for_my_hedgehog_channel_with_myself;
                state.admin_preimage_for_own_hedgehog_channel = hedgehog_factory.bytesToHex( window.crypto.getRandomValues( new Uint8Array( 16 ) ) );
                state.initial_state_hash = hedgehog.rmd160( hedgehog.hexToBytes( state.admin_preimage_for_own_hedgehog_channel ) );
                state.admin_privkey_for_own_hedgehog_channel = my_privkey_for_my_hedgehog_channel_with_myself;
                hedgehog.keypairs[ state.admins_pubkey_for_hedgehog_channel ] = {
                    privkey: my_privkey_for_my_hedgehog_channel_with_myself,
                    preimage: state.admin_preimage_for_own_hedgehog_channel,
                }
                var i; for ( i=0; i<peers.length; i++ ) {
                    var peer = peers[ i ];
                    console.log( `getting an invoice for ${peer}` );
                    var delay_tolerance = 10;
                    var invoice_data = await nwcjs.makeInvoice( nwcjs.nwc_infos[ 0 ], channel_cost, "", delay_tolerance );
                    if ( invoice_data.hasOwnProperty( "error" ) && invoice_data.error ) throw "your nwc string is not giving you invoices, check what's wrong";
                    var invoice = invoice_data.result.invoice;
                    var preimage_for_this_channel = hedgehog_factory.bytesToHex( nobleSecp256k1.utils.randomBytes( 16 ) );
                    var privkey_for_this_channel = hedgehog_factory.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    var pubkey_for_this_channel = nobleSecp256k1.getPublicKey( privkey_for_this_channel, true ).substring( 2 );
                    hedgehog.keypairs[ pubkey_for_this_channel ] = {
                        privkey: privkey_for_this_channel,
                        preimage: preimage_for_this_channel,
                    }
                    pubkeys_for_hedgehog_channels[ peer ] = pubkey_for_this_channel;
                    who_should_pay[ peer ] = [ "not_paid", invoice, preimage_for_this_channel, privkey_for_this_channel ];
                }
                state.admin_pubkeys_for_hedgehog_channels = pubkeys_for_hedgehog_channels;
                var i; for ( i=0; i<peers.length; i++ ) {
                    var peer = peers[ i ];
                    var index = i;
                    console.log( `sending ${peer} their invoice` );
                    var msg = JSON.stringify({
                        type: "pay_invoice",
                        value: invoice,
                    });
                    node.send( 'preparation_phase', msg, peers[ index ], msg_id );
                    var start_time = Math.floor( Date.now() / 1000 );
                    console.log( `in 10 seconds we will check if ${peer}'s invoice is paid` );
                    var loop = async () => {
                        //TODO: uncomment the following 12 lines to stop pretending everyone paid
                        // await hedgehog_factory.waitSomeTime( 10 * 1000 );
                        // console.log( `checking if ${peer}'s invoice is paid` );
                        // var now = Math.floor( Date.now() / 1000 );
                        // var status_data = await nwcjs.checkInvoice( nwcjs.nwc_infos[ 0 ], invoice, delay_tolerance );
                        // if ( now - start_time > 60 ) return console.log( `timing out this peer: ${peer}` );
                        // console.log( `${peer}'s invoice is paid, right?`, !!status_data.result.settled_at );
                        // //if settled_at is null I should loop
                        // // if ( !status_data.result.settled_at ) {
                        // //     console.log( `in another 10 seconds we will check again if ${peer}'s invoice is paid` );
                        // //     return loop();
                        // // }
                        // //otherwise I should mark them as paid
                        who_should_pay[ peer ][ 0 ] = "paid";
                        all_peers.push( peer );
                        console.log( `${peer} paid` );
                        var hash_for_hedgehog_channel = hedgehog.rmd160( hedgehog.hexToBytes( who_should_pay[ peer ][ 2 ] ) );
                        var msg = JSON.stringify({
                            type: "invoice_paid",
                            value: JSON.stringify({
                                //give each user a hash for use in
                                //creating the initial state of the hedgehog
                                //channel (they need to pass in your pubkey-
                                //hash pair in order to give you a sig that
                                //lets you withdraw everything in the initial
                                //state)
                                hash_for_hedgehog_channel,
                                pubkeys_for_hedgehog_channels,
                                //TODO: also give each user a blind signature
                            }),
                        });
                        node.send( 'preparation_phase', msg, peers[ index ], msg_id );
                    }
                    await loop();
                }
                //TODO: kick people out of admin_pubkeys_for_hedgehog_channels if they don't pay or don't sign right data
                //abort if, after 60 seconds, not enough people paid to meet your minimum
                //TODO: fix the wait time -- I should wait a maximum of 60 seconds for everyone to send back their data
                var peers_to_message = JSON.parse( JSON.stringify( all_peers ) );
                var num_who_paid = Object.keys( who_should_pay ).length;
                Object.keys( who_should_pay ).forEach( participant => {
                    if ( who_should_pay[ participant ][ 0 ] !== "paid" ) num_who_paid = num_who_paid - 1;
                });
                console.log( "num who paid:", num_who_paid, "minimum:", minimum );
                if ( num_who_paid < minimum ) {
                    console.log( 'not enough paid' );
                    console.log( who_should_pay );
                    var were_or_was = minimum - num_who_paid === 1 ? "was a troll" : "were trolls";
                    var msg = JSON.stringify({
                        type: "abort",
                        value: `Aborting because ${peers.length} people registered (which is enough because the minimum was ${minimum}) but ${minimum - num_who_paid} of them ${were_or_was}, so the number of real participants was less than ${minimum}, so well have to try again later. Please bring more people next time.`
                    });
                    node.relay( 'preparation_phase', msg, peers_to_message, msg_id );
                    return;
                }
                console.log( 'enough paid' );
                // Give everyone the list of participating pubkeys, sorted in random order (you got their pubkeys when they announced their presence)
                var randomized_peers = hedgehog_factory.shuffle( JSON.parse( JSON.stringify( peers ) ) );
                all_peers.push( pubkey );
                // Give everyone the utxo data of a sufficient number of inputs to make your 1-or-2 output transaction (utxo data consists of a txid, a vout, an amount, and an address)
                var required_sum = ( channel_size * ( randomized_peers.length + 1 ) ) + ( amount_per_user_to_cover_p2a_costs * ( randomized_peers.length + 1 ) ) + 830;
                var admin_addy = tapscript.Address.fromScriptPubKey( [ 1, pubkey ], address_type );
                console.log( `send at least ${required_sum} to this address:` );
                console.log( admin_addy );
                var txid = prompt( `send at least ${required_sum} sats to the address in your console and enter the txid` );
                var vout = Number( prompt( `and the vout` ) );
                var amnt = Number( prompt( `and the amount` ) );
                var utxos_for_protocol = [{txid, vout, amnt, addy: admin_addy}];
                // Give everyone a feerate to use when creating the 1-or-2 output transaction
                // TODO: actually check a feerate source and ensure the feerate chosen is at or above the fast-track option
                var sats_per_byte = 1;
                // Give everyone a change address to send the change to when creating the 1-or-2 output transaction
                //TODO: use a "real" change address
                var change_address = "tb1phl9kvt953d9rwvwy322fjpdgf95wqvj0l9rhgfnwgknqgfcwdkwqwrfkf8";
                var msg = JSON.stringify({
                    type: "official_peers_and_utxos_list",
                    value: { randomized_peers, utxos_for_protocol, sats_per_byte, change_address },
                });
                node.relay( 'signing_phase', msg, peers_to_message, msg_id );
                hedgehog_factory.startSigning( msg, state_id );
            }
        </script>
    </body>
</html>
