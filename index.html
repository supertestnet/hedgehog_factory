<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <script>var nostr_p2p = null;</script>
        <script src="https://supertestnet.github.io/hedgehog-advanced/tapscript.js"></script>
        <script src="https://supertestnet.github.io/hedgehog-advanced/rmd160.js"></script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/bolt11.js"></script>
        <script src="https://supertestnet.github.io/nostr_p2p/nostr_p2p.js"></script>
        <script src="https://supertestnet.github.io/bankify/super_nostr.js"></script>
        <script src="https://supertestnet.github.io/nwcjs/nwcjs.js"></script>
        <!-- <script src="https://unpkg.com/@cmdcode/tapscript@1.5.1"></script> -->
        <!-- <script src="https://bundle.run/browserify-cipher@1.0.1"></script> -->
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script>
            var hedgehog = {
                network: "testnet",
                state: {},
                keypairs: {},
                state_obj: {
                    alices_privkey: null,
                    bobs_privkey: null,
                    alices_pubkey: null,
                    bobs_pubkey: null,
                    multisig_script: null,
                    multisig_tree: null,
                    multisig_utxo_info: {},
                    i_was_last_to_send: false,
                    alice_can_revoke: [],
                    bob_can_revoke: [],
                    balances: [],
                    balances_before_most_recent_send: [],
                    balances_before_most_recent_receive: [],
                    alices_revocation_preimages: [],
                    alices_revocation_hashes: [],
                    bobs_revocation_preimages: [],
                    bobs_revocation_hashes: [],
                    txids_to_watch_for: {},
                    latest_force_close_txs: [],
                    extra_outputs: [],
                    pending_htlc: {},
                },
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                bytesToHex: bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" ),
                rmd160: s => {
                    if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                    var hash = RIPEMD160.create();
                    hash.update( new Uint8Array( s ) );
                    return hedgehog.bytesToHex( hash.digest() );
                },
                sha256: async s => {
                    if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                    var hash = await nobleSecp256k1.utils.sha256( new Uint8Array( s ) );
                    return hedgehog.bytesToHex( hash );                    
                },
                waitSomeSeconds: num => {
                    var num = num.toString() + "000";
                    num = Number( num );
                    return new Promise( resolve => setTimeout( resolve, num ) );
                },
                getInvoicePmthash: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var i; for ( i=0; i<decoded[ "tags" ].length; i++ ) {
                        if ( decoded[ "tags" ][ i ][ "tagName" ] == "payment_hash" ) var pmthash = decoded[ "tags" ][ i ][ "data" ].toString();
                    }
                    return pmthash;
                },
                getInvoiceAmount: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var amount = decoded[ "satoshis" ].toString();
                    return Number( amount );
                },
                isValidHex: hex => {
                    if ( !hex ) return;
                    var length = hex.length;
                    if ( length % 2 ) return;
                    try {
                        var bigint = BigInt( "0x" + hex, "hex" );
                    } catch( e ) {
                        return;
                    }
                    var prepad = bigint.toString( 16 );
                    var i; for ( i=0; i<length; i++ ) prepad = "0" + prepad;
                    var padding = prepad.slice( -Math.abs( length ) );
                    return ( padding === hex );
                },
                getVin: ( txid, vout, amnt, addy, sequence ) => {
                    var input = {
                        txid,
                        vout,
                        prevout: {
                            value: amnt,
                            scriptPubKey: tapscript.Address.toScriptPubKey( addy ),
                        },
                    }
                    if ( sequence ) input[ "sequence" ] = sequence;
                    return input;
                },
                getVout: ( amnt, addy ) => ({
                    value: amnt,
                    scriptPubKey: tapscript.Address.toScriptPubKey( addy ),
                }),
                makeAddress: ( scripts ) => {
                    var tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var pubkey = "ab".repeat( 32 );
                    var [ tpubkey ] = tapscript.Tap.getPubKey( pubkey, { tree });
                    return tapscript.Address.p2tr.fromPubKey( tpubkey, hedgehog.network );
                },
                makeAlicesRevocationScript: chan_id => ([
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    [ "OP_RIPEMD160", hedgehog.state[ chan_id ].alices_revocation_hashes[ hedgehog.state[ chan_id ].alices_revocation_hashes.length - 1 ], "OP_EQUALVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    //TODO: change the 10 to 4032
                    [ 10, "OP_CHECKSEQUENCEVERIFY", "OP_DROP", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                ]),
                makeBobsRevocationScript: chan_id => ([
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    [ "OP_RIPEMD160", hedgehog.state[ chan_id ].bobs_revocation_hashes[ hedgehog.state[ chan_id ].bobs_revocation_hashes.length - 1 ], "OP_EQUALVERIFY", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG" ],
                    //TODO: change the 10 to 4032
                    [ 10, "OP_CHECKSEQUENCEVERIFY", "OP_DROP", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG" ],
                ]),
                makeHTLC: ( chan_id, hash ) => ([
                    [ "OP_SIZE", 32, "OP_EQUALVERIFY", "OP_SHA256", hash, "OP_EQUALVERIFY", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                ]),
                openChannel: async ( push_all_funds_to_counterparty, alices_pubkey_and_hash = null, papa_swap_hash = null, utxos_for_papa_swap = null, deposit_amount = null, change_address = null, data = null, bobs_privkey = null ) => {
                    //there are three ways to open a channel:
                    //the first way is as Bob, opening a channel to Alice unilaterally
                    //the code for that appears after this "if" statement (not in it) because a
                    //unilateral channel open requires pushing all funds to your counterparty
                    //the second way is as Alice, accepting a channel Bob already unilaterally opened
                    //the third way is as Alice, opening a new channel cooperatively with Bob
                    //the second and third ways are handled in the first "if" statement below
                    //in theory there are two more ways: Bob could open a channel to Alice cooperatively
                    //and thus keep some or all of the funds on his side, or Alice could open a channel
                    //to Bob unilaterally and thus push all funds to Bob's side. To do these examples,
                    //just have Alice open a channel with push_all_funds_to_counterparty set to true
                    //or have Bob open a channel with push_all_funds_to_counterparty set to false
                    if ( !push_all_funds_to_counterparty ) {
                        if ( !data ) {
                            var has_data = confirm( `Click ok if someone sent you channel opening info or cancel if you are opening this channel yourself` );
                        } else {
                            has_data = true;
                        }
                        if ( has_data ) {
                            if ( !data ) data = JSON.parse( prompt( `Enter the data your counterparty sent you` ) );
                            //TODO: validate the data so you don't acccidentally accept irredeemable coins
                            //or crash your wallet

                            //create the state object
                            var pubkey = data[ "recipient_pubkey" ];
                            if ( !( pubkey in hedgehog.keypairs ) ) return alert( `Your counterparty tried to scam you! Do not interact with them any further` );
                            var privkey = hedgehog.keypairs[ pubkey ][ "privkey" ];
                            var preimage = hedgehog.keypairs[ pubkey ][ "preimage" ];
                            var chan_id = data[ "chan_id" ];
                            hedgehog.state[ chan_id ] = hedgehog.state_obj;
                            hedgehog.state[ chan_id ][ "alices_privkey" ] = privkey;
                            hedgehog.state[ chan_id ][ "alices_pubkey" ] = pubkey;
                            hedgehog.state[ chan_id ][ "bobs_pubkey" ] = data[ "sender_pubkey" ];
                            hedgehog.state[ chan_id ][ "multisig_utxo_info" ] = data[ "utxo_info" ];
                            hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                            var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                            hedgehog.state[ chan_id ].alices_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].alices_pubkey ], hedgehog.network );
                            hedgehog.state[ chan_id ].bobs_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].bobs_pubkey ], hedgehog.network );
                            var multisig_script = [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ];
                            var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                            hedgehog.state[ chan_id ].multisig_script = multisig_script;
                            hedgehog.state[ chan_id ].multisig_tree = multisig_tree;
                            hedgehog.state[ chan_id ].multisig = hedgehog.makeAddress( [ multisig_script ] );

                            //temporarily pretend the entire balance is on Bob's side so he can
                            //send it to Alice using the regular send command
                            var amnt = data[ "amnt" ];
                            hedgehog.state[ chan_id ].balances = [ 0, amnt ];
                            var opening = true;

                            //validate the initial state using the regular "receive" function
                            var opened = await hedgehog.receive( {amnt: amnt - 500 - 500, sig_1: data[ "sig_1" ], sig_3: data[ "sig_3" ], chan_id: data[ "chan_id" ], hash: data[ "hash" ]} );
                            if ( opened !== true ) return;

                            //update the state to reflect alice's ability to withdraw 100%
                            hedgehog.state[ chan_id ].balances = [ amnt, 0 ];

                            //update the send/receive/close buttons to use this channel
                            // $( '.send_btn' ).onclick = () => {console.log( "send this data to your recipient:" );console.log( JSON.stringify( hedgehog.send( chan_id ) ) );}
                            // $( '.receive_btn' ).onclick = () => {hedgehog.receive();}
                            // $( '.close_channel' ).onclick = () => {hedgehog.closeChannel( chan_id );}
                            // $( '.send_htlc_btn' ).onclick = async () => {
                            //     var chan_id = Object.keys( hedgehog.state )[ 0 ];
                            //     var amnt = Number( prompt( `enter an amount of sats you want to send to the htlc` ) );
                            //     var info_for_bob = await hedgehog.aliceSendsHtlc( chan_id, amnt );
                            // }
                            // alert( `yay, your channel is open!` );
                            return true;
                        } else {
                            // In this way, Alice does *not* receive data from Bob but instead
                            // opens a channel to him *cooperatively.* It is not yet implemented
                        }
                        return;
                    }

                    //handle the case where Bob opens a channel to Alice unilaterally
                    //start by preparing the state object
                    var chan_id = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    hedgehog.state[ chan_id ] = hedgehog.state_obj;
                    if ( !bobs_privkey ) hedgehog.state[ chan_id ].bobs_privkey = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    else hedgehog.state[ chan_id ].bobs_privkey = bobs_privkey;
                    hedgehog.state[ chan_id ].bobs_pubkey = nobleSecp256k1.getPublicKey( hedgehog.state[ chan_id ].bobs_privkey, true ).substring( 2 );
                    if ( !alices_pubkey_and_hash ) alices_pubkey_and_hash = JSON.parse( prompt( `Enter Alice's pubkey and revocation hash` ) );
                    hedgehog.state[ chan_id ].alices_pubkey = alices_pubkey_and_hash[ 0 ];
                    hedgehog.state[ chan_id ].alices_revocation_hashes.push( alices_pubkey_and_hash[ 1 ] );
                    hedgehog.state[ chan_id ].alices_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].alices_pubkey ], hedgehog.network );
                    hedgehog.state[ chan_id ].bobs_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].bobs_pubkey ], hedgehog.network );
                    var multisig_script = [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ];
                    var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                    hedgehog.state[ chan_id ].multisig_script = multisig_script;
                    hedgehog.state[ chan_id ].multisig_tree = multisig_tree;
                    hedgehog.state[ chan_id ].multisig = hedgehog.makeAddress( [ multisig_script ] );
                    if ( papa_swap_hash ) {
                        //we are using a papa swap so a transaction needs to go from the multisig to a
                        //revocable address; and a 2 week timelock from the revocable address should give
                        //the funds back to Bob; but if he revokes this path, then of course Alice can
                        //sweep it if Bob tries to use it, because she will have the revocation preimage.
                        var vin = [];
                        var sum = 0;
                        utxos_for_papa_swap.forEach( utxo => {
                            sum = sum + utxo.amnt;
                            vin.push( hedgehog.getVin( utxo.txid, utxo.vout, utxo.amnt, utxo.addy ) );
                        });
                        var papa_swap_funding_tx = tapscript.Tx.create({
                            vin,
                            vout: [hedgehog.getVout( deposit_amount, hedgehog.state[ chan_id ].multisig )],
                        });
                        var deposit_mining_txfee = 500;
                        if ( sum - deposit_amount - deposit_mining_txfee > 330 ) {
                            papa_swap_funding_tx.vout.push( hedgehog.getVout( sum - deposit_amount - deposit_mining_txfee, change_address ) );
                        }
                        var i; for ( i=0; i<papa_swap_funding_tx.vin.length; i++ ) {
                            var utxo = utxos_for_papa_swap[ i ];
                            var sig = tapscript.Signer.taproot.sign( utxo[ "skey" ], papa_swap_funding_tx, 0 ).hex;
                            papa_swap_funding_tx.vin[ i ].witness = [ sig ];
                        }
                        var funding_txhex = tapscript.Tx.encode( papa_swap_funding_tx ).hex;
                        var txid = tapscript.Tx.util.getTxid( papa_swap_funding_tx );
                        var utxos_created = [];
                        if ( sum - deposit_amount - deposit_mining_txfee > 330 ) {
                            utxos_created.push( {txid, vout: 1, amnt: sum - deposit_amount - deposit_mining_txfee, addy: change_address } );
                        }
                        var vout = 0;
                        var amnt = deposit_amount;

                        var revocable_scripts = [
                            [
                                2016,
                                "OP_CHECKSEQUENCEVERIFY",
                                "OP_DROP",
                                hedgehog.state[ chan_id ].bobs_pubkey,
                                "OP_CHECKSIG",
                            ],
                            [
                                "OP_SIZE",
                                32,
                                "OP_EQUALVERIFY",
                                "OP_SHA256",
                                papa_swap_hash,
                                "OP_EQUALVERIFY",
                                hedgehog.state[ chan_id ].alices_pubkey,
                                "OP_CHECKSIG",
                            ]
                        ];

                        var revocable_address = hedgehog.makeAddress( revocable_scripts );

                        hedgehog.state[ chan_id ].multisig_utxo_info = {
                            txid,
                            vout,
                            amnt,
                        }

                        //temporarily pretend the entire balance is on Bob's side so he can
                        //send it to Alice using the regular send command
                        hedgehog.state[ chan_id ].balances = [ 0, amnt ];

                        //prepare the transaction that moves all funds to Alice's side
                        var opening = true;
                        var sigs_and_stuff = hedgehog.send( chan_id, amnt - 500 - 500, opening );
                        sigs_and_stuff[ "amnt" ] = amnt;

                        //update the state to reflect alice's ability to withdraw 100%
                        hedgehog.state[ chan_id ].balances = [ amnt, 0 ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ amnt, 0 ];

                        // update the send/receive/close buttons to use this channel
                        // $( '.send_btn' ).onclick = () => {console.log( "send this data to your recipient:" );console.log( JSON.stringify( hedgehog.send( chan_id ) ) );}
                        // $( '.receive_btn' ).onclick = () => {hedgehog.receive();}
                        // $( '.close_channel' ).onclick = () => {hedgehog.closeChannel( chan_id );}
                        // alert( `yay, your channel is funded! send your counterparty the info in your console` );
                        return [ chan_id, sigs_and_stuff, funding_txhex, utxos_created ];
                    }
                    console.log( "address:", hedgehog.state[ chan_id ].multisig );

                    var txid = prompt( `send some sats to this address and give the txid:\n\n${hedgehog.state[ chan_id ].multisig}` );
                    var vout = Number( prompt( `and the vout` ) );
                    var amnt = Number( prompt( `and the amount` ) );
                    hedgehog.state[ chan_id ].multisig_utxo_info = {
                        txid,
                        vout,
                        amnt,
                    }

                    //temporarily pretend the entire balance is on Bob's side so he can
                    //send it to Alice using the regular send command
                    hedgehog.state[ chan_id ].balances = [ 0, amnt ];

                    //prepare the transaction that moves all funds to Alice's side
                    var opening = true;
                    var sigs_and_stuff = hedgehog.send( chan_id, amnt - 500 - 500, opening );
                    sigs_and_stuff[ "amnt" ] = amnt;
                    console.log( "send this data to your recipient:" );
                    console.log( JSON.stringify( sigs_and_stuff ) );

                    //update the state to reflect alice's ability to withdraw 100%
                    hedgehog.state[ chan_id ].balances = [ amnt, 0 ];
                    hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ amnt, 0 ];

                    //update the send/receive/close buttons to use this channel
                    $( '.send_btn' ).onclick = () => {console.log( "send this data to your recipient:" );console.log( JSON.stringify( hedgehog.send( chan_id ) ) );}
                    $( '.receive_btn' ).onclick = () => {hedgehog.receive();}
                    $( '.close_channel' ).onclick = () => {hedgehog.closeChannel( chan_id );}
                    alert( `yay, your channel is funded! send your counterparty the info in your console` );
                },
                send: ( chan_id, amnt, opening, skip_pending_check ) => {
                    if ( !skip_pending_check && Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot send money while you have one...clear it before proceeding` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_send;
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                    }

                    //unless an amount is already given, prompt the user to enter an amount
                    if ( !amnt ) amnt = Number( prompt( `Please enter an amount you want to send to your counterparty` ) );

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Bob but I sent him 5k,
                    //current_balances would say he has 5k. If I am now
                    //sending him 1k, amnt should be 6k, which is 
                    //( current_balances[ 1 ] - prev_balance[ 1 ] ) + amnt
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                        else amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                    }

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create and sign the timeout tx in case your counterparty takes
                    //too long to force close or disappears during a force closure
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    //tx0 sends all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    if ( am_alice ) var my_address = alices_address;
                    else var my_address = bobs_address;
                    var timeout_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 10 to 4032
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                    });
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var timeout_tx_script = latest_scripts[ 2 ];
                    var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                    var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: timeout_tx_tree, target: timeout_tx_target });
                    timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                    hedgehog.state[ chan_id ].txids_to_watch_for[ tx0_id ] = {
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                    }

                    //create tx1 to distribute the funds however the sender wishes to do so
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [],
                    });

                    //increase the recipient's balance by amnt and decrease the sender's by
                    //amnt and two mining fees
                    if ( am_alice ) {
                        var amnt_for_alice = balances[ 0 ] - amnt - 500 - 500;
                        var amnt_for_bob = balances[ 1 ] + amnt;
                    } else {
                        var amnt_for_alice = balances[ 0 ] + amnt;
                        var amnt_for_bob = balances[ 1 ] - amnt - 500 - 500;
                        if ( opening ) var amnt_for_bob = 0;
                    }
                    if ( am_alice ) {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }
                    console.log( 87, tx1.vout );
                    // console.log( "tx0:", JSON.stringify( tx0 ) );
                    // console.log( "tx1:", JSON.stringify( tx1 ) );

                    //Sign both of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    //sig_3 is for tx1 and it has a relative timelock of 2016 blocks
                    //because tx1's only input (see above) has sequence number 2016
                    var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;

                    //If necessary, create a revocation sig that conditionally revokes
                    //the prior state
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, prepare to reveal whichever preimage fully revokes
                    //the state prior to the prior state (yes, doubly prior)
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chan_id ].alices_revocation_preimages[ hedgehog.state[ chan_id ].alices_revocation_preimages.length - 2 ];
                        else var full_revocation_preimage = hedgehog.state[ chan_id ].bobs_revocation_preimages[ hedgehog.state[ chan_id ].bobs_revocation_preimages.length - 2 ];
                    }

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                    } else {
                        hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                    }
                    //Create an object to send all this data to the recipient
                    var object = {
                        sig_1,
                        sig_3,
                        hash,
                        amnt,
                        chan_id,
                    }
                    if ( conditional_revocation_sig ) object[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;
                    if ( opening ) object[ "utxo_info" ] = utxo_info;
                    if ( opening ) object[ "sender_pubkey" ] = hedgehog.state[ chan_id ].bobs_pubkey;
                    if ( opening ) object[ "recipient_pubkey" ] = hedgehog.state[ chan_id ].alices_pubkey;

                    //update the balances
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                    } else {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = true;

                    return object;
                },
                receive: async ( data, skip_pending_check ) => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];

                    if ( !skip_pending_check && Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot receive money in this channel while you have one...clear it before proceeding` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) {
                            if ( amnt <= hedgehog.state[ chan_id ].balances[ 0 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 0 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );                            
                        } else {
                            if ( amnt <= hedgehog.state[ chan_id ].balances[ 1 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 1 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );
                        }
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_receive;
                        if ( !hedgehog.state[ chan_id ].balances.length ) {
                            var sum = current_balances[ 0 ] + current_balances[ 1 ];
                            if ( am_alice ) hedgehog.state[ chan_id ].balances = [ 0, sum ];
                            else hedgehog.state[ chan_id ].balances = [ sum, 0 ];
                        }
                        if ( am_alice ) {
                            var old_rev_hashes = hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].alice_can_revoke.pop();
                        } else {
                            var old_rev_hashes = hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].bob_can_revoke.pop();
                        }
                    }

                    //push your counterparty's payment hash to their hashes object
                    if ( am_alice ) hedgehog.state[ chan_id ].bobs_revocation_hashes.push( data[ "hash" ] );
                    else hedgehog.state[ chan_id ].alices_revocation_hashes.push( data[ "hash" ] );

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create tx0 to send all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var amnt = data[ "amnt" ];
                    var balances = hedgehog.state[ chan_id ].balances;
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                    //create tx1 to distribute the funds however the sender wishes to do so
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [],
                    });

                    //increase the recipient's balance by amnt and decrease the sender's by
                    //amnt and two mining fees
                    if ( am_alice ) {
                        var amnt_for_alice = balances[ 0 ] + amnt;
                        var amnt_for_bob = balances[ 1 ] - amnt - 500 - 500;
                        if ( data_was_here_originally && !skip_pending_check ) var amnt_for_bob = 0;
                    } else {
                        var amnt_for_alice = balances[ 0 ] - amnt - 500 - 500;
                        var amnt_for_bob = balances[ 1 ] + amnt;
                    }
                    if ( am_alice ) {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }
                    console.log( 88, tx1.vout );
                    // console.log( "tx0:", JSON.stringify( tx0 ) );
                    // console.log( "tx1:", JSON.stringify( tx1 ) );

                    //validate the signatures by which the sender creates the new state
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var sig_1 = data[ "sig_1" ];
                    var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                    var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                    var sig_3 = data[ "sig_3" ];
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                    var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );
                    if ( !is_valid_1 || !is_valid_3 ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    //Sign both of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;

                    //If necessary, validate the signature by which the sender
                    //conditionally revokes the old state and cosign the revocation
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( !( "conditional_revocation_sig" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = data[ "conditional_revocation_sig" ];
                        var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                        var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                        if ( !conditional_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                        var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, validate the preimage by which the sender
                    //fully revokes the old state and sign the revocation
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( !( "full_revocation_preimage" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 1 ];
                        var preimage = data[ "full_revocation_preimage" ];
                        var expected_hash = prev_scripts[ 1 ][ 1 ];
                        var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                        if ( hash_provided != expected_hash ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                        }
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var tx2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        var tx2_script = prev_scripts[ 1 ];
                        var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                        var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                    }

                    //prepare and save the force closure initiation transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx0_tree, target: tx0_target });
                    //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                    //the first sig must be sig_2 -- which means it must be in the "last"
                    //position (i.e. the sig created by Alice must appear right before her pubkey)
                    if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                    else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                    //prepare the force closure finalization transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx1_tree, target: tx1_target });
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                    else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx1_tree, target: new_tx1_target });
                        if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                        else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                    }

                    //if necessary, prepare and save the full revocation transaction
                    if ( full_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx2_tree, target: tx2_target });
                        tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                    }

                    //save the transactions
                    hedgehog.state[ chan_id ].latest_force_close_txs = [
                        tapscript.Tx.encode( tx0 ).hex,
                        tapscript.Tx.encode( tx1 ).hex,
                    ];
                    if ( conditional_revocation_is_necessary ) {
                        hedgehog.state[ chan_id ].txids_to_watch_for[ prev_txid ] = {
                            conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                        }
                    }
                    if ( full_revocation_is_necessary ) hedgehog.state[ chan_id ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                    //update the balances
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                    } else {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = false;

                    return true;
                },
                aliceSendsHtlc: async ( chan_id, amnt, htlc_hash = null, invoice_to_pay ) => {
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and you want to make an htlc worth less than that, i.e. only ${amnt} sats, so it cannot be done -- the software refuses and your only recourse is to find or make a modified version that allows dust htlcs` );
                    console.log( amnt );
                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot send money while you have one...clear it before proceeding` );
                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;
                    if ( !am_alice ) return;

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_send;
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                    }

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Bob but I sent him 5k,
                    //current_balances would say he has 5k. If I am now
                    //sending him 1k, amnt should be 6k, which is 
                    //( current_balances[ 1 ] - prev_balance[ 1 ] ) + amnt
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                        else amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                    }

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create and sign the timeout tx in case your counterparty takes
                    //too long to force close or disappears during a force closure
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    //tx0 sends all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    if ( am_alice ) var my_address = alices_address;
                    else var my_address = bobs_address;
                    var timeout_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 10 to 4032
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                    });
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var timeout_tx_script = latest_scripts[ 2 ];
                    var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                    var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: timeout_tx_tree, target: timeout_tx_target });
                    timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                    hedgehog.state[ chan_id ].txids_to_watch_for[ tx0_id ] = {
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                    }

                    //create the htlc
                    if ( !htlc_hash ) {
                        var htlc_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                        htlc_hash = await hedgehog.sha256( hedgehog.hexToBytes( htlc_preimage ) );
                    } else {
                        var htlc_preimage = null;
                    }
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 1996
                        //note that it is 20 blocks less than 2016 because below, we will give
                        //second_from_htlc_tx a timelock of 2026, 10 blocks longer than any LN invoice (so the
                        //operator can't be screwed by paying a 2016 block lightning invoice),
                        //and we want the sum of that timelock plus this one (2026+1996) to be
                        //10 blocks less than 4032, that way the operator can't be stolen from
                        //on the grounds that he disappeared
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create first_from_htlc_tx to disperse the funds from the htlc to the new state if
                    //Bob discloses his knowledge of the preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                            hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                        ],
                    });

                    //create second_from_htlc_tx to disperse the funds from the htlc to the current state
                    //if Bob does not disclose his knowledge of the preimage in time
                    var amnt_for_alice = balances[ 0 ] - 500 - 500 - 500;
                    var amnt_for_bob = balances[ 1 ];
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2026
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    //sig_3 is for tx1 and it has a relative timelock of 1996 blocks
                    //because tx1's only input (see above) has sequence number 1996
                    var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    //alices_first_htlc_sig is for first_from_htlc_tx which lets Bob create the latest
                    //state if he learns the preimage
                    var alices_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    //alices_second_htlc_sig is for second_from_htlc_tx which restores the current state
                    //if Bob doesn't learn the preimage in time
                    var alices_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;

                    //If necessary, create a revocation sig that conditionally revokes
                    //the prior state
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                                hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                            ],
                        });
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2026
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                        var alices_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var alices_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    }

                    //If necessary, prepare to reveal whichever preimage fully revokes
                    //the state prior to the prior state (yes, doubly prior)
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chan_id ].alices_revocation_preimages[ hedgehog.state[ chan_id ].alices_revocation_preimages.length - 2 ];
                        else var full_revocation_preimage = hedgehog.state[ chan_id ].bobs_revocation_preimages[ hedgehog.state[ chan_id ].bobs_revocation_preimages.length - 2 ];
                    }

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                    } else {
                        hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = true;

                    //collect info to send to bob
                    var info_for_bob = {
                        alices_first_htlc_sig,
                        alices_second_htlc_sig,
                        htlc_hash,
                        hash,
                        amnt,
                        chan_id,
                        alices_conditional_first_htlc_sig,
                        alices_conditional_second_htlc_sig,
                    }

                    //don't send the rest of the data til Bob cosigns first_from_htlc_tx and second_from_htlc_tx
                    //and the conditional versions thereof
                    // console.log( `send this info to bob:` );
                    // console.log( JSON.stringify( info_for_bob ) );
                    var recipient = $_GET[ "layer2" ];
                    var depositor_id = Object.keys( l2generator.state.depositor_data )[ 0 ];
                    var nostr_privkey = l2generator.state.depositor_data[ depositor_id ].nostr_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var secret = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "initiate_ln_payment",
                        msg: {
                            info_for_bob,
                            secret,
                            invoice_to_pay,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_bob = await getNote( secret );
                    sessionStorage.removeItem( secret );
                    var { secret_for_responding_to_bob } = JSON.parse( preparsed_info_from_bob );
                    var info_from_bob = JSON.parse( preparsed_info_from_bob )[ "data_for_alice" ];
                    var { bobs_first_htlc_sig, bobs_second_htlc_sig, bobs_conditional_first_htlc_sig, bobs_conditional_second_htlc_sig } = info_from_bob;
                    // var { bobs_first_htlc_sig, bobs_second_htlc_sig, bobs_conditional_first_htlc_sig, bobs_conditional_second_htlc_sig } = JSON.parse( prompt( `send the info in your console to bob and enter his reply -- btw he should be running hedgehog.bobReceivesHTLC()` ) );

                    //validate the sigs
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_first_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_first_htlc_sig, first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var bobs_second_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_second_htlc_sig, second_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var new_first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_conditional_htlc_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_first_htlc_sig, new_first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var new_second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var bobs_conditional_htlc_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_second_htlc_sig, new_second_from_htlc_tx_sighash, pubkey_to_validate_against );
                    if ( !bobs_first_htlc_sig_is_valid || !bobs_second_htlc_sig_is_valid || !bobs_conditional_htlc_1_sig_is_valid || !bobs_conditional_htlc_2_sig_is_valid ) {
                        //restore previous state
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                        return;
                    }

                    //send bob the rest of the data

                    //Create an object to send all this data to the recipient
                    //but don't send him the htlc_preimage -- that's for Alice
                    //only
                    var object = {
                        sig_1,
                        sig_3,
                    }
                    if ( conditional_revocation_sig ) object[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;

                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify( object ),
                            secret: secret_for_responding_to_bob,
                        }
                    });
                    var recipient = $_GET[ "layer2" ];
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );

                    // console.log( `send this info to bob:` );
                    // console.log( JSON.stringify( object ) );
                    // alert( `send the info in your console to bob and then click ok` );

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    console.log( "prev_tx0:" );
                    console.log( prev_force_close_tx );

                    if ( htlc_preimage ) {
                        console.log( 'here is the preimage your counterparty needs, they should run hedgehog.settleIncomingHTLC() and enter it' );
                        console.log( JSON.stringify({chan_id, preimage: htlc_preimage}) );
                    }

                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "alice",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage,
                        htlc_hash,
                        force_close_tx: prev_force_close_tx,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        restore_current_state_after_force_close: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        when_to_restore_current_state: 2026, //longer than any lightning invoice locktime
                        //note that the timeout_tx is there in case your counterparty disappears after you
                        //force close -- Alice can EITHER sweep the money using the timeout tx after 4032
                        //blocks, if Bob disappears entirely, or -- if she force closes and then Bob at
                        //least sticks around long enough to move the money into the htlc, but then doesn't
                        //disclose the preimage within 2026 blocks, Alice can sweep back her funds using
                        //the new_second_from_htlc_tx
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                        time_til_timeout_tx: 4032,
                    }

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Bob can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Alice's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    hedgehog.state[ chan_id ].balances_before_most_recent_receive = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    //TODO: if you have the preimage, send it to whoever you're sending money to
                    //and remember to also tell them whatever amount you are sending so
                    //they can set up a scenario where they gain that much money if they
                    //disclose the preimage to bob
                },
                bobReceivesHTLC: async ( data, secret_for_responding_to_alice, alices_nostr_pubkey, invoice_to_pay ) => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];

                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot receive money in this channel while you have one...clear it before proceeding` );

                    var amnt = data[ "amnt" ];
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and this htlc is worth only ${amnt} sats so we reject it` );
                    if ( amnt > hedgehog.state[ chan_id ].balances[ 0 ] ) return alert( `alice tried to send you more money than she has so we reject it` );
                    //TODO: ensure checking the invoice here doesn't crash my app
                    var invoice_amt = hedgehog.getInvoiceAmount( invoice_to_pay );
                    //TODO: let the operator charge a fee to pay invoices
                    if ( invoice_amt > amnt ) return alert( `alice tried to send you less money than the invoice she wants you to pay` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( amnt <= hedgehog.state[ chan_id ].balances[ 1 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 1 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_receive;
                        if ( !hedgehog.state[ chan_id ].balances.length ) {
                            var sum = current_balances[ 0 ] + current_balances[ 1 ];
                            if ( am_alice ) hedgehog.state[ chan_id ].balances = [ 0, sum ];
                            else hedgehog.state[ chan_id ].balances = [ sum, 0 ];
                        }
                        if ( am_alice ) {
                            var old_rev_hashes = hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].alice_can_revoke.pop();
                        } else {
                            var old_rev_hashes = hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].bob_can_revoke.pop();
                        }
                    }

                    //push your counterparty's payment hash to their hashes object
                    if ( am_alice ) hedgehog.state[ chan_id ].bobs_revocation_hashes.push( data[ "hash" ] );
                    else hedgehog.state[ chan_id ].alices_revocation_hashes.push( data[ "hash" ] );

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create tx0 to send all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                    //create the htlc
                    var htlc_hash = data[ "htlc_hash" ];
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 1996
                        //note that it is 20 blocks less than 2016 because below, we will give
                        //second_from_htlc_tx a timelock of 2026, 10 blocks longer than any LN invoice (so the
                        //operator can't be screwed by paying a 2016 block lightning invoice),
                        //and we want the sum of that timelock plus this one (2026+1996) to be
                        //10 blocks less than 4032, that way the operator can't be stolen from
                        //on the grounds that he disappeared
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create first_from_htlc_tx to disperse the funds from the htlc to the new state if
                    //Bob discloses his knowledge of the preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                            hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                        ],
                    });

                    //create second_from_htlc_tx to disperse the funds from the htlc to the current state
                    //if Bob does not disclose his knowledge of the preimage in time
                    var amnt_for_alice = balances[ 0 ] - 500 - 500 - 500;
                    var amnt_for_bob = balances[ 1 ];
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2026
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //validate the signatures by which the sender creates the new state
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var alices_first_htlc_sig = data[ "alices_first_htlc_sig" ];
                    var sighash_first_htlc = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var is_valid_first_htlc = await nobleSecp256k1.schnorr.verify( alices_first_htlc_sig, sighash_first_htlc, pubkey_to_validate_against );
                    var alices_second_htlc_sig = data[ "alices_second_htlc_sig" ];
                    var sighash_second_htlc = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var is_valid_second_htlc = await nobleSecp256k1.schnorr.verify( alices_second_htlc_sig, sighash_second_htlc, pubkey_to_validate_against );

                    if ( !is_valid_first_htlc || !is_valid_second_htlc ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    var bobs_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;

                    //If necessary, validate the signature by which the sender
                    //conditionally revokes the old state and cosign the revocation
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                                hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                            ],
                        });
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2026
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var alices_conditional_first_htlc_sig = data[ "alices_conditional_first_htlc_sig" ];
                        var conditional_htlc_1_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var conditional_htlc_1_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_first_htlc_sig, conditional_htlc_1_sighash, pubkey_to_validate_against );
                        var bobs_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var alices_conditional_second_htlc_sig = data[ "alices_conditional_second_htlc_sig" ];
                        var conditional_htlc_2_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var conditional_htlc_2_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_second_htlc_sig, conditional_htlc_2_sighash, pubkey_to_validate_against );
                        var bobs_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        if ( !conditional_htlc_1_is_valid || !conditional_htlc_2_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                    }

                    var data_for_alice = {
                        bobs_first_htlc_sig,
                        bobs_second_htlc_sig,
                    }
                    if ( bobs_conditional_first_htlc_sig ) data_for_alice[ "bobs_conditional_first_htlc_sig" ] = bobs_conditional_first_htlc_sig;
                    if ( bobs_conditional_second_htlc_sig ) data_for_alice[ "bobs_conditional_second_htlc_sig" ] = bobs_conditional_second_htlc_sig;

                    // console.log( `send this data to alice:` );
                    // console.log( JSON.stringify( data_for_alice ) );

                    var l2id = Object.keys( l2generator.state.l2s )[ 0 ];
                    var nostr_privkey = l2generator.state.l2s[ l2id ].l2_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var recipient = alices_nostr_pubkey;
                    var secret_for_responding_to_bob = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify({
                                data_for_alice, secret_for_responding_to_bob
                            }),
                            secret: secret_for_responding_to_alice,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_alice = await getNote( secret_for_responding_to_bob );
                    sessionStorage.removeItem( secret_for_responding_to_bob );
                    var data = JSON.parse( preparsed_info_from_alice );

                    // alert( `send the data in your console to alice and then click ok` );
                    // await hedgehog.waitSomeSeconds( 1 );
                    // var data = JSON.parse( prompt( `enter alice's reply here` ) );

                    //validate the rest of the data sent by your counterparty

                    var sig_1 = data[ "sig_1" ];
                    var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                    var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                    var sig_3 = data[ "sig_3" ];
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                    var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );

                    if ( !is_valid_1 || !is_valid_3 ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    if ( conditional_revocation_is_necessary ) {
                        if ( !( "conditional_revocation_sig" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = data[ "conditional_revocation_sig" ];
                        var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                        var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                        if ( !conditional_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                        var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, validate the preimage by which the sender
                    //fully revokes the old state and sign the revocation
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( !( "full_revocation_preimage" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 1 ];
                        var preimage = data[ "full_revocation_preimage" ];
                        var expected_hash = prev_scripts[ 1 ][ 1 ];
                        var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                        if ( hash_provided != expected_hash ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                        }
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var tx2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        var tx2_script = prev_scripts[ 1 ];
                        var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                        var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                    }

                    //prepare and save the force closure initiation transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx0_tree, target: tx0_target });
                    //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                    //the first sig must be sig_2 -- which means it must be in the "last"
                    //position (i.e. the sig created by Alice must appear right before her pubkey)
                    if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                    else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                    //prepare the force closure finalization transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx1_tree, target: tx1_target });
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                    else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx1_tree, target: new_tx1_target });
                        if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                        else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                    }

                    //prepare the transaction that uses the htlc to create the new state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                    if ( am_alice ) first_from_htlc_tx.vin[ 0 ].witness = [ alices_first_htlc_sig, bobs_first_htlc_sig, first_htlc_script, cblock ];
                    else first_from_htlc_tx.vin[ 0 ].witness = [ bobs_first_htlc_sig, alices_first_htlc_sig, first_htlc_script, cblock ];

                    //prepare the transaction that uses the htlc to restore the current state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    if ( am_alice ) second_from_htlc_tx.vin[ 0 ].witness = [ alices_second_htlc_sig, bobs_second_htlc_sig, second_htlc_script, cblock ];
                    else second_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];

                    //if necessary, prepare and save the full revocation transactions
                    if ( full_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx2_tree, target: tx2_target });
                        tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                    }

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    //save the transactions
                    hedgehog.state[ chan_id ].latest_force_close_txs = [
                        tapscript.Tx.encode( tx0 ).hex,
                        tapscript.Tx.encode( tx1 ).hex,
                    ];
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) {
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                            new_first_from_htlc_tx.vin[ 0 ].witness = [ alices_conditional_first_htlc_sig, bobs_conditional_first_htlc_sig, first_htlc_script, cblock ];
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                            new_second_from_htlc_tx.vin[ 0 ].witness = [ alices_conditional_second_htlc_sig, bobs_conditional_second_htlc_sig, second_htlc_script, cblock ];
                        } else {
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                            new_first_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_first_htlc_sig, alices_conditional_first_htlc_sig, first_htlc_script, cblock ];
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                            new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];
                        }
                        hedgehog.state[ chan_id ].txids_to_watch_for[ prev_txid ] = {
                            conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                            conditional_second_htlc_tx: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        }
                    }
                    if ( full_revocation_is_necessary ) hedgehog.state[ chan_id ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Bob can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Alice's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = false;

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "alice",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage: null,
                        htlc_hash,
                        force_close_tx: tapscript.Tx.encode( tx0 ).hex,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        from_force_close_to_htlc: tapscript.Tx.encode( tx1 ).hex,
                        when_to_fund_htlc: 1996, //shorter than normal so that 4032 blocks is never exceeded
                        unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( first_from_htlc_tx ).hex,
                        restore_current_state_after_force_close: tapscript.Tx.encode( second_from_htlc_tx ).hex,
                        when_to_restore_current_state: 2026, //longer than any lightning invoice locktime
                        txid_to_watch_for: prev_txid,
                        replacement_tx1_if_txid_to_watch_for_is_seen: tapscript.Tx.encode( new_tx1 ).hex,
                        //remember to decode the following tx, then make the preimage the item in
                        //the witness stack closest to the script, then reencode it, then broadcast it
                        conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_first_from_htlc_tx ).hex,
                        restore_current_state_after_replacement_tx1: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        channels_with_pending_outgoing_htlcs_linked_to_this_one: {},
                        time_when_preimage_was_received: null,
                        time_to_wait_after_preimage_is_received: 2016,
                    }

                    //test the following scenarios:

                    // console.log( `first test tx0 (bob) tx1 (bob) second_from_htlc_tx (bob) [tested]` );
                    // console.log( `next test prev_tx0 (alice) replacement_tx1 (bob) new_second_from_htlc_tx (bob) [tested]` );
                    // console.log( `next test prev_tx0 (alice) replacement_tx1 (bob) new_second_from_htlc_tx (alice) [tested by proxy -- I checked that her copy of new_second_from_htlc_tx is identical to bob's, so it will necessarily work too if he broadcasts replacement_tx1]` );
                    // console.log( `next test tx0 (bob) tx1 (bob) first_from_htlc_tx (bob) [tested]` );
                    // console.log( `next test prev_tx0 (alice) replacement_tx1 (bob) new_first_from_htlc_tx (bob) [tested]` );

                    //note that I was gonna have Bob broadcast *his* prev_tx0 and then
                    //have *Alice* broadcast *her* replacement_tx1 but that won't
                    //result in the htlc getting created -- it will just mean they
                    //go to the state *before* the htlc was created, in which Alice
                    //had more money coming to her

                    //TODO: set up a listener to get the preimage from somewhere
                    //or restore the old state after too much time goes by without resolution

                    //i am bob

                    return invoice_to_pay;
                },
                bobSendsHtlc: async ( chan_id, amnt, htlc_hash = null, invoice = null, alices_nostr_pubkey, l2id ) => {
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and you want to make an htlc worth less than that, i.e. only ${amnt} sats, so it cannot be done -- the software refuses and your only recourse is to find or make a modified version that allows dust htlcs` );
                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot send money while you have one...clear it before proceeding` );
                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;
                    if ( am_alice ) return;

                    var recipient = alices_nostr_pubkey;
                    var nostr_privkey = l2generator.state.l2s[ l2id ].l2_privkey;
                    var nwc_string = l2generator.state.l2s[ l2id ].nwc_string;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var secret = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "get_revocation_data",
                        msg: {
                            secret,
                            chan_id,
                            amnt,
                            invoice,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_alice = await getNote( secret );
                    sessionStorage.removeItem( secret );
                    var { alices_revocation_hash, secret_for_responding_to_alice } = JSON.parse( preparsed_info_from_alice );
                    // console.log( JSON.stringify({ chan_id, amnt }) );
                    // var alices_revocation_data = JSON.parse( prompt( 'send the data in your console to alice and enter her reply here -- she should run hedgehog.aliceReceivesHTLC()' ) );
                    // var alices_revocation_hash = alices_revocation_data[ "alices_revocation_hash" ];

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_send;
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                    }

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Bob but I sent him 5k,
                    //current_balances would say he has 5k. If I am now
                    //sending him 1k, amnt should be 6k, which is 
                    //( current_balances[ 1 ] - prev_balance[ 1 ] ) + amnt
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                        else amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                    }

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create and sign the timeout tx in case your counterparty takes
                    //too long to force close or disappears during a force closure
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    //tx0 sends all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    if ( am_alice ) var my_address = alices_address;
                    else var my_address = bobs_address;
                    var timeout_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 10 to 4032
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                    });
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var timeout_tx_script = latest_scripts[ 2 ];
                    var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                    var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: timeout_tx_tree, target: timeout_tx_target });
                    timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                    hedgehog.state[ chan_id ].txids_to_watch_for[ tx0_id ] = {
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                    }

                    //create the htlc
                    if ( !htlc_hash ) {
                        var htlc_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                        htlc_hash = await hedgehog.sha256( hedgehog.hexToBytes( htlc_preimage ) );
                    } else {
                        var htlc_preimage = null;
                    }
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: there's no sequence number because this is expected to be used
                        //when Alice is receiving a lightning payment, and the htlc will have
                        //a timelock of 20 blocks, 20 because every hop on an LN path increases
                        //the timelock and most wallets have a max timelock of only 2016 blocks
                        //-- but, to ensure Alice isn't screwed if she goes offline for 20
                        //blocks, we'll make it so that, after the 20 blocks expire, Bob can
                        //only sweep the funds into a revocable address that *does* have a
                        //2016 block timelock before he can sweep them from *there* -- and then,
                        //when updating the state, Bob will revoke his ability to withdraw from
                        //the revocable address
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create an address that Alice can revoke later -- I will reuse
                    //makeHTLC for this because she can revoke this one by revealing
                    //its preimage after signing a tx that lets Bob sweep it if he
                    //learns the preimage
                    var alices_revocation_scripts = hedgehog.makeHTLC( chan_id, alices_revocation_hash );
                    var alices_revocation_address = hedgehog.makeAddress( alices_revocation_scripts );

                    //create first_from_htlc_tx to disperse the funds from the htlc to Alice's
                    //revocation_address if Alice discloses her knowledge of the payment preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                            hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                        ],
                    });
                    var first_from_htlc_txid = tapscript.Tx.util.getTxid( first_from_htlc_tx );

                    //note that this revocation path requires Alice to disclose alices_revocation_preimage
                    //which means it uses the first path in alices_revocation_scripts
                    //she should only do this once the new state has been created
                    //if Alice revokes this state the following tx lets Bob sweep the funds
                    var from_revo_tx_1 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                        ],
                    });

                    //this one actually disperses the funds to Alice but only after a 20 block timelock
                    //it also uses the second path in alices_revocation_scripts
                    var from_revo_tx_2 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                        vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                    });

                    //create an address that Bob can revoke later -- I will reuse
                    //makeHTLC for this because he can revoke this one by revealing
                    //its preimage after signing a tx that lets Alice sweep it if
                    //she learns the preimage
                    var revocation_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    var revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_preimage ) );
                    var revocation_scripts = hedgehog.makeHTLC( chan_id, revocation_hash );
                    var revocation_address = hedgehog.makeAddress( revocation_scripts );

                    //create second_from_htlc_tx to move the funds into the revocation addy with a 20 block
                    //timelock if Alice does not disclose her knowledge of the preimage in a timely manner
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 20
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                    });
                    var htlc_2_txid = tapscript.Tx.util.getTxid( second_from_htlc_tx );

                    //create restore_from_revo_tx to disperse the funds from the revocation address to
                    //restore the current state if Bob did not revoke this address (for use when Alice
                    //won't disclose the preimage in the "happy path" so he forces her to do so or go
                    //back to the prior state, or, if he tries to do this just because he thinks she will
                    //be offline for 20 blocks, she gets 2016 blocks to show he revoked this path and
                    //penalize him)
                    //TODO: ensure Alice cannot put the money in the revocation address after Bob revokes
                    //it -- note that I thought for a second Alice could broadcast the *prior* state and
                    //thus force Bob to "update" the state to the one where the money is in the htlc, from
                    //which he is screwed because he can only move it from there to the state where Alice
                    //gets the new state as of this state update, or into the revocation address; but that
                    //is not true for two reasons: first, Alice will revoke that state shortly, so she
                    //cannot do that; and even if she didn't, Alice can only force closes into the state
                    //when she last sent money, in which case she loses the money she gains through this
                    //transaction -- so Bob can just let her lose that money.
                    //And I don't think Alice has any other opportunity to put the money in the revocation
                    //address after Bob revokes it -- he will only revoke it after they've created the
                    //new state and Alice has fully revoked this one, so if she tries to get it into the
                    //revocation address later, she will be screwed
                    var amnt_for_alice = balances[ 0 ];
                    var amnt_for_bob = balances[ 1 ] - 500 - 500 - 500 - 500;
                    var restore_from_revo_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //create bob_tried_to_cheat_tx that lets Alice sweep the funds if
                    //Bob tries to restore the current state after revoking it
                    var bob_tried_to_cheat_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                    });

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires,
                    //and sign bob_tried_to_cheat_tx with the path that requires
                    //Bob to reveal his preimage for Alice to use it (i.e. the first
                    //path)
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var alices_first_revo_script = alices_revocation_scripts[ 0 ];
                    var alices_first_revo_target = tapscript.Tap.encodeScript( alices_first_revo_script );
                    var alices_second_revo_script = alices_revocation_scripts[ 1 ];
                    var alices_second_revo_target = tapscript.Tap.encodeScript( alices_second_revo_script );
                    var alices_revo_tree = alices_revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_revo_script = revocation_scripts[ 0 ];
                    var first_revo_target = tapscript.Tap.encodeScript( first_revo_script );
                    var revo_tree = revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_revo_script = revocation_scripts[ 1 ];
                    var second_revo_target = tapscript.Tap.encodeScript( second_revo_script );
                    var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    //sig_3 is for tx1 and it has a relative timelock of 1996 blocks
                    //because tx1's only input (see above) has sequence number 1996
                    var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    //bobs_first_htlc_sig is for first_from_htlc_tx which lets Alice create the latest
                    //state if she discloses the preimage
                    var bobs_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var bobs_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;

                    //bobs_second_htlc_sig is for second_from_htlc_tx which restores the current state
                    //if Alice doesn't disclose the preimage in time -- or lets Alice sweep all of Bob's
                    //funds if he revokes this state and then puts the money in this state anyway
                    var bobs_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    //bobs_restoration_sig is for restore_from_revo_tx which disperses the funds from the
                    //revocation address to restore the current state if Bob did not revoke this address
                    //(for use when Alice won't disclose the preimage in the "happy path" so he forces her
                    //to do so or go back to the prior state, or, if he tries to do this just because he
                    //thinks she will be offline for 20 blocks, she gets 2016 blocks to show he revoked
                    //this path and penalize him)
                    var bobs_restoration_sig = tapscript.Signer.taproot.sign( privkey, restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    //bobs_cheater_sig is for bob_tried_to_cheat_tx which lets Alice sweep the funds if
                    //Bob tries to restore the current state after revoking it
                    var bobs_cheater_sig = tapscript.Signer.taproot.sign( privkey, bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;

                    //If necessary, create a revocation sig that conditionally revokes
                    //the prior state
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                                hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                            ],
                        });
                        var new_first_from_htlc_txid = tapscript.Tx.util.getTxid( new_first_from_htlc_tx );
                        var new_from_revo_tx_1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                            ],
                        });
                        var new_from_revo_tx_2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                            vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                        });
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 20
                            vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                        });
                        var new_htlc_2_txid = tapscript.Tx.util.getTxid( new_second_from_htlc_tx );
                        var new_restore_from_revo_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2016
                            vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_bob_tried_to_cheat_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                        });

                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                        var bobs_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var bobs_conditional_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, new_from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        var bobs_conditional_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, new_from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        var bobs_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var bobs_conditional_restoration_sig = tapscript.Signer.taproot.sign( privkey, new_restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                        var bobs_conditional_cheater_sig = tapscript.Signer.taproot.sign( privkey, new_bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                    }

                    //If necessary, prepare to reveal whichever preimage fully revokes
                    //the state prior to the prior state (yes, doubly prior)
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chan_id ].alices_revocation_preimages[ hedgehog.state[ chan_id ].alices_revocation_preimages.length - 2 ];
                        else var full_revocation_preimage = hedgehog.state[ chan_id ].bobs_revocation_preimages[ hedgehog.state[ chan_id ].bobs_revocation_preimages.length - 2 ];
                    }

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                    } else {
                        hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = true;

                    //collect info to send to alice
                    //it is important that Alice not be able
                    //to force Bob to put money into the revocation
                    //address after he has revoked it
                    var info_for_alice = {
                        bobs_first_htlc_sig,
                        bobs_revo_tx_1_sig,
                        bobs_revo_tx_2_sig,
                        bobs_second_htlc_sig,
                        // I don't think Alice should know the
                        // restoration sig otherwise once the
                        // money moves into the revocation
                        // address after a new state update
                        // she can broadcast the restoration
                        // tx and restore an old state
                        //bobs_restoration_sig,
                        // I think it is fine for her to have
                        // bobs_second_htlc_sig because that
                        // one is timelocked for 20 blocks
                        // which should give Bob time to
                        // broadcast first_from_htlc_tx
                        // instead -- though this *also*
                        // restores the state created by
                        // this transaction, so I also
                        // ensure Alice can revoke that
                        // state so Bob can penalize her
                        // if she tries to broadcast this
                        // state later -- and this also
                        // means Bob must never have the
                        // sigs he needs to broadcast
                        // first_from_htlc_tx on his own
                        // -- but that's a contradiction
                        // -- I just said he needs to be
                        // able to broadcast that if
                        // Alice restores this state. Ok
                        // maybe he can only do that *if*
                        // her restoration tx reveals a
                        // piece of data he needs to do
                        // that. But duh, of course it
                        // does: Alice alone can restore
                        // this state once Bob has
                        // conditionally revoked it --
                        // he cannot do that on his own
                        // so I think all is well
                        bobs_cheater_sig,
                        htlc_hash,
                        revocation_hash,
                        hash,
                        amnt,
                        chan_id,
                        bobs_conditional_first_htlc_sig,
                        bobs_conditional_second_htlc_sig,
                        bobs_conditional_revo_tx_1_sig,
                        bobs_conditional_revo_tx_2_sig,
                        // removing the following one for
                        // the same lengthy reason I gave
                        // above
                        // bobs_conditional_restoration_sig,
                        bobs_conditional_cheater_sig,
                    }

                    var recipient = alices_nostr_pubkey;
                    var nostr_privkey = l2generator.state.l2s[ l2id ].l2_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var secret_2_for_responding_to_bob = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify({
                                data: info_for_alice,
                                secret_2_for_responding_to_bob,
                            }),
                            secret: secret_for_responding_to_alice,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_alice = await getNote( secret_2_for_responding_to_bob );
                    sessionStorage.removeItem( secret_2_for_responding_to_bob );

                    var { data, secret_2_for_responding_to_alice } = JSON.parse( preparsed_info_from_alice );

                    //don't send the rest of the data til alice cosigns first_from_htlc_tx and second_from_htlc_tx
                    //and the restoration_tx and the conditional versions thereof
                    // console.log( `send this info to alice:` );
                    // console.log( JSON.stringify( info_for_alice ) );
                    // var { alices_first_htlc_sig, alices_revo_tx_1_sig, alices_revo_tx_2_sig, alices_second_htlc_sig, alices_restoration_sig, alices_conditional_first_htlc_sig, alices_conditional_revo_tx_1_sig, alices_conditional_revo_tx_2_sig, alices_conditional_second_htlc_sig, alices_conditional_restoration_sig } = JSON.parse( prompt( `send the info in your console to alice and enter her reply` ) );
                    var { alices_first_htlc_sig, alices_revo_tx_1_sig, alices_revo_tx_2_sig, alices_second_htlc_sig, alices_restoration_sig, alices_conditional_first_htlc_sig, alices_conditional_revo_tx_1_sig, alices_conditional_revo_tx_2_sig, alices_conditional_second_htlc_sig, alices_conditional_restoration_sig } = data;

                    //validate the sigs
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var alices_first_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_first_htlc_sig, first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var revo_tx_1_sighash = tapscript.Signer.taproot.hash( from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var alices_revo_tx_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_revo_tx_1_sig, revo_tx_1_sighash, pubkey_to_validate_against );
                    var revo_tx_2_sighash = tapscript.Signer.taproot.hash( from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                    var alices_revo_tx_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_revo_tx_2_sig, revo_tx_2_sighash, pubkey_to_validate_against );

                    var second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var alices_second_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_second_htlc_sig, second_from_htlc_tx_sighash, pubkey_to_validate_against );

                    var restoration_tx_sighash = tapscript.Signer.taproot.hash( restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    var alices_restoration_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_restoration_sig, restoration_tx_sighash, pubkey_to_validate_against );
                    var new_restoration_tx_sighash = tapscript.Signer.taproot.hash( new_restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    var alices_conditional_restoration_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_restoration_sig, new_restoration_tx_sighash, pubkey_to_validate_against );

                    var new_first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var alices_conditional_htlc_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_first_htlc_sig, new_first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var new_second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var alices_conditional_htlc_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_second_htlc_sig, new_second_from_htlc_tx_sighash, pubkey_to_validate_against );
                    if ( !alices_first_htlc_sig_is_valid || !alices_second_htlc_sig_is_valid || !alices_conditional_htlc_1_sig_is_valid || !alices_conditional_htlc_2_sig_is_valid || !alices_restoration_sig_is_valid || !alices_conditional_restoration_sig_is_valid || !alices_revo_tx_1_sig_is_valid || !alices_revo_tx_2_sig_is_valid ) {
                        //restore previous state
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                        return;
                    }

                    //send alice the rest of the data

                    //Create an object to send all this data to the recipient
                    //but don't send her the htlc_preimage -- that's for Bob
                    //only
                    //I forgot that Bob will only know the preimage
                    //when he creates an invoice that pays Alice -- in every
                    //other case, Alice will know the preimage and Bob will
                    //be trying to learn it -- so I made a todo to figure out
                    //what to do about that. I thought about it and decided to
                    //make it so that Bob is by default the one who knows
                    //the preimage, and if someone wants this to work
                    //differently they can modify it
                    var object = {
                        sig_1,
                        sig_3,
                    }
                    if ( conditional_revocation_sig ) object[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;

                    var recipient = alices_nostr_pubkey;
                    var nostr_privkey = l2generator.state.l2s[ l2id ].l2_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify( object ),
                            secret: secret_2_for_responding_to_alice,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );

                    // console.log( `send this info to alice:` );
                    // console.log( JSON.stringify( object ) );
                    // alert( `send the info in your console to alice and then click ok` );

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    console.log( "prev_tx0:" );
                    console.log( prev_force_close_tx );

                    if ( htlc_preimage ) {
                        console.log( 'here is the preimage your counterparty needs, they should run hedgehog.settleIncomingHTLC() and enter it' );
                        console.log( JSON.stringify({chan_id, preimage: htlc_preimage}) );
                    }

                    //if I force close, Alice can broadcast new_tx1, which puts the money in the htlc,
                    //so I need to prepare new_first_from_htlc_tx (which gives Alice her money if this
                    //is the latest state or will soon let bob penalize her otherwise)
                    //I also need to prepare new_second_from_htlc_tx. It
                    //moves the money into the revocation address -- if Alice has revoked her state,
                    //I should not broadcast new_second_from_htlc_tx but rather new_first_from_htlc_tx
                    //and then penalize her; otherwise, I have two options: I should either broadcast
                    //new_first_from_htlc_tx if the sender paid me, and that results in Alice getting
                    //her money; or, if he did not, I should broadcast new_second_from_htlc_tx to
                    //restore the current state.
                    //consequently, after new_second_from_htlc_tx I need to prepare
                    //new_restore_from_revo_tx so that I can restore the current state. I also create
                    //"non" conditional versions of those so that if Alice force closes I can react
                    //properly.

                    //prepare to give Alice her money if this is the latest state
                    //or prepare to sweep it from her if this is not the latest state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                    new_first_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];

                    //actually give Alice her money if this is the latest state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                    new_from_revo_tx_1.vin[ 0 ].witness = [ bobs_conditional_revo_tx_1_sig, alices_conditional_revo_tx_1_sig, alices_first_revo_script, cblock ];

                    //sweep Alice's money if she tries to broadcast old state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                    new_from_revo_tx_2.vin[ 0 ].witness = [ bobs_conditional_revo_tx_2_sig, alices_conditional_revo_tx_2_sig, alices_second_revo_script, cblock ];

                    //prepare to restore the current state if the sender did not pay bob
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];

                    //actually restore the current state if the sender did not pay bob
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: revo_tree, target: second_revo_target });
                    new_restore_from_revo_tx.vin[ 0 ].witness = [ bobs_conditional_restoration_sig, alices_conditional_restoration_sig, second_revo_script, cblock ];

                    //the unconditional versions of all the above -- in case Alice force closes
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                    first_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                    from_revo_tx_1.vin[ 0 ].witness = [ bobs_revo_tx_1_sig, alices_revo_tx_1_sig, alices_first_revo_script, cblock ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                    from_revo_tx_2.vin[ 0 ].witness = [ bobs_revo_tx_2_sig, alices_revo_tx_2_sig, alices_second_revo_script, cblock ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    second_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: revo_tree, target: second_revo_target });
                    restore_from_revo_tx.vin[ 0 ].witness = [ bobs_restoration_sig, alices_restoration_sig, second_revo_script, cblock ];

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "bob",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage,
                        htlc_hash,
                        force_close_tx: prev_force_close_tx,
                        conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_first_from_htlc_tx ).hex,
                        conditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_from_revo_tx_1 ).hex,
                        conditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( new_from_revo_tx_2 ).hex,
                        conditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        conditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_restore_from_revo_tx ).hex,
                        unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( first_from_htlc_tx ).hex,
                        unconditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( from_revo_tx_1 ).hex,
                        unconditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( from_revo_tx_2 ).hex,
                        unconditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( second_from_htlc_tx ).hex,
                        unconditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( restore_from_revo_tx ).hex,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        when_to_restore_current_state: 20, //short because I don't want to support hodl invoices yet
                        //note that the timeout_tx is there in case your counterparty disappears after you
                        //force close -- Bob can EITHER sweep the money using the timeout tx after 4032
                        //blocks, if Alice disappears entirely, or -- if he force closes and then Alice at
                        //least sticks around long enough to move the money into the htlc, but then doesn't
                        //disclose the preimage within 20 blocks, Bob can restore the existing state using
                        //the new_second_from_htlc_tx and the restoration_tx
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                        time_til_timeout_tx: 4032,
                    }

                    console.log( 73, hedgehog.state[ chan_id ].balances_before_most_recent_send );
                    console.log( 74, hedgehog.state[ chan_id ].balances );

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Alice can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Bob's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    hedgehog.state[ chan_id ].balances_before_most_recent_receive = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    console.log( 'htlc sent!' );
                    console.log( 75, hedgehog.state[ chan_id ].balances );

                    if ( invoice ) {
                        //start listening for the invoice to be paid
                        var loop = async () => {
                            //TODO: if the invoice is not paid quickly and Alice won't cancel it, force close
                            console.log( 'checking invoice status' );
                            var delay_tolerance = 10;
                            var nwc_info = nwcjs.processNWCstring( nwc_string );
                            var invoice_status_info = await nwcjs.checkInvoice( nwc_info, invoice, delay_tolerance );
                            if ( invoice_status_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "result_type" in invoice_status_info && invoice_status_info[ "result_type" ] !== "lookup_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "error" in invoice_status_info && invoice_status_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( invoice_status_info[ "error" ] )} -- please try again` );
                            if ( invoice_status_info.result.settled_at ) {
                                var sigs_and_stuff = await hedgehog.checkIfOutgoingHTLCIsSettled( chan_id, invoice_status_info.result.preimage );
                                var msg = JSON.stringify({
                                    type: "payment_complete",
                                    msg: {
                                        chan_id,
                                        preimage: invoice_status_info.result.preimage,
                                        sigs_and_stuff,
                                    }
                                });
                                var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                                var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                                super_nostr.sendEvent( event, socket );
                                return;
                            }
                            await super_nostr.waitSomeSeconds( loop_delay );
                            return loop();
                            //return here
                            //TODO: resolve the htlc
                        }
                        await loop();
                    }

                    //TODO: set up some kind of listener to do the rest, e.g. getting a preimage
                    //from the recipient (if they have it) or from the nwc funding source and
                    //using it to close out the posititon with the sender (and the recipient, if
                    //they don't already have the preimage) and then revoking the
                    //revocation_address so that it can't be used
                },
                aliceReceivesHTLC: async data => {
                    //TODO: ensure Alice rejects the offer if it contains an htlc_hash she doesn't expect
                    //-- namely, one from a lightning invoice Bob offered to pay her with -- and she
                    //should also reject it if the amount in the invoice she is expecting does not match
                    //the amount offered to her by this htlc -- oh yeah and I just figured out that she
                    //should also *independently* have info from the sender about how much they want to
                    //pay her, that way Bob can't send her an invoice for *less* than that and keep the
                    //difference -- then again, she is the one who hit receive, and then typed in an
                    //amount, so she *should* know how much money to expect
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];
                    var secret_for_responding_to_bob = null;
                    var invoice = null;
                    if ( data[ "secret" ] ) secret_for_responding_to_bob = data[ "secret" ];
                    if ( data[ "invoice" ] ) invoice = data[ "invoice" ];

                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot receive money in this channel while you have one...clear it before proceeding` );

                    var amnt = data[ "amnt" ];
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and this htlc is worth only ${amnt} sats so we reject it` );
                    if ( amnt > hedgehog.state[ chan_id ].balances[ 1 ] ) return alert( `bob tried to send you more money than he has so we reject it` );

                    //give Bob a revocation hash
                    var alices_revocation_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    var alices_revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( alices_revocation_preimage ) );
                    if ( secret_for_responding_to_bob ) {
                        var recipient = $_GET[ "layer2" ];
                        var depositor_id = Object.keys( l2generator.state.depositor_data )[ 0 ];
                        var nostr_privkey = l2generator.state.depositor_data[ depositor_id ].nostr_privkey;
                        var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                        var socket = super_nostr.sockets[ socket_id ].socket;
                        var secret_for_responding_to_alice = super_nostr.getPrivkey();
                        var msg = JSON.stringify({
                            type: "secret_you_need",
                            msg: {
                                thing_needed: JSON.stringify({
                                    alices_revocation_hash,
                                    secret_for_responding_to_alice,
                                }),
                                secret: secret_for_responding_to_bob,
                            }
                        });
                        var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                        var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                        super_nostr.sendEvent( event, socket );
                        var preparsed_info_from_bob = await getNote( secret_for_responding_to_alice );
                        sessionStorage.removeItem( secret_for_responding_to_alice );
                        var data = JSON.parse( preparsed_info_from_bob )[ "data" ];
                        var secret_2_for_responding_to_bob = JSON.parse( preparsed_info_from_bob )[ "secret_2_for_responding_to_bob" ];
                    } else {
                        console.log( JSON.stringify({alices_revocation_hash}) );
                        alert( `send your counterparty the data in your console and then click ok` );
                        await hedgehog.waitSomeSeconds( 1 );
                        var data = JSON.parse( prompt( `enter the data from your counterparty here` ) );
                    }
                    var new_amnt = data[ "amnt" ];
                    if ( new_amnt !== amnt ) return alert( `aborting because your counterparty tried to scam you on the amount` );
                    var new_chan_id = data[ "chan_id" ];
                    if ( new_chan_id !== chan_id ) return alert( `aborting because your counterparty tried to scam you with an invalid chan_id` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( amnt <= hedgehog.state[ chan_id ].balances[ 1 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 1 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_receive;
                        if ( !hedgehog.state[ chan_id ].balances.length ) {
                            var sum = current_balances[ 0 ] + current_balances[ 1 ];
                            if ( am_alice ) hedgehog.state[ chan_id ].balances = [ 0, sum ];
                            else hedgehog.state[ chan_id ].balances = [ sum, 0 ];
                        }
                        if ( am_alice ) {
                            var old_rev_hashes = hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].alice_can_revoke.pop();
                        } else {
                            var old_rev_hashes = hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].bob_can_revoke.pop();
                        }
                    }

                    //push your counterparty's payment hash to their hashes object
                    if ( am_alice ) hedgehog.state[ chan_id ].bobs_revocation_hashes.push( data[ "hash" ] );
                    else hedgehog.state[ chan_id ].alices_revocation_hashes.push( data[ "hash" ] );

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create tx0 to send all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                    //create the htlc
                    var htlc_hash = data[ "htlc_hash" ];
                    if ( invoice ) {
                        var invoice_hash = hedgehog.getInvoicePmthash( invoice );
                        if ( htlc_hash !== invoice_hash ) return alert( `bob tried to scam you by giving you an htlc unrelated to the invoice` );
                        var invoice_amt = hedgehog.getInvoiceAmount( invoice );
                        //TODO: consider whether to allow the invoice to pay you less
                        //as a kind of fee for Bob
                        if ( invoice_amt !== data[ "amnt" ] ) return alert( `bob tried to scam you by giving you an invoice with the wrong amount` );
                    }
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: there's no sequence number because this is expected to be used
                        //when Alice is receiving a lightning payment, and the htlc will have
                        //a timelock of 20 blocks, 20 because every hop on an LN path increases
                        //the timelock and most wallets have a max timelock of only 2016 blocks
                        //-- but, to ensure Alice isn't screwed if she goes offline for 20
                        //blocks, we'll make it so that, after the 20 blocks expire, Bob can
                        //only sweep the funds into a revocable address that *does* have a
                        //2016 block timelock before he can sweep them from *there* -- and then,
                        //when updating the state, Bob will revoke his ability to withdraw from
                        //the revocable address
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create an address that Alice can revoke later -- I will reuse
                    //makeHTLC for this because she can revoke this one by revealing
                    //its preimage after signing a tx that lets Bob sweep it if he
                    //learns the preimage
                    var alices_revocation_scripts = hedgehog.makeHTLC( chan_id, alices_revocation_hash );
                    var alices_revocation_address = hedgehog.makeAddress( alices_revocation_scripts );

                    //create first_from_htlc_tx to disperse the funds from the htlc to Alice's
                    //revocation_address if Alice discloses her knowledge of the payment preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                            hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                        ],
                    });
                    var first_from_htlc_txid = tapscript.Tx.util.getTxid( first_from_htlc_tx );

                    //note that this revocation path requires Alice to disclose alices_revocation_preimage
                    //which means it uses the first path in alices_revocation_scripts
                    //she should only do this once the new state has been created
                    //if Alice revokes this state the following tx lets Bob sweep the funds
                    var from_revo_tx_1 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                        ],
                    });

                    //this one actually disperses the funds to Alice but only after a 20 block timelock
                    //it also uses the second path in alices_revocation_scripts
                    var from_revo_tx_2 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                        vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                    });

                    //create an address that Bob can revoke later -- I will reuse
                    //makeHTLC for this because he can revoke this one by revealing
                    //its preimage after signing a tx that lets Alice sweep it if
                    //she learns the preimage
                    var revocation_hash = data[ "revocation_hash" ];
                    var revocation_scripts = hedgehog.makeHTLC( chan_id, revocation_hash );
                    var revocation_address = hedgehog.makeAddress( revocation_scripts );

                    //create second_from_htlc_tx to move the funds into the revocation addy after a 20 block
                    //timelock if Alice does not disclose her knowledge of the preimage in a timely manner
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 20
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                    });
                    var htlc_2_txid = tapscript.Tx.util.getTxid( second_from_htlc_tx );

                    //create restore_from_revo_tx to disperse the funds from the revocation address to
                    //restore the current state if Bob did not revoke this address (for use when Alice
                    //won't disclose the preimage in the "happy path" so he forces her to do so or go
                    //back to the prior state, or, if he tries to do this just because he thinks she will
                    //be offline for 20 blocks, she gets 2016 blocks to show he revoked this path and
                    //penalize him)
                    //TODO: ensure Alice cannot put the money in the revocation address after Bob revokes
                    //it -- note that I thought for a second Alice could broadcast the *prior* state and
                    //thus force Bob to "update" the state to the one where the money is in the htlc, from
                    //which he is screwed because he can only move it from there to the state where Alice
                    //gets the new state as of this state update, or into the revocation address; but that
                    //is not true for two reasons: first, Alice will revoke that state shortly, so she
                    //cannot do that; and even if she didn't, Alice can only force closes into the state
                    //when she last sent money, in which case she loses the money she gains through this
                    //transaction -- so Bob can just let her lose that money.
                    //And I don't think Alice has any other opportunity to put the money in the revocation
                    //address after Bob revokes it -- he will only revoke it after they've created the
                    //new state and Alice has fully revoked this one, so if she tries to get it into the
                    //revocation address later, she will be screwed
                    var amnt_for_alice = balances[ 0 ];
                    var amnt_for_bob = balances[ 1 ] - 500 - 500 - 500 - 500;
                    var restore_from_revo_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //create bob_tried_to_cheat_tx that lets Alice sweep the funds if
                    //Bob tries to restore the current state after revoking it
                    var bob_tried_to_cheat_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                    });

                    //validate the signatures by which the sender creates the new state
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var alices_first_revo_script = alices_revocation_scripts[ 0 ];
                    var alices_first_revo_target = tapscript.Tap.encodeScript( alices_first_revo_script );
                    var alices_second_revo_script = alices_revocation_scripts[ 1 ];
                    var alices_second_revo_target = tapscript.Tap.encodeScript( alices_second_revo_script );
                    var alices_revo_tree = alices_revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_revo_script = revocation_scripts[ 0 ];
                    var first_revo_target = tapscript.Tap.encodeScript( first_revo_script );
                    var revo_tree = revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_revo_script = revocation_scripts[ 1 ];
                    var second_revo_target = tapscript.Tap.encodeScript( second_revo_script );
                    var bobs_first_htlc_sig = data[ "bobs_first_htlc_sig" ];
                    var sighash_first_htlc = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var is_valid_first_htlc = await nobleSecp256k1.schnorr.verify( bobs_first_htlc_sig, sighash_first_htlc, pubkey_to_validate_against );
                    var bobs_revo_tx_1_sig = data[ "bobs_revo_tx_1_sig" ];
                    var revo_tx_1_sighash = tapscript.Signer.taproot.hash( from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var revo_tx_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_revo_tx_1_sig, revo_tx_1_sighash, pubkey_to_validate_against );
                    var bobs_revo_tx_2_sig = data[ "bobs_revo_tx_2_sig" ];
                    var revo_tx_2_sighash = tapscript.Signer.taproot.hash( from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                    var revo_tx_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_revo_tx_2_sig, revo_tx_2_sighash, pubkey_to_validate_against );
                    var bobs_second_htlc_sig = data[ "bobs_second_htlc_sig" ];
                    var sighash_second_htlc = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var is_valid_second_htlc = await nobleSecp256k1.schnorr.verify( bobs_second_htlc_sig, sighash_second_htlc, pubkey_to_validate_against );
                    // var bobs_restoration_sig = data[ "bobs_restoration_sig" ];
                    // var sighash_restoration = tapscript.Signer.taproot.hash( restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    // var is_valid_restoration = await nobleSecp256k1.schnorr.verify( bobs_restoration_sig, sighash_restoration, pubkey_to_validate_against );
                    var bobs_cheater_sig = data[ "bobs_cheater_sig" ];
                    var sighash_cheater = tapscript.Signer.taproot.hash( bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                    var is_valid_cheater = await nobleSecp256k1.schnorr.verify( bobs_cheater_sig, sighash_cheater, pubkey_to_validate_against );

                    // if ( !is_valid_first_htlc || !is_valid_second_htlc || !is_valid_restoration || !is_valid_cheater ) {
                    if ( !is_valid_first_htlc || !is_valid_second_htlc || !is_valid_cheater ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    var alices_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var alices_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var alices_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                    var alices_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var alices_first_revo_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var alices_second_revo_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                    var alices_restoration_sig = tapscript.Signer.taproot.sign( privkey, restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    var alices_cheater_sig = tapscript.Signer.taproot.sign( privkey, bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;

                    //If necessary, validate the signature by which the sender
                    //conditionally revokes the old state and cosign the revocation
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                                hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                            ],
                        });
                        var new_first_from_htlc_txid = tapscript.Tx.util.getTxid( new_first_from_htlc_tx );
                        var new_from_revo_tx_1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                            ],
                        });
                        var new_from_revo_tx_2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                            vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                        })
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 20
                            vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                        });
                        var new_htlc_2_txid = tapscript.Tx.util.getTxid( new_second_from_htlc_tx );
                        var new_restore_from_revo_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2016
                            vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_bob_tried_to_cheat_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                        });
                        var bobs_conditional_first_htlc_sig = data[ "bobs_conditional_first_htlc_sig" ];
                        var conditional_htlc_1_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var conditional_htlc_1_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_first_htlc_sig, conditional_htlc_1_sighash, pubkey_to_validate_against );
                        var alices_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var bobs_conditional_revo_tx_1_sig = data[ "bobs_conditional_revo_tx_1_sig" ];
                        var conditional_revo_tx_1_sighash = tapscript.Signer.taproot.hash( new_from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        var conditional_revo_tx_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_revo_tx_1_sig, conditional_revo_tx_1_sighash, pubkey_to_validate_against );
                        var alices_conditional_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        var bobs_conditional_revo_tx_2_sig = data[ "bobs_conditional_revo_tx_2_sig" ];
                        var conditional_revo_tx_2_sighash = tapscript.Signer.taproot.hash( new_from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        var conditional_revo_tx_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_revo_tx_2_sig, conditional_revo_tx_2_sighash, pubkey_to_validate_against );
                        var alices_conditional_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        var bobs_conditional_second_htlc_sig = data[ "bobs_conditional_second_htlc_sig" ];
                        var conditional_htlc_2_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var conditional_htlc_2_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_second_htlc_sig, conditional_htlc_2_sighash, pubkey_to_validate_against );
                        var alices_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var bobs_conditional_cheater_sig = data[ "bobs_conditional_cheater_sig" ];
                        var conditional_cheater_sighash = tapscript.Signer.taproot.hash( new_bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                        var conditional_cheater_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_cheater_sig, conditional_cheater_sighash, pubkey_to_validate_against );
                        var alices_conditional_restoration_sig = tapscript.Signer.taproot.sign( privkey, new_restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                        var alices_conditional_cheater_sig = tapscript.Signer.taproot.sign( privkey, new_bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;

                        if ( !conditional_htlc_1_is_valid || !conditional_htlc_2_is_valid || !conditional_cheater_is_valid || !conditional_revo_tx_1_sig_is_valid || !conditional_revo_tx_2_sig_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                    }

                    var data_for_bob = {
                        alices_first_htlc_sig,
                        alices_second_htlc_sig,
                        alices_restoration_sig,
                        alices_revo_tx_1_sig,
                        alices_revo_tx_2_sig,
                    }
                    if ( alices_conditional_first_htlc_sig ) data_for_bob[ "alices_conditional_first_htlc_sig" ] = alices_conditional_first_htlc_sig;
                    if ( alices_conditional_second_htlc_sig ) data_for_bob[ "alices_conditional_second_htlc_sig" ] = alices_conditional_second_htlc_sig;
                    if ( alices_conditional_restoration_sig ) data_for_bob[ "alices_conditional_restoration_sig" ] = alices_conditional_restoration_sig;
                    if ( alices_conditional_revo_tx_1_sig ) data_for_bob[ "alices_conditional_revo_tx_1_sig" ] = alices_conditional_revo_tx_1_sig;
                    if ( alices_conditional_revo_tx_2_sig ) data_for_bob[ "alices_conditional_revo_tx_2_sig" ] = alices_conditional_revo_tx_2_sig;

                    if ( secret_for_responding_to_bob ) {
                        var recipient = $_GET[ "layer2" ];
                        var depositor_id = Object.keys( l2generator.state.depositor_data )[ 0 ];
                        var nostr_privkey = l2generator.state.depositor_data[ depositor_id ].nostr_privkey;
                        var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                        var socket = super_nostr.sockets[ socket_id ].socket;
                        var secret_2_for_responding_to_alice = super_nostr.getPrivkey();
                        var msg = JSON.stringify({
                            type: "secret_you_need",
                            msg: {
                                thing_needed: JSON.stringify({
                                    data: data_for_bob,
                                    secret_2_for_responding_to_alice,
                                }),
                                secret: secret_2_for_responding_to_bob,
                            }
                        });
                        var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                        var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                        super_nostr.sendEvent( event, socket );
                        var preparsed_info_from_bob = await getNote( secret_2_for_responding_to_alice );
                        sessionStorage.removeItem( secret_2_for_responding_to_alice );
                        var data = JSON.parse( preparsed_info_from_bob );
                    } else {
                        console.log( `send this data to bob:` );
                        console.log( JSON.stringify( data_for_bob ) );
                        alert( `send the data in your console to bob and then click ok` );
                        await hedgehog.waitSomeSeconds( 1 );
                        var data = JSON.parse( prompt( `enter bob's reply here` ) );
                    }

                    //validate the rest of the data sent by your counterparty

                    var sig_1 = data[ "sig_1" ];
                    var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                    var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                    var sig_3 = data[ "sig_3" ];
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                    var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );

                    if ( !is_valid_1 || !is_valid_3 ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    if ( conditional_revocation_is_necessary ) {
                        if ( !( "conditional_revocation_sig" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = data[ "conditional_revocation_sig" ];
                        var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                        var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                        if ( !conditional_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                        var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, validate the preimage by which the sender
                    //fully revokes the old state and sign the revocation
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( !( "full_revocation_preimage" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 1 ];
                        var preimage = data[ "full_revocation_preimage" ];
                        var expected_hash = prev_scripts[ 1 ][ 1 ];
                        var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                        if ( hash_provided != expected_hash ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                        }
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var tx2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        var tx2_script = prev_scripts[ 1 ];
                        var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                        var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                    }

                    //prepare and save the force closure initiation transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx0_tree, target: tx0_target });
                    //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                    //the first sig must be sig_2 -- which means it must be in the "last"
                    //position (i.e. the sig created by Alice must appear right before her pubkey)
                    if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                    else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                    //prepare the force closure finalization transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx1_tree, target: tx1_target });
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                    else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx1_tree, target: new_tx1_target });
                        if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                        else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                    }

                    //prepare the transaction that uses the htlc to prepare to create the new state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                    first_from_htlc_tx.vin[ 0 ].witness = [ bobs_first_htlc_sig, alices_first_htlc_sig, first_htlc_script, cblock ];

                    //actually give Alice her money if this is the latest state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                    from_revo_tx_1.vin[ 0 ].witness = [ bobs_revo_tx_1_sig, alices_revo_tx_1_sig, alices_first_revo_script, cblock ];

                    //let Bob sweep Alice's money if she tries to broadcast old state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                    from_revo_tx_2.vin[ 0 ].witness = [ bobs_revo_tx_2_sig, alices_revo_tx_2_sig, alices_second_revo_script, cblock ];

                    //prepare the transaction that uses the htlc to restore the current state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    second_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];

                    //if necessary, prepare and save the full revocation transactions
                    if ( full_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx2_tree, target: tx2_target });
                        tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                    }

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    //save the transactions
                    hedgehog.state[ chan_id ].latest_force_close_txs = [
                        tapscript.Tx.encode( tx0 ).hex,
                        tapscript.Tx.encode( tx1 ).hex,
                    ];
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                        new_first_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_first_htlc_sig, alices_conditional_first_htlc_sig, first_htlc_script, cblock ];
                        //in case Bob force closes, prepare and save the conditional transaction that uses the htlc to actually create the new state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                        new_from_revo_tx_1.vin[ 0 ].witness = [ bobs_conditional_revo_tx_1_sig, alices_conditional_revo_tx_1_sig, alices_first_revo_script, cblock ];
                        //let Bob conditionally sweep Alice's money if she tries to broadcast old state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                        new_from_revo_tx_2.vin[ 0 ].witness = [ bobs_conditional_revo_tx_2_sig, alices_conditional_revo_tx_2_sig, alices_second_revo_script, cblock ];
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                        new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];
                        hedgehog.state[ chan_id ].txids_to_watch_for[ prev_txid ] = {
                            conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                            conditional_second_htlc_tx: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        }
                    }
                    if ( full_revocation_is_necessary ) hedgehog.state[ chan_id ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Bob can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Alice's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = false;

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "bob",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage: null,
                        htlc_hash,
                        force_close_tx: tapscript.Tx.encode( tx0 ).hex,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        from_force_close_to_htlc: tapscript.Tx.encode( tx1 ).hex,
                        when_to_fund_htlc: 1996, //shorter than normal so that 4032 blocks is never exceeded
                        conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_first_from_htlc_tx ).hex,
                        conditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_from_revo_tx_1 ).hex,
                        conditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( new_from_revo_tx_2 ).hex,
                        conditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        conditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_restore_from_revo_tx ).hex,
                        unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( first_from_htlc_tx ).hex,
                        unconditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( from_revo_tx_1 ).hex,
                        unconditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( from_revo_tx_2 ).hex,
                        unconditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( second_from_htlc_tx ).hex,
                        unconditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( restore_from_revo_tx ).hex,
                        when_to_restore_current_state: 2026, //longer than any lightning invoice locktime
                        txid_to_watch_for: prev_txid,
                        replacement_tx1_if_txid_to_watch_for_is_seen: tapscript.Tx.encode( new_tx1 ).hex,
                        //remember to decode the following tx, then make the preimage the item in
                        //the witness stack closest to the script, then reencode it, then broadcast it
                        channels_with_pending_outgoing_htlcs_linked_to_this_one: {},
                        time_when_preimage_was_received: null,
                        time_to_wait_after_preimage_is_received: 2016,
                    }

                    //test the following scenarios:

                    //alice force closes and restores the current state
                    console.log( `first test tx0 (alice) tx1 (alice) second_from_htlc_tx (alice)` );
                    //bob force closes and alice restores the current state
                    console.log( `next test prev_tx0 (bob) replacement_tx1 (alice) new_second_from_htlc_tx (alice)` );
                    //alice force closes and gives herself the money using a preimage obtained from bob
                    console.log( `next test tx0 (alice) tx1 (alice) first_from_htlc_tx (alice)` );
                    //bob force closes and alice gives herself the money using a preimage obtained from bob
                    console.log( `next test prev_tx0 (bob) replacement_tx1 (alice) new_first_from_htlc_tx (alice)` );

                    //TODO: also test other scenarios and consider eliminating txs that Alice doesn't need
                    //TODO: relatedly, I think Bob also has txs that he doesn't need -- and in both cases
                    //I think these unneeded txs allow them to put the money in states that they shouldn't
                    //be able to put them in, because they can steal them from those states in some scenarios
                    //e.g. Bob shouldn't be able to put Alice's money in a state she has revoked unless *she*
                    //broadcasts it after revoking it -- when *Bob* force closes he should not be able to do
                    //that

                    //TODO: set up a listener to get the preimage from somewhere
                    //or restore the old state after too much time goes by without resolution

                    //i am alice

                    if ( invoice ) return invoice;
                    return true;
                },
                closeChannel: chan_id => {
                    console.log( "Broadcast this transaction to initiate a force closure:" );
                    console.log( hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ] );
                    //TODO: change the 5 to a 2016
                    console.log( "Wait 5 blocks and broadcast this transaction to finalize the force closure:" );
                    console.log( hedgehog.state[ chan_id ].latest_force_close_txs[ 1 ] );
                    return [ hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ], hedgehog.state[ chan_id ].latest_force_close_txs[ 1 ] ];
                },
                checkIfIncomingHTLCIsSettled: async data => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //check if this channel has a pending htlc
                    var pending_htlc = hedgehog.state[ chan_id ].pending_htlc;
                    if ( !Object.keys( pending_htlc ).length ) return;

                    if ( am_alice && pending_htlc.from === "alice" ) return;
                    if ( !am_alice && pending_htlc.from !== "alice" ) return;

                    if ( !hedgehog.state[ chan_id ].pending_htlc.htlc_preimage ) {
                        var data_for_counterparty = {
                            msg: "unsettled",
                            htlc_hash: hedgehog.state[ chan_id ].pending_htlc.htlc_hash,
                        }
                        console.log( JSON.stringify( data_for_counterparty ) );
                        return alert( 'send the data in your console to your counterparty' );
                    }
                    var data_for_counterparty = {
                        status: "settled",
                        htlc_preimage: hedgehog.state[ chan_id ].pending_htlc.htlc_preimage,
                    }
                    console.log( JSON.stringify( data_for_counterparty ) );
                    alert( 'send the data in your console to your counterparty and then click ok' );
                    await hedgehog.waitSomeSeconds( 1 );
                    var data = JSON.parse( prompt( `enter your counterparty's reply here` ) );
                    var amnt_expected = hedgehog.state[ chan_id ].balances[ 1 ] + hedgehog.state[ chan_id ].pending_htlc.amnt;
                    if ( data[ "amnt" ] !== amnt_expected ) return alert( `something strange happened, your counterparty tried to send ${data[ "amnt" ]} and you expected ${amnt_expected} -- force close and settle with the preimage` );
                    var skip_pending_check = true;
                    hedgehog.receive( data, skip_pending_check );
                    hedgehog.state[ chan_id ].pending_htlc = {}
                },
                checkIfOutgoingHTLCIsSettled: async ( chan_id, preimage ) => {
                    if ( !chan_id ) chan_id = prompt( `enter chan_id` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    if ( !preimage ) {
                        console.log( JSON.stringify( {
                            chan_id,
                        } ) );
                        alert( 'send the data in your console to your counterparty and then click ok -- btw they should run hedgehog.checkIfIncomingHTLCIsSettled()' );
                        await hedgehog.waitSomeSeconds( 1 );
                        var data = JSON.parse( prompt( `enter bob's reply here` ) );
                        if ( data[ "status" ] === "unsettled" ) return alert( 'not settled yet' );
                        preimage = data[ "htlc_preimage" ];
                    }
                    var pending_htlc = hedgehog.state[ chan_id ].pending_htlc;
                    var expected_hash = pending_htlc.htlc_hash;
                    //ensure hashing the preimage won't crash the pc
                    var is_hex = hedgehog.isValidHex( preimage );
                    var is_right_size = preimage.length === 64;
                    if ( is_hex && is_right_size ) {
                        var actual_hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                        //TODO: uncomment the line below
                        // if ( expected_hash !== actual_hash ) return;
                    }
                    if ( am_alice ) var amnt_to_send = hedgehog.state[ chan_id ].balances_before_most_recent_send[ 1 ] + pending_htlc[ "amnt" ];
                    else var amnt_to_send = pending_htlc[ "amnt" ];
                    var skip_pending_check = true;
                    console.log( 75.5, hedgehog.state[ chan_id ].balances_before_most_recent_send );
                    console.log( 75.6, pending_htlc[ "amnt" ] );
                    console.log( 76, hedgehog.state[ chan_id ].balances );
                    console.log( amnt_to_send );
                    var sigs_and_stuff = hedgehog.send( chan_id, amnt_to_send, null, skip_pending_check );
                    console.log( 77, hedgehog.state[ chan_id ].balances );
                    // console.log( "send this data to your counterparty:" );
                    // console.log( JSON.stringify( sigs_and_stuff ) );
                    hedgehog.state[ chan_id ].pending_htlc = {}
                    return sigs_and_stuff;
                },
                settleIncomingHTLC: async data => {
                    console.log( 0 );
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];
                    var preimage = data[ "preimage" ];

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //check if this channel has a pending htlc
                    var pending_htlc = hedgehog.state[ chan_id ].pending_htlc;
                    if ( !Object.keys( pending_htlc ).length ) return;

                    if ( am_alice && pending_htlc.from === "alice" ) return;
                    console.log( 0.5 );
                    if ( !am_alice && pending_htlc.from !== "alice" ) return;

                    console.log( 1 );

                    var expected_hash = pending_htlc.htlc_hash;
                    //ensure hashing the preimage won't crash the pc
                    var is_hex = hedgehog.isValidHex( preimage );
                    var is_right_size = preimage.length === 64;
                    if ( is_hex && is_right_size ) {
                        var actual_hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                        console.log( 1.5, expected_hash, actual_hash );
                        if ( expected_hash !== actual_hash ) return alert( `error regarding the hashes: expected_hash ${expected_hash} but got ${actual_hash} instead -- the preimage was ${preimage}` );
                    } else {
                        console.log( 'force close this channel and restore the previous state, and if it is linked to any related payments, force close those too and restore *their* previous state' );
                        console.log( 'broadcast this force close tx:' );
                        console.log( hedgehog.state[ chan_id ].pending_htlc.force_close_tx );
                        console.log( 'then wait 1996 blocks and broadcast this tx that funds the htlc:' );
                        console.log( hedgehog.state[ chan_id ].pending_htlc.from_force_close_to_htlc );
                        console.log( 'then wait 2016 blocks and broadcast this to restore the prior state:' );
                        console.log( hedgehog.state[ chan_id ].pending_htlc.restore_current_state_after_force_close );
                    }
                    console.log( 2 );

                    //mark htlc ready for resolution

                    hedgehog.state[ chan_id ].pending_htlc[ "htlc_preimage" ] = preimage;
                    hedgehog.state[ chan_id ].pending_htlc[ "time_when_preimage_was_received" ] = Math.floor( Date.now() / 1000 );

                    //add the preimage to the transactions that need it

                    var first_tx_to_fix = hedgehog.state[ chan_id ].pending_htlc.unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state;
                    var decoded_1 = tapscript.Tx.decode( first_tx_to_fix );
                    decoded_1.vin[ 0 ].witness = [ decoded_1.vin[ 0 ].witness[ 0 ], decoded_1.vin[ 0 ].witness[ 1 ], preimage, decoded_1.vin[ 0 ].witness[ 2 ], decoded_1.vin[ 0 ].witness[ 3 ] ];
                    var encoded_1 = tapscript.Tx.encode( decoded_1 ).hex;

                    console.log( 3 );

                    var second_tx_to_fix = hedgehog.state[ chan_id ].pending_htlc.conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state;
                    var decoded_2 = tapscript.Tx.decode( second_tx_to_fix );
                    decoded_2.vin[ 0 ].witness = [ decoded_2.vin[ 0 ].witness[ 0 ], decoded_2.vin[ 0 ].witness[ 1 ], preimage, decoded_2.vin[ 0 ].witness[ 2 ], decoded_2.vin[ 0 ].witness[ 3 ] ];
                    var encoded_2 = tapscript.Tx.encode( decoded_2 ).hex;

                    //save those transactions
                    hedgehog.state[ chan_id ].pending_htlc.unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state = encoded_1;
                    hedgehog.state[ chan_id ].pending_htlc.conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state = encoded_2;

                    console.log( 4 );

                    //TODO: set up a listener so that if 2016 blocks go by we force close
                    return `that went well, now your counterparty should run hedgehog.checkIfOutgoingHTLCIsSettled("${chan_id}")`;
                },
            }
        </script>
        <script>
            var waitSomeTime = num => new Promise( resolve => setTimeout( resolve, num ) );
            var bytesToHex = bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" );
            function convertHMS( value ) {
                if ( value < 0 ) value = 0;
                var sec = parseInt(value, 10); // convert value to number if it's string
                var years = Math.floor(sec / 31536000); // get years
                var months = Math.floor((sec - (years * 31536000)) / 2592000); // get months
                var days = Math.floor((sec - (years * 31536000) - (months * 2592000)) / 86400); // get days
                var hours = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400)) / 3600); // get hours
                var minutes = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600)) / 60); // get minutes
                var seconds = sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600) - (minutes * 60); //  get seconds
                var yearsstring = (years != 1) ? `years`:`year`;
                var monthsstring = (months != 1) ?  `months`:`month`;
                var daysstring = (days != 1) ? `days`:`day`;
                var hoursstring = (hours != 1) ? `hours`:`hour`;
                var minutesstring = (minutes != 1) ? `minutes`:`minute`;
                var secondsstring = (seconds != 1) ? `seconds`:`second`;
                return `${days} ${daysstring} ${minutes} ${minutesstring} ${seconds} seconds`;
            }
            var hexToText = hex => {
                var bytes = new Uint8Array( Math.ceil( hex.length / 2 ) );
                var i; for ( i=0; i<hex.length; i++ ) bytes[ i ] = parseInt( hex.substr( i * 2, 2 ), 16 );
                var text = new TextDecoder().decode( bytes );
                return text;
            }
            var textToHex = text => {
                var encoded = new TextEncoder().encode( text );
                return Array.from( encoded )
                    .map( x => x.toString( 16 ).padStart( 2, "0" ) )
                    .join( "" );
            }
            var shuffle = array => {
                var secureRandom = () => Number( `0.${parseInt( bytesToHex( window.crypto.getRandomValues( new Uint8Array( 7 ) ) ), 16 )}` );
                array = JSON.parse( JSON.stringify( array ) );
                var currentIndex = array.length, randomIndex;
                // While there remain elements to shuffle.
                while ( currentIndex > 0 ) {
                    // Pick a remaining element.
                    randomIndex = Math.floor( secureRandom() * currentIndex );
                    currentIndex--;
                    // And swap it with the current element.
                    [ array[ currentIndex ], array[ randomIndex ] ] = [
                        array[ randomIndex ], array[ currentIndex ]
                    ];
                }
                return array;
            }
            var isValidAddress = address => {
                try {
                    return !!tapscript.Address.decode( address ).script;
                } catch( e ) {return;}
                return;
            }
            var isValidBitcoinKey = key => {
                if ( key.length != 64 || key.length != 66 ) return;
                if ( key.length === 64 ) key = "02" + key;
                try {
                    return !!nobleSecp256k1.Point.fromCompressedHex( hexToBytes( key ) )
                } catch ( e ) {
                    return;
                }
            }
            var whosHereCleaner = async () => {
                var now = Math.floor( Date.now() / 1000 );
                Object.keys( whos_here ).forEach( participant => {
                    if ( now - whos_here[ participant ] > 30 ) delete whos_here[ participant ];
                });
                if ( Object.keys( whos_here ).length < 2 ) $( '.participant_count' ).innerText = `1 (just you)`;
                else $( '.participant_count' ).innerText = Object.keys( whos_here ).length;
                if ( params.hasOwnProperty( "admin" ) ) {
                    if ( !Object.keys( whos_here ).length ) $( '.participant_count' ).innerText = `0 (it's just you)`;
                    if ( Object.keys( whos_here ).length === 1 ) $( '.participant_count' ).innerText = 1;
                }
                await waitSomeTime( 1000 );
                whosHereCleaner();
            }
            var startSigning = async official_peers_and_utxos_list => {
                var peers_and_utxos = JSON.parse( official_peers_and_utxos_list );
                var peers = peers_and_utxos.value.randomized_peers;
                var utxos = peers_and_utxos.value.utxos_for_protocol;
                var sats_per_byte = peers_and_utxos.value.sats_per_byte;
                var change_address = peers_and_utxos.value.change_address;

                // Have every party insert the admins pubkey at the top of the pubkeys list
                peers.unshift( routing_node );
                all_peers = JSON.parse( JSON.stringify( peers ) );

                // Have every party independently validate that the list has no repeats
                var duplicates = peers.filter( ( item, index ) => peers.indexOf( item ) !== index );
                if ( duplicates.length ) return alert( `aborting because the admin scammed you by including some people twice in the multisig. Your money is probably gone forever.` );
                // Have every party independently validate that their pubkey is in the list
                if ( !peers.includes( pubkey ) ) return alert( `aborting because the admin scammed you by not including you in the multisig. Your money is probably gone forever.` );

                // Have every party independently validate that all pubkeys in the list are valid
                var all_keys_are_valid = true;
                peers.forEach( key => {
                    if ( !isValidBitcoinKey( key ) ) all_keys_are_valid = false;
                });

                // TODO: Have every party independently validate that those utxos exist
                // Have every party independently validate that those utxos are in segwit addresses (v0 or v1)
                var all_addys_are_segwit = true;
                var addys_in_utxo_list = [];
                utxos.forEach( utxo => addys_in_utxo_list.push( utxo[ "addy" ] ) );
                addys_in_utxo_list.forEach( addy => {
                    if ( !addy.startsWith( "bc1" ) && !addy.startsWith( "tb1" ) && !addy.startsWith( "bcrt1" ) ) all_addys_are_segwit = false;
                });
                if ( !all_addys_are_segwit ) return alert( `aborting because the admin scammed you by not using segwit addresses to fund the multisig, which means anyone can render all signatures invalid while the funding transaction is still in the mempool. Your money is probably gone forever.` );

                // Have every party independently validate that the utxos contain enough money to fund the multisig
                var required_sum = ( channel_size * peers.length ) + ( amount_per_user_to_cover_p2a_costs * peers.length ) + 830;
                var actual_sum = 0;
                utxos.forEach( utxo => actual_sum = actual_sum + utxo[ "amnt" ] );
                if ( actual_sum < required_sum ) return alert( `aborting because the admin scammed you by not providing enough money to fund the multisig, which means the funding transaction won't be valid. Your money is probably gone forever.` );

                // Have every party independently validate that the feerate chosen is sufficient
                // TODO: actually check a feerate source and ensure the feerate chosen is at or above the fast-track option
                if ( sats_per_byte < 1 ) return alert( `aborting because the admin scammed you by telling you to use an insufficient feerate, which means the funding transaction will probably never get mined. Your money is probably gone forever.` );

                // Have every party independently validate that the change address is valid
                if ( !isValidAddress( change_address ) ) return alert( `aborting because the admin scammed you by telling you to send their change to an invalid bitcoin address, which means the funding transaction won't be valid. Your money is probably gone forever.` );

                // Have every party independently create an n of n multisig owned by the pubkeys mentioned in the first bullet point of this section
                peers.forEach( ( key, index ) => script.push( key, "OP_CHECKSIGVERIFY" ) );
                script.pop();
                script.push( "OP_CHECKSIG" );
                scripts.push( script );
                tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                var tapleaf = tree[ 0 ];
                var [ tpubkey ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tapleaf, tree });
                multisig = tapscript.Address.p2tr.fromPubKey( tpubkey, address_type );

                // Have every party independently create the 1-or-2 output transaction depositing the right amount of money into the multisig and giving the change, if any, back to the admin
                var vin = [];
                utxos.forEach( utxo => {
                    vin.push({
                        txid: utxo[ "txid" ],
                        vout: utxo[ "vout" ],
                        prevout: {
                            value: utxo[ "amnt" ],
                            scriptPubKey: tapscript.Address.toScriptPubKey( utxo[ "addy" ] ),
                        }
                    });
                });
                var change_amnt = actual_sum - required_sum;
                var vout = [{
                    value: required_sum - 830,
                    scriptPubKey: tapscript.Address.toScriptPubKey( multisig ),
                }];
                // TODO: ensure you apply the tx fee per the feerate value
                if ( change_amnt >= 830 ) vout.push({
                    value: change_amnt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( change_address ),
                });
                funding_tx = tapscript.Tx.create({
                    vin,
                    vout,
                });
                var num_of_users = peers.length;

                // Have every party prepare the midstate scripts
                var i; for ( i=0; i<num_of_users; i++ ) {
                    var scripts_for_this_midstate = [];
                    var j; for ( j=0; j<num_of_users; j++ ) {
                        var midstate_script = JSON.parse( JSON.stringify( script ) );
                        scripts_for_this_midstate.push( midstate_script );
                    }
                    midstate_scripts.push( scripts_for_this_midstate );
                }

                // Have every party prepare the midstate addresses
                midstate_scripts.forEach( scripts => {
                    var midstate_tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    midstate_trees.push( midstate_tree );
                    var [ tpubkey ] = tapscript.Tap.getPubKey( backup_pubkey, { tree: midstate_tree });
                    var midstate_address = tapscript.Address.p2tr.fromPubKey( tpubkey, address_type );
                    midstate_addresses.push( midstate_address );
                });

                // Have every party independently create a 10 step exit ladder using my tornado factory protocol so that the money for each participant is guaranteed to end up in a 2 of 2 multisig owned by that participants pubkey and the admin's
                var every_partys_2_of_2 = [];
                peers.forEach( key => {
                    var two_of_two_script = [ key, "OP_CHECKSIGVERIFY", routing_node, "OP_CHECKSIG" ];
                    var two_of_two_tree = [ tapscript.Tap.encodeScript( two_of_two_script ) ];
                    var two_of_two_addy = hedgehog.makeAddress( [ two_of_two_script ] );
                    every_partys_2_of_2.push( two_of_two_addy );
                });
                // Generate n presigned txs, to which each user gets a copy
                var funding_amount = channel_size;
                var i; for ( i=0; i<num_of_users; i++ ) {
                    var txid = rounds.length ? tapscript.Tx.util.getTxid( rounds[ rounds.length - 1 ] ) : tapscript.Tx.util.getTxid( funding_tx );
                    var round = tapscript.Tx.create({
                        version: 3,
                        vin: [{
                            txid,
                            vout: rounds.length ? 2 : 0,
                            prevout: rounds.length ? rounds[ rounds.length - 1 ].vout[ 2 ] : funding_tx.vout[ 0 ],
                        }],
                        vout: [{
                            value: 240,
                            scriptPubKey: "51024e73",
                        },{
                            value: funding_amount + amount_per_user_to_cover_p2a_costs - 330 - 240,
                            scriptPubKey: tapscript.Address.toScriptPubKey( midstate_addresses[ i ] ),
                        }],
                    });
                    if ( i !== num_of_users - 1 ) {
                        round.vout.push({
                            value: ( funding_amount * num_of_users ) + ( amount_per_user_to_cover_p2a_costs * num_of_users ) - ( funding_amount * ( i + 1 ) ) - ( amount_per_user_to_cover_p2a_costs * ( i + 1 ) ) - ( 330 * num_of_users ),
                            scriptPubKey: tapscript.Address.toScriptPubKey( multisig ),
                        });
                    }
                    if ( !i ) {
                        var j; for ( j=0; j<num_of_users; j++ ) {
                            round.vout.push({
                                value: 330,
                                scriptPubKey: tapscript.Address.toScriptPubKey( multisig ),
                            });
                        }
                    }
                    if ( !i ) {
                        var j; for ( j=0; j<num_of_users; j++ ) {
                            connector_utxos.push({
                                txid: tapscript.Tx.util.getTxid( round ),
                                vout: j + 3,
                                prevout: round.vout[ j + 3 ],
                            });
                        }
                    }
                    var sigs = [];
                    var tapleaf = tree[ 0 ];
                    var sig = tapscript.Signer.taproot.sign( privkey, round, 0, { extension: tapleaf }).hex;
                    sigs.push( sig );
                    rounds.push( round );
                    round_sigs.push( sigs );
                }
                // Have every party sign transactions allowing every other party to exit into that multisig
                //allow each user to unilaterally exit in each round
                //each user needs the ability to withdraw from the midstate in any round
                //therefore, I must make n*n*n sigs -- there are n users who need to exit
                //and n rounds to exit in, and each user, in order to exit in that round,
                //needs n sigs
                //each key needs to sign n*n ejection transactions
                //the ejection transaction is different for each user
                //in each round so let's make the other two loops
                var totalnum = 0;
                var i; for ( i=0; i<num_of_users; i++ ) {
                    if ( !i ) console.log( `0 out of ${( num_of_users ** 2 ) * 2} signatures created` );
                    //in the codeblock beginning above, i represents a round
                    var all_ejection_sigs_for_this_round = [];
                    var all_connector_sigs_for_this_round = [];
                    var all_withdrawal_txids_for_this_round = [];
                    var all_ejection_txs_for_this_round = [];
                    var j; for ( j=0; j<num_of_users; j++ ) {
                        //in the codeblock beginning above, j represents a user
                        var eject_user_tx = tapscript.Tx.create({
                            version: 3,
                            vin: [{
                                txid: tapscript.Tx.util.getTxid( rounds[ i ] ),
                                vout: 1,
                                prevout: rounds[ i ].vout[ 1 ],
                            }],
                            vout: [{
                                value: 240,
                                scriptPubKey: "51024e73",
                            },{
                                //note that the round made an output of funding_amount - 240
                                //and this tx is spending that and taking out an *additional*
                                //240 for output 0 -- so it's funding_amount - 240 - 240
                                //todo: change the scriptPubKey to a 2 of 2 multisig with a
                                //routing node
                                value: funding_amount + amount_per_user_to_cover_p2a_costs - 240 - 240,
                                scriptPubKey: tapscript.Address.toScriptPubKey( every_partys_2_of_2[ j ] ),
                            }],
                        });
                        eject_user_tx.vin.push( connector_utxos[ j ] );
                        var txid_of_this_withdrawal_tx = tapscript.Tx.util.getTxid( eject_user_tx );
                        all_withdrawal_txids_for_this_round.push( txid_of_this_withdrawal_tx );
                        all_ejection_txs_for_this_round.push( eject_user_tx );
                        //I will use the tapleaf that lets one user alone leave after revealing his or her first withdrawal secret
                        //in round 1, the tapleaf I need for the first user is midstate_trees[ 0 ][ 0 ]
                        //in round 1, the tapleaf I need for the second user is midstate_trees[ 0 ][ 1 ]
                        //etc.
                        //in round 2, the tapleaf I need for the first user is midstate_trees[ 1 ][ 0 ]
                        //in round 2, the tapleaf I need for the second user is midstate_trees[ 1 ][ 1 ]
                        //etc.
                        var midstate_tapleaf = midstate_trees[ i ][ j ];
                        var connector_tapleaf = tree[ 0 ];
                        var [ _, cblock ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tapleaf, tree: midstate_trees[ i ] });
                        var sigs_for_this_user_for_this_round = [];
                        var connector_sigs_for_this_user_for_this_round = [];
                        var sig = tapscript.Signer.taproot.sign( privkey, eject_user_tx, 0, { extension: midstate_tapleaf } ).hex;
                        totalnum = totalnum + 1;
                        console.log( `${totalnum} out of ${( num_of_users ** 2 ) * 2} signatures created` );
                        sigs_for_this_user_for_this_round.push( sig );
                        var connector_sig = tapscript.Signer.taproot.sign( privkey, eject_user_tx, 1, { extension: connector_tapleaf } ).hex;
                        totalnum = totalnum + 1;
                        console.log( `${totalnum} out of ${( num_of_users ** 2 ) * 2} signatures created` );
                        connector_sigs_for_this_user_for_this_round.push( connector_sig );
                        all_ejection_sigs_for_this_round.push( sigs_for_this_user_for_this_round );
                        all_connector_sigs_for_this_round.push( connector_sigs_for_this_user_for_this_round );
                    }
                    if ( i === num_of_users - 1 ) console.log( 'done!' );
                    user_ejection_sigs.push( all_ejection_sigs_for_this_round );
                    connector_sigs.push( all_connector_sigs_for_this_round );
                    ejection_txs.push( all_ejection_txs_for_this_round );
                    withdrawal_txids.push( all_withdrawal_txids_for_this_round );
                }
                // Have every party (except the admin) give the admin their signatures and any data needed to unilaterally eject them from the multisig
                var sigs_to_send = [];
                round_sigs.forEach( sig_array => sigs_to_send.push( sig_array[ 0 ] ) );
                var i; for ( i=0; i<user_ejection_sigs.length; i++ ) {
                    var j; for ( j=0; j<user_ejection_sigs[ i ].length; j++ ) {
                        sigs_to_send.push( user_ejection_sigs[ i ][ j ][ 0 ] );
                    }
                }
                var i; for ( i=0; i<connector_sigs.length; i++ ) {
                    var j; for ( j=0; j<connector_sigs[ i ].length; j++ ) {
                        sigs_to_send.push( connector_sigs[ i ][ j ][ 0 ] );
                    }
                }
                if ( peers[ 0 ] !== pubkey ) node.send( 'sigs', JSON.stringify( sigs_to_send ), peers[ 0 ], msg_id );
                else all_sigs_needed_by_admin[ pubkey ] = sigs_to_send;
                // Have every party give the admin signatures and hashes which, per my hedgehog protocol, allow the admin to create an initial state for the 2 of 2 multisig such that the admin can withdraw everything from it
                // Then have the admin broadcast the funding transaction and the protocol is done
            }
            var validateAndBroadcast = async () => {
                var num_of_round_sigs_in_each_set = all_peers.length;
                var unsorted_sigs = JSON.parse( JSON.stringify( all_sigs_needed_by_admin ) );
                var round_sigs = [];
                var user_ejection_sigs = [];
                var connector_sigs = [];
                all_peers.forEach( peer => {
                    round_sigs.push( [ ...unsorted_sigs[ peer ].splice( 0, all_peers.length ) ] );
                    user_ejection_sigs.push( [ ...unsorted_sigs[ peer ].splice( 0, all_peers.length ** 2 ) ] );
                    connector_sigs.push( [ ...unsorted_sigs[ peer ].splice( 0, all_peers.length ** 2 ) ] );
                });
                // console.log( 0 );
                // console.log( round_sigs );
                // console.log( user_ejection_sigs );
                // console.log( connector_sigs );
                var i; for ( i=0; i<round_sigs.length; i++ ) {
                    var sorted = [];
                    var j; for ( j=0; j<round_sigs.length; j++ ) sorted.push( round_sigs[ j ][ i ] );
                    sorted_round_sigs.push( sorted );
                }
                var naughty_peers = [];
                var i; for ( i=0; i<sorted_round_sigs.length; i++ ) {
                    //i represents the round
                    var sig_array = sorted_round_sigs[ i ];
                    var round = rounds[ i ];
                    var target = tree[ 0 ];
                    var sighash = tapscript.Signer.taproot.hash( round, 0, { extension: target });
                    var j; for ( j=0; j<sig_array.length; j++ ) {
                        //j represents the user whose sig we are checking
                        //and we skip checking our own
                        if ( !j ) continue;
                        var sig = sig_array[ j ];
                        var is_valid = await nobleSecp256k1.schnorr.verify( sig, sighash, all_peers[ j ] );
                        if ( !is_valid && !naughty_peers.includes( all_peers[ j ] ) ) naughty_peers.push( all_peers[ j ] );
                    }
                }
                //TODO: eject any naughty peers
                console.log( 0, `naughty_peers:`, naughty_peers.length );
                //the following loop makes it so that the first n sig_arrays in the
                //sorted_user_ejection_sigs array and in the sorted_connector_sigs array
                //eject all users from the first round, in the order given by all_peers
                //(so the first array ejects user 1, the second array ejects user 2, etc.)
                //the second n sig_arrays eject all users from the second round, etc.
                //this should make it easy to make buttons to eject any user from any round
                //if we are in the first round, I can have buttons to eject user 1, user 2,
                //etc. and each one just grabs the next sig_array and makes a tx using them
                //when the first round is done I can discard the first n sig_arrays and keep
                //the rest of the code the same, and keep repeating that for all rounds
                var i; for ( i=0; i<all_peers.length ** 2; i++ ) {
                    var sorted_1 = [];
                    var sorted_2 = [];
                    var j; for ( j=0; j<user_ejection_sigs.length; j++ ) {
                        sorted_1.push( user_ejection_sigs[ j ][ i ] );
                        sorted_2.push( connector_sigs[ j ][ i ] );
                    }
                    sorted_user_ejection_sigs.push( sorted_1 );
                    sorted_connector_sigs.push( sorted_2 );
                }
                //now I take the sorted_user_ejection_sigs and sorted_connector_sigs and group
                //their sig_arrays by round
                var grouped_1 = [];
                var grouped_2 = [];
                var i; for ( i=0; i<all_peers.length; i++ ) {
                    var round_group_1 = [ ...sorted_user_ejection_sigs.splice( 0, all_peers.length ) ];
                    var round_group_2 = [ ...sorted_connector_sigs.splice( 0, all_peers.length ) ];
                    grouped_1.push( round_group_1 );
                    grouped_2.push( round_group_2 );
                }
                sorted_user_ejection_sigs = grouped_1;
                sorted_connector_sigs = grouped_2;
                var i; for ( i=0; i<ejection_txs.length; i++ ) {
                    //i represents a round
                    var sig_array_1 = sorted_user_ejection_sigs[ i ];
                    var sig_array_2 = sorted_connector_sigs[ i ];
                    var j; for ( j=0; j<all_peers.length; j++ ) {
                        //j represents the user being ejected
                        var ejection_tx = ejection_txs[ i ][ j ];
                        var ejection_sigs_for_this_user = sig_array_1[ j ];
                        var connector_sigs_for_this_user = sig_array_2[ j ];
                        var midstate_tapleaf = midstate_trees[ i ][ j ];
                        var connector_tapleaf = tree[ 0 ];
                        var midstate_sighash = tapscript.Signer.taproot.hash( ejection_tx, 0, { extension: midstate_tapleaf });
                        var connector_sighash = tapscript.Signer.taproot.hash( ejection_tx, 1, { extension: connector_tapleaf });
                        var k; for ( k=0; k<ejection_sigs_for_this_user.length; k++ ) {
                            //k represents the user whose sig we are checking
                            //and we skip checking our own
                            if ( !k ) continue;
                            var sig_1 = ejection_sigs_for_this_user[ k ];
                            var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, midstate_sighash, all_peers[ k ] );
                            if ( !is_valid_1 && !naughty_peers.includes( all_peers[ k ] ) ) naughty_peers.push( all_peers[ k ] );
                            var sig_2 = connector_sigs_for_this_user[ k ];
                            var is_valid_2 = await nobleSecp256k1.schnorr.verify( sig_2, connector_sighash, all_peers[ k ] );
                            if ( !is_valid_2 && !naughty_peers.includes( all_peers[ k ] ) ) naughty_peers.push( all_peers[ k ] );
                        }
                    }
                }
                //TODO: eject any naughty peers
                console.log( 1, `naughty_peers:`, naughty_peers.length );
                // console.log( 1 );
                // console.log( sorted_round_sigs );
                // console.log( sorted_user_ejection_sigs );
                // console.log( sorted_connector_sigs );
                var i; for ( i=0; i<all_peers.length; i++ ) $( '.ejection_buttons' ).innerHTML = $( '.ejection_buttons' ).innerHTML + `<button onclick="ejectUser( ${i} );" class="eject_user_btn">Eject user ${i + 1}</button>`;
                showPage( 'ejection_buttons' );
                var sig_for_funding_tx = tapscript.Signer.taproot.sign( privkey, funding_tx, 0 );
                funding_tx.vin[ 0 ].witness = [ sig_for_funding_tx ];
                var txhex = tapscript.Tx.encode( funding_tx ).hex;
                console.log( 'broadcast this:' );
                console.log( txhex );
            }
            var ejectUser = e => {
                // var user = Number( e.target.getAttribute( "data-usernum" ) );
                // e.target.parentElement.parentElement.style.backgroundColor = "pink";
                // e.target.parentElement.parentElement.getElementsByClassName( "off_chain_balance" )[ 0 ].innerText = 0;
                // e.target.parentElement.parentElement.getElementsByClassName( "on_chain_balance" )[ 0 ].innerText = funding_amount;
                // e.target.disabled = true;
                var user = e;
                var round = current_round;
                var tapleaf = tree[ 0 ];
                var [ _, cblock ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tapleaf, tree });
                rounds[ round ].vin[ 0 ].witness = [ ...sorted_round_sigs[ round ].reverse(), scripts[ 0 ], cblock ];

                //to spend from the user's branch, get a utxo that you can pay the mining fee with
                var admin_addy = tapscript.Address.fromScriptPubKey( [ 1, pubkey ], address_type );
                var fee_for_round = 2 * all_peers.length * average_bytesize_of_each_users_input;
                console.log( `please send ${fee_for_round} sats to this address:` );
                console.log( admin_addy );
                var txid2 = prompt( `You are about to eject the user you selected. Please send ${fee_for_round} sats to the address in your console so that your user can pay the mining fee for their exit transaction, then enter the txid of your deposit` );
                var vout2 = Number( prompt( `and the vout` ) );
                var amnt2 = Number( prompt( `and the amount` ) );

                var round_fee_tx = tapscript.Tx.create({
                    version: 3,
                    vin: [{
                        txid: tapscript.Tx.util.getTxid( rounds[ round ] ),
                        vout: 0,
                        prevout: rounds[ round ].vout[ 0 ],
                    },{
                        txid: txid2,
                        vout: vout2,
                        prevout: {
                            value: amnt2,
                            scriptPubKey: [ 1, pubkey ],
                        }
                    }],
                    vout: [{
                        value: ( all_peers.length * average_bytesize_of_each_users_input ) - 240,
                        scriptPubKey: [ 1, pubkey ],
                    }],
                });

                //sign for the input that pays the round fee
                var sig = tapscript.Signer.taproot.sign( privkey, round_fee_tx, 1 ).hex;
                round_fee_tx.vin[ 1 ].witness = [ sig ];

                var eject_user_tx = ejection_txs[ round ][ user ];
                var eject_user_sigs = sorted_user_ejection_sigs[ round ][ user ].reverse();
                var my_connector_sigs = sorted_connector_sigs[ round ][ user ].reverse();
                var tapleaf = midstate_trees[ round ][ user ];
                var [ _, cblock ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tapleaf, tree: midstate_trees[ round ] });
                eject_user_tx.vin[ 0 ].witness = [ ...eject_user_sigs, midstate_scripts[ round ][ user ], cblock ];
                var [ _, cblock ] = tapscript.Tap.getPubKey( backup_pubkey, { target: tree[ 0 ], tree: tree });
                eject_user_tx.vin[ 1 ].witness = [ ...my_connector_sigs, scripts[ 0 ], cblock ];

                var exit_fee_tx = tapscript.Tx.create({
                    version: 3,
                    vin: [{
                        txid: tapscript.Tx.util.getTxid( eject_user_tx ),
                        vout: 0,
                        prevout: eject_user_tx.vout[ 0 ],
                    },{
                        txid: tapscript.Tx.util.getTxid( round_fee_tx ),
                        vout: 0,
                        prevout: round_fee_tx.vout[ 0 ],
                    }],
                    vout: [{
                        value: 0,
                        scriptPubKey: [ "OP_RETURN", "" ],
                    }],
                });

                //sign for the input that pays the exit fee
                var sig = tapscript.Signer.taproot.sign( privkey, exit_fee_tx, 1 ).hex;
                exit_fee_tx.vin[ 1 ].witness = [ sig ];

                //show the admin the raw transaction hex for creating the midstate
                var txhex = tapscript.Tx.encode( rounds[ round ] ).hex;
                console.log( `broadcast this round_${round} tx that lets any user leave:` );
                console.log( txhex );

                //show the admin the raw transaction hex for paying the round fee
                var txhex = tapscript.Tx.encode( round_fee_tx ).hex;
                console.log( `broadcast this round_fee_tx tx that pays the fee for this round:` );
                console.log( txhex );
                console.log( `then wait for the round transaction and the round_fee_tx to confirm` );

                //show the admin the raw transaction hex for ejecting whoever they picked to eject
                var txhex = tapscript.Tx.encode( eject_user_tx ).hex;
                console.log( `broadcast this eject_user_tx that ejects the user you selected:` );
                console.log( txhex );

                //show the admin the raw transaction hex for paying the exit fee
                var txhex = tapscript.Tx.encode( exit_fee_tx ).hex;
                console.log( `broadcast this exit_fee_tx tx that pays the fee for the eject_user_tx:` );
                console.log( txhex );
                current_round = round + 1;
                $$( '.eject_user_btn' )[ user ].disabled = true;
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 800px;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
                padding: 0;
            }
            body {
                margin: 3rem 1rem;
                word-wrap: break-word;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .hidden {
                display: none !important;
            }
            .minutes_selector {
                display: flex;
            }
            .minutes_selector span {
                margin-left: .5rem;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
            var hash_arr = window.location.href.substring( window.location.href.indexOf( "#" ) ).split( "#" );
            hash_arr.splice( 0, 1 );
            var params = {}
            hash_arr.forEach( item => {
                var vals = item.split( "=" );
                params[ vals[ 0 ] ] = vals[ 1 ];
            });
        </script>
    </head>
    <body>
        <h1>Channel Service</h1>
        <div class="schedule_signing_ceremony">
            <p>Pick how long you're willing to wait for people to show up to your signing ceremony</p>
            <p class="minutes_selector"><input type="number" class="minutes_to_wait" value="1" step="1"><span>minutes</span></p>
            <p>Enter an nwc string so you can create invoices for your users</p>
            <p><input class="nwc_string_entry_form"></p>
            <p><button class="prep_ceremony">Submit</button></p>
        </div>
        <div class="ceremony_page hidden">
            <p>The signing ceremony will start before this timer runs out:</p>
            <p class="time_til_signing_ceremony"></p>
            <p>How many people are here (other than the admin): <span class="participant_count">loading...</span></p>
            <p>Minimum number of participants required: <span class="minimum_required"></span></p>
            <div class="user_only">
                <p>Instructions:</p>
                <p>When the admin starts the signing ceremony you will see a lightning invoice to purchase a hedgehog channel with <span class="channel_size"></span> sats of inbound capacity for <span class="channel_cost"></span> sats. Get your wallet ready! You will only have 1 minute to pay.</p>
            </div>
            <div class="admin_only hidden">
                <p>Instructions:</p>
                <p>Share this link with anyone you want to open channels for:</p>
                <p class="shareable_link"></p>
                <p><button class="start_signing_ceremony">Start signing ceremony</button></p>
            </div>
        </div>
        <div class="ejection_buttons admin_only hidden"></div>
        <script>
            var whos_here = {}
            var who_should_pay = {}
            var all_peers = [];
            var ceremony_started = false;
            var channel_cost = 1000;
            var channel_size = 100_000;
            var minimum = 3;
            var maximum = 20;
            var address_type = "regtest";
            var relays = ["wss://nostrue.com"];
            var privkey = bytesToHex( window.crypto.getRandomValues( new Uint8Array( 32 ) ) );
            if ( params[ "privkey" ] ) privkey = params[ "privkey" ];
            var pubkey = nobleSecp256k1.getPublicKey( privkey, true ).substring( 2 );
            var routing_node = pubkey;
            var scripts = [];
            var script = [];
            var tree = [];
            var multisig = null;
            var backup_pubkey = "a".repeat( 64 );
            var funding_tx = null;
            var rounds = [];
            var ejection_txs = [];
            var round_sigs = [];
            var midstate_scripts = [];
            var midstate_trees = [];
            var midstate_addresses = [];
            var connector_utxos = [];
            var user_ejection_sigs = [];
            var connector_sigs = [];
            var withdrawal_txids = [];
            var all_sigs_needed_by_admin = {}
            var sorted_round_sigs = [];
            var sorted_user_ejection_sigs = [];
            var sorted_connector_sigs = [];
            var current_round = 0;
            var amount_per_user_to_cover_p2a_costs = 240 * 2;
            var average_bytesize_of_each_users_input = 200;
            if ( params.hasOwnProperty( "routing_node" ) ) routing_node = params.routing_node;
            var node = nostr_p2p( relays, privkey );
            var msg_id = null;
            $( '.channel_cost' ).innerText = channel_cost;
            $( '.channel_size' ).innerText = channel_size.toLocaleString();
            var showPage = page => {
                $( '.schedule_signing_ceremony' ).classList.add( "hidden" );
                $( '.ceremony_page' ).classList.add( "hidden" );
                $( '.ejection_buttons' ).classList.add( "hidden" );
                $( `.${page}` ).classList.remove( "hidden" );
            }
            if ( !params[ "ceremony" ] ) {
                $( '.minutes_to_wait' ).value = 1;
                $( '.nwc_string_entry_form' ).value = "";
                $( '.prep_ceremony' ).onclick = () => {
                    var nwc_string = $( '.nwc_string_entry_form' ).value;
                    try {
                        var nwc_obj = nwcjs.processNWCstring( nwc_string );
                    } catch ( e ) {
                        return alert( `Your NWC string was invalid, try again` );
                    }
                    var minutes_to_wait = Number( $( '.minutes_to_wait' ).value );
                    var timestamp = Math.floor( Date.now() / 1000 ) + ( minutes_to_wait * 60 );
                    var timestamp_as_hex = timestamp.toString( 16 ).padStart( 8, "0" );
                    msg_id = timestamp_as_hex + bytesToHex( window.crypto.getRandomValues( new Uint8Array( 16 - 4 ) ) );
                    var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `#ceremony=${msg_id}#privkey=${privkey}#admin=true#nwc_string=${textToHex( nwc_string )}`;
                    window.location.href = url;
                    window.location.reload();
                }
            }
            if ( params[ "ceremony" ] ) {
                $( '.minimum_required' ).innerText = minimum;
                showPage( `ceremony_page` );
                var loop = async future => {
                    var now = Math.floor( Date.now() / 1000 );
                    var time_til_then = future - now >= 0 ? future - now : 0;
                    $( '.time_til_signing_ceremony' ).innerText = convertHMS( time_til_then );
                    await waitSomeTime( 1000 );
                    loop( future );
                }
                var future = parseInt( params[ "ceremony" ].substring( 0, 8 ), 16 );
                loop( future );
                var listenFunction = async socket => {
                    var subId = super_nostr.bytesToHex( crypto.getRandomValues( new Uint8Array( 8 ) ) );
                    var filter  = {}
                    filter.kinds = [ 52175 ];
                    filter[ "#e" ] = [ params[ "ceremony" ].padStart( 64, "0" ) ];
                    filter.since = Math.floor( Date.now() / 1000 ) - 30;
                    var subscription = [ "REQ", subId, filter ];
                    socket.send( JSON.stringify( subscription ) );
                }
                var handleFunction = async message => {
                    var [ type, subId, event ] = JSON.parse( message.data );
                    if ( !event || event === true ) return;
                    if ( !ceremony_started && event.pubkey !== routing_node ) whos_here[ event.pubkey ] = Math.floor( Date.now() / 1000 );
                }
                (async()=>{
                    msg_id = params[ "ceremony" ];
                    await node.connect();
                    node.event.on( 'init', console.log( 'connected to the p2p network!' ) );
                    node.inbox.on( msg_id, msg => {
                        //the admin ignores preparation messages that they themselves sent
                        if ( msg.tag === "preparation_phase" && params.hasOwnProperty( "admin" ) ) return;
                        //users ignore any messages from people other than the admin
                        if ( !params.hasOwnProperty( "admin" ) && msg.ctx.pubkey !== params.routing_node ) return;
                        //if the admin sends the "signing_phase" message, pass it to the startSigning function
                        if ( msg.ctx.pubkey === params.routing_node && msg.tag === "signing_phase" ) {
                            startSigning( msg.dat );
                            return;
                        }
                        //if the admin receives sigs, validate them and add them to the all_sigs_needed_by_admin object
                        if ( params.hasOwnProperty( "admin" ) && all_peers.includes( msg.ctx.pubkey ) && msg.tag === "sigs" ) {
                            //if you already have all the sigs you need, ignore the message
                            if ( Object.keys( all_sigs_needed_by_admin ).length === all_peers.length ) return;
                            all_sigs_needed_by_admin[ msg.ctx.pubkey ] = JSON.parse( msg.dat );
                            //if you now have all the sigs you need, broadcast the funding tx
                            if ( Object.keys( all_sigs_needed_by_admin ).length === all_peers.length ) validateAndBroadcast();
                            return;
                        }
                        console.log( 'received msg:', msg.id, msg.dat );
                    });
                    var connection = super_nostr.newPermanentConnection( relays[ 0 ], listenFunction, handleFunction );
                    console.log( `loading...` );
                    await waitSomeTime( 2000 );
                    console.log( `ready!` );
                    var loop = async () => {
                        var event = await super_nostr.prepEvent( privkey, "", 52175, [ [ "e", params[ "ceremony" ].padStart( 64, "0" ) ] ] );
                        super_nostr.sendEvent( event, relays[ 0 ] );
                        await waitSomeTime( 25000 );
                        loop();
                    }
                    loop();
                })();
                whosHereCleaner();
                if ( params.hasOwnProperty( "admin" ) ) {
                    $( '.ceremony_page p' ).innerText = `Start the signing ceremony before this timer runs out:`;
                    $( '.participant_count' ).parentElement.innerHTML = `How many people are here (other than you): <span class="participant_count">loading...</span>`;
                    $$( '.user_only' ).forEach( item => item.classList.add( "hidden" ) );
                    $$( '.admin_only' ).forEach( item => item.classList.remove( "hidden" ) );
                    var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `#ceremony=${params[ "ceremony" ]}#routing_node=${pubkey}`;
                    $( '.shareable_link' ).innerText = url;
                    var nwc_obj = nwcjs.processNWCstring( hexToText( params.nwc_string ) );
                }
            }
            $( '.start_signing_ceremony' ).onclick = async () => {
                console.log( 'starting ceremony...' );
                msg_id = params[ "ceremony" ];
                ceremony_started = true;
                var peers = Object.keys( whos_here );
                if ( peers.length > maximum ) {
                    //TODO: send a message to anyone who gets cut off telling them
                    //to try again later
                    var cut_off_people = JSON.parse( JSON.stringify( peers ) );
                    cut_off_people = cut_off_people.splice( 0, maximum );
                    peers.length = maximum;
                    var msg = JSON.stringify({
                        type: "abort",
                        value: `You have been excluded from this channel factory because we exceeded the maximum number of people allowed. Please try again in a different channel factory.`
                    });
                    node.relay( 'preparation_phase', msg, cut_off_people, msg_id );
                }
                if ( peers.length < minimum ) {
                    console.log( 'not enough' );
                    var msg = JSON.stringify({
                        type: "abort",
                        value: `Aborting because we did not have enough participants. Only ${peers.length} people showed up when there was a required minimum of ${minimum}, so well have to try again later. Please bring more people next time.`
                    });
                    node.relay( 'preparation_phase', msg, peers, msg_id );
                    return;
                }
                console.log( 'yay, there are enough peers!' );
                peers.forEach( async ( peer, index ) => {
                    console.log( `getting an invoice for ${peer}` );
                    var delay_tolerance = 10;
                    var invoice_data = await nwcjs.makeInvoice( nwcjs.nwc_infos[ 0 ], channel_cost, "", delay_tolerance );
                    if ( invoice_data.hasOwnProperty( "error" ) && invoice_data.error ) throw "your nwc string is not giving you invoices, check what's wrong";
                    console.log( invoice_data );
                    var invoice = invoice_data.result.invoice;
                    who_should_pay[ peer ] = [ "not_paid", invoice ];
                    console.log( `sending ${peer} their invoice` );
                    var msg = JSON.stringify({
                        type: "pay_invoice",
                        value: invoice,
                    });
                    node.send( 'preparation_phase', msg, peers[ index ], msg_id );
                    var start_time = Math.floor( Date.now() / 1000 );
                    console.log( `in 10 seconds we will check if ${peer}'s invoice is paid` );
                    var loop = async () => {
                        await waitSomeTime( 10 * 1000 );
                        console.log( `checking if ${peer}'s invoice is paid` );
                        var now = Math.floor( Date.now() / 1000 );
                        var status_data = await nwcjs.checkInvoice( nwcjs.nwc_infos[ 0 ], invoice, delay_tolerance );
                        if ( now - start_time > 60 ) return console.log( `timing out this peer: ${peer}` );
                        console.log( `${peer}'s invoice is paid, right?`, !!status_data.result.settled_at );
                        //if settled_at is null I should loop
                        if ( !status_data.result.settled_at ) {
                            console.log( `in another 10 seconds we will check again if ${peer}'s invoice is paid` );
                            return loop();
                        }
                        //otherwise I should mark them as paid
                        who_should_pay[ peer ][ 0 ] = "paid";
                        console.log( `${peer} paid` );
                        var msg = JSON.stringify({
                            type: "invoice_paid",
                            value: ``,
                        });
                        node.send( 'preparation_phase', msg, peers[ index ], msg_id );
                    }
                    await loop();
                });
                //abort if, after 60 seconds, not enough people paid to meet your minimum
                //TODO: change the wait time to 60000
                await waitSomeTime( 12000 );
                //TODO: delete the lines below, which pretend everyone paid
                peers.forEach( peer => who_should_pay[ peer ][ 0 ] = "paid" );
                peers.forEach( peer => all_peers.push( peer ) );
                var num_who_paid = Object.keys( who_should_pay ).length;
                Object.keys( who_should_pay ).forEach( participant => {
                    if ( who_should_pay[ participant ][ 0 ] !== "paid" ) num_who_paid = num_who_paid - 1;
                });
                console.log( "num who paid:", num_who_paid, "minimum:", minimum );
                if ( num_who_paid < minimum ) {
                    console.log( 'not enough paid' );
                    console.log( who_should_pay );
                    var were_or_was = minimum - num_who_paid === 1 ? "was a troll" : "were trolls";
                    var msg = JSON.stringify({
                        type: "abort",
                        value: `Aborting because ${peers.length} people registered (which is enough because the minimum was ${minimum}) but ${minimum - num_who_paid} of them ${were_or_was}, so the number of real participants was less than ${minimum}, so well have to try again later. Please bring more people next time.`
                    });
                    node.relay( 'preparation_phase', msg, peers, msg_id );
                    return;
                }
                console.log( 'enough paid' );
                // Give everyone the list of participating pubkeys, sorted in random order (you got their pubkeys when they announced their presence)
                var randomized_peers = shuffle( JSON.parse( JSON.stringify( peers ) ) );
                // Give everyone the utxo data of a sufficient number of inputs to make your 1-or-2 output transaction (utxo data consists of a txid, a vout, an amount, and an address)
                var required_sum = ( channel_size * ( randomized_peers.length + 1 ) ) + ( amount_per_user_to_cover_p2a_costs * ( randomized_peers.length + 1 ) ) + 830;
                var admin_addy = tapscript.Address.fromScriptPubKey( [ 1, pubkey ], address_type );
                console.log( `send at least ${required_sum} to this address:` );
                console.log( admin_addy );
                var txid = prompt( `send at least ${required_sum} sats to the address in your console and enter the txid` );
                var vout = Number( prompt( `and the vout` ) );
                var amnt = Number( prompt( `and the amount` ) );
                var utxos_for_protocol = [{txid, vout, amnt, addy: admin_addy}];
                // Give everyone a feerate to use when creating the 1-or-2 output transaction
                // TODO: actually check a feerate source and ensure the feerate chosen is at or above the fast-track option
                var sats_per_byte = 1;
                // Give everyone a change address to send the change to when creating the 1-or-2 output transaction
                var change_address = "tb1phl9kvt953d9rwvwy322fjpdgf95wqvj0l9rhgfnwgknqgfcwdkwqwrfkf8";
                var msg = JSON.stringify({
                    type: "official_peers_and_utxos_list",
                    value: { randomized_peers, utxos_for_protocol, sats_per_byte, change_address },
                });
                node.relay( 'signing_phase', msg, peers, msg_id );
                startSigning( msg );
            }
        </script>
    </body>
</html>
